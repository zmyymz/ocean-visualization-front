{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.error.cause.js\";\n\n/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  let s = 0;\n\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1:\n      // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n\n      break;\n\n    case 2:\n      // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n\n      break;\n\n    case 3:\n      // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n\n        case 64:\n          return new Float64Array(size);\n\n        default:\n          break;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize); // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) {\n    // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip; // let sampleBitOffset = 0;\n\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample; // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    } // Bits per line rounds up to next byte boundary.\n\n\n    let bitsPerLine = tileWidth * pixelBitSkip;\n\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = bitsPerLine + 7 & ~7;\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;\n\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + i * bitsPerSample;\n          const outIndex = (y * tileWidth + x) * samplesToTransfer + i;\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);\n            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;\n          } else {\n            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;\n          } // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n\n        } // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n\n      }\n    }\n  } else if (format === 3) {// floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n/**\n * GeoTIFF sub-file image.\n */\n\n\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;\n\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n\n\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n\n\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n\n\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n\n\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n\n\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n\n\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n\n\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - y * this.getTileHeight();\n    }\n  }\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n\n\n  getBytesPerPixel() {\n    let bytes = 0;\n\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n\n    switch (format) {\n      case 1:\n        // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n\n        break;\n\n      case 2:\n        // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n\n        break;\n\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n\n          case 32:\n            return DataView.prototype.getFloat32;\n\n          case 64:\n            return DataView.prototype.getFloat64;\n\n          default:\n            break;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n\n\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const {\n      tiles\n    } = this;\n\n    if (this.planarConfiguration === 1) {\n      index = y * numTilesPerRow + x;\n    } else if (this.planarConfiguration === 2) {\n      index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;\n    }\n\n    let offset;\n    let byteCount;\n\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n\n    const slice = (await this.source.fetch([{\n      offset,\n      length: byteCount\n    }], signal))[0];\n    let request;\n\n    if (tiles === null || !tiles[index]) {\n      // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(data, sampleFormat, this.planarConfiguration, this.getSamplesPerPixel(), bitsPerSample, this.getTileWidth(), this.getBlockHeight(y));\n        }\n\n        return data;\n      })(); // set the cache\n\n\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    } // cache the tile request\n\n\n    return {\n      x,\n      y,\n      sample,\n      data: await request\n    };\n  }\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n\n\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));\n    const windowWidth = imageWindow[2] - imageWindow[0];\n    let bytesPerPixel = this.getBytesPerPixel();\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const {\n      littleEndian\n    } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          promises.push(promise);\n          promise.then(tile => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = (y * tileWidth + x) * bytesPerPixel;\n                const value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);\n                let windowCoordinate;\n\n                if (interleave) {\n                  windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n\n    await Promise.all(promises);\n\n    if (width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height) {\n      let resampled;\n\n      if (interleave) {\n        resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);\n      } else {\n        resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);\n      }\n\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n    return valueArrays;\n  }\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n\n\n  async readRasters({\n    window: wnd,\n    samples = [],\n    interleave,\n    pool = null,\n    width,\n    height,\n    resampleMethod,\n    fillValue,\n    signal\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n\n    let valueArrays;\n\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || (await getDecoder(this.fileDirectory));\n    const result = await this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);\n    return result;\n  }\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n\n\n  async readRGB({\n    window,\n    interleave = true,\n    pool = null,\n    width,\n    height,\n    resampleMethod,\n    enableAlpha = false,\n    signal\n  } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n\n      if (!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {\n        s = [];\n\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal\n      });\n    }\n\n    let samples;\n\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal\n    };\n    const {\n      fileDirectory\n    } = this;\n    const raster = await this.readRasters(subOptions);\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    } // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n\n\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n\n\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5]\n      });\n    }\n\n    return tiePoints;\n  }\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n\n\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n\n    const string = this.fileDirectory.GDAL_METADATA;\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter(item => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter(item => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n\n    return metadata;\n  }\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n\n\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n\n\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (tiePoints && tiePoints.length === 6) {\n      return [tiePoints[3], tiePoints[4], tiePoints[5]];\n    }\n\n    if (modelTransformation) {\n      return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n\n\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];\n    }\n\n    if (modelTransformation) {\n      return [modelTransformation[0], modelTransformation[5], modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n\n\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n\n\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n    const x1 = origin[0];\n    const y1 = origin[1];\n    const x2 = x1 + resolution[0] * this.getWidth();\n    const y2 = y1 + resolution[1] * this.getHeight();\n    return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n  }\n\n}\n\nexport default GeoTIFFImage;","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/geotiffimage.js"],"names":["getFloat16","getAttribute","findTagsByName","photometricInterpretations","ExtraSamplesValues","fromWhiteIsZero","fromBlackIsZero","fromPalette","fromCMYK","fromYCbCr","fromCIELab","getDecoder","resample","resampleInterleaved","sum","array","start","end","s","i","arrayForType","format","bitsPerSample","size","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","Error","needsNormalization","normalizeArray","inBuffer","planarConfiguration","samplesPerPixel","tileWidth","tileHeight","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","y","lineBitOffset","x","pixelBitOffset","bitOffset","outIndex","byteOffset","Math","floor","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","GeoTIFFImage","constructor","fileDirectory","geoKeys","dataView","littleEndian","cache","source","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","getWidth","ImageWidth","getHeight","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","min","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","length","getSampleByteSize","RangeError","ceil","getReaderForSample","sampleIndex","SampleFormat","prototype","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","byteCount","TileOffsets","TileByteCounts","StripByteCounts","slice","fetch","request","data","decode","sampleFormat","_readRaster","imageWindow","samples","valueArrays","interleave","width","height","resampleMethod","imageWidth","imageHeight","minXTile","max","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","push","promises","yTile","xTile","si","promise","then","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","value","call","windowCoordinate","Promise","all","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","apply","fill","valueArray","Array","isArray","result","readRGB","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","raster","ColorMap","red","green","blue","j","getTiePoints","ModelTiepoint","tiePoints","k","z","getGDALMetadata","metadata","GDAL_METADATA","string","items","filter","item","undefined","Number","inner","getGDALNoData","GDAL_NODATA","substring","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","origin","resolution","x1","y1","x2","y2"],"mappings":";;;;AAAA;AACA,SAASA,UAAT,QAA2B,sBAA3B;AACA,OAAOC,YAAP,MAAyB,4BAAzB;AACA,OAAOC,cAAP,MAA2B,gCAA3B;AAEA,SAASC,0BAAT,EAAqCC,kBAArC,QAA+D,cAA/D;AACA,SAASC,eAAT,EAA0BC,eAA1B,EAA2CC,WAA3C,EAAwDC,QAAxD,EAAkEC,SAAlE,EAA6EC,UAA7E,QAA+F,UAA/F;AACA,SAASC,UAAT,QAA2B,wBAA3B;AACA,SAASC,QAAT,EAAmBC,mBAAnB,QAA8C,eAA9C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAASC,GAAT,CAAaC,KAAb,EAAoBC,KAApB,EAA2BC,GAA3B,EAAgC;AAC9B,MAAIC,CAAC,GAAG,CAAR;;AACA,OAAK,IAAIC,CAAC,GAAGH,KAAb,EAAoBG,CAAC,GAAGF,GAAxB,EAA6B,EAAEE,CAA/B,EAAkC;AAChCD,IAAAA,CAAC,IAAIH,KAAK,CAACI,CAAD,CAAV;AACD;;AACD,SAAOD,CAAP;AACD;;AAED,SAASE,YAAT,CAAsBC,MAAtB,EAA8BC,aAA9B,EAA6CC,IAA7C,EAAmD;AACjD,UAAQF,MAAR;AACE,SAAK,CAAL;AAAQ;AACN,UAAIC,aAAa,IAAI,CAArB,EAAwB;AACtB,eAAO,IAAIE,UAAJ,CAAeD,IAAf,CAAP;AACD,OAFD,MAEO,IAAID,aAAa,IAAI,EAArB,EAAyB;AAC9B,eAAO,IAAIG,WAAJ,CAAgBF,IAAhB,CAAP;AACD,OAFM,MAEA,IAAID,aAAa,IAAI,EAArB,EAAyB;AAC9B,eAAO,IAAII,WAAJ,CAAgBH,IAAhB,CAAP;AACD;;AACD;;AACF,SAAK,CAAL;AAAQ;AACN,UAAID,aAAa,KAAK,CAAtB,EAAyB;AACvB,eAAO,IAAIK,SAAJ,CAAcJ,IAAd,CAAP;AACD,OAFD,MAEO,IAAID,aAAa,KAAK,EAAtB,EAA0B;AAC/B,eAAO,IAAIM,UAAJ,CAAeL,IAAf,CAAP;AACD,OAFM,MAEA,IAAID,aAAa,KAAK,EAAtB,EAA0B;AAC/B,eAAO,IAAIO,UAAJ,CAAeN,IAAf,CAAP;AACD;;AACD;;AACF,SAAK,CAAL;AAAQ;AACN,cAAQD,aAAR;AACE,aAAK,EAAL;AACA,aAAK,EAAL;AACE,iBAAO,IAAIQ,YAAJ,CAAiBP,IAAjB,CAAP;;AACF,aAAK,EAAL;AACE,iBAAO,IAAIQ,YAAJ,CAAiBR,IAAjB,CAAP;;AACF;AACE;AAPJ;;AASA;;AACF;AACE;AA/BJ;;AAiCA,QAAMS,KAAK,CAAC,uCAAD,CAAX;AACD;;AAED,SAASC,kBAAT,CAA4BZ,MAA5B,EAAoCC,aAApC,EAAmD;AACjD,MAAI,CAACD,MAAM,KAAK,CAAX,IAAgBA,MAAM,KAAK,CAA5B,KAAkCC,aAAa,IAAI,EAAnD,IAAyDA,aAAa,GAAG,CAAhB,KAAsB,CAAnF,EAAsF;AACpF,WAAO,KAAP;AACD,GAFD,MAEO,IAAID,MAAM,KAAK,CAAX,KAAiBC,aAAa,KAAK,EAAlB,IAAwBA,aAAa,KAAK,EAA1C,IAAgDA,aAAa,KAAK,EAAnF,CAAJ,EAA4F;AACjG,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASY,cAAT,CAAwBC,QAAxB,EAAkCd,MAAlC,EAA0Ce,mBAA1C,EAA+DC,eAA/D,EAAgFf,aAAhF,EAA+FgB,SAA/F,EAA0GC,UAA1G,EAAsH;AACpH;AACA,QAAMC,IAAI,GAAG,IAAIC,QAAJ,CAAaN,QAAb,CAAb;AACA,QAAMO,OAAO,GAAGN,mBAAmB,KAAK,CAAxB,GACZG,UAAU,GAAGD,SADD,GAEZC,UAAU,GAAGD,SAAb,GAAyBD,eAF7B;AAGA,QAAMM,iBAAiB,GAAGP,mBAAmB,KAAK,CAAxB,GACtB,CADsB,GAClBC,eADR;AAEA,QAAMO,QAAQ,GAAGxB,YAAY,CAACC,MAAD,EAASC,aAAT,EAAwBoB,OAAxB,CAA7B,CARoH,CASpH;;AAEA,QAAMG,OAAO,GAAGC,QAAQ,CAAC,IAAIC,MAAJ,CAAWzB,aAAX,CAAD,EAA4B,CAA5B,CAAxB;;AAEA,MAAID,MAAM,KAAK,CAAf,EAAkB;AAAE;AAClB;AACA,QAAI2B,YAAJ,CAFgB,CAGhB;;AACA,QAAIZ,mBAAmB,KAAK,CAA5B,EAA+B;AAC7BY,MAAAA,YAAY,GAAGX,eAAe,GAAGf,aAAjC,CAD6B,CAE7B;AACD,KAHD,MAGO;AACL0B,MAAAA,YAAY,GAAG1B,aAAf;AACD,KATe,CAWhB;;;AACA,QAAI2B,WAAW,GAAGX,SAAS,GAAGU,YAA9B;;AACA,QAAI,CAACC,WAAW,GAAG,CAAf,MAAsB,CAA1B,EAA6B;AAC3BA,MAAAA,WAAW,GAAIA,WAAW,GAAG,CAAf,GAAqB,CAAC,CAApC;AACD;;AAED,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,UAApB,EAAgC,EAAEW,CAAlC,EAAqC;AACnC,YAAMC,aAAa,GAAGD,CAAC,GAAGD,WAA1B;;AACA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,SAApB,EAA+B,EAAEc,CAAjC,EAAoC;AAClC,cAAMC,cAAc,GAAGF,aAAa,GAAIC,CAAC,GAAGT,iBAAJ,GAAwBrB,aAAhE;;AACA,aAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,iBAApB,EAAuC,EAAExB,CAAzC,EAA4C;AAC1C,gBAAMmC,SAAS,GAAGD,cAAc,GAAIlC,CAAC,GAAGG,aAAxC;AACA,gBAAMiC,QAAQ,GAAI,CAAEL,CAAC,GAAGZ,SAAL,GAAkBc,CAAnB,IAAwBT,iBAAzB,GAA8CxB,CAA/D;AAEA,gBAAMqC,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWJ,SAAS,GAAG,CAAvB,CAAnB;AACA,gBAAMK,cAAc,GAAGL,SAAS,GAAG,CAAnC;;AACA,cAAIK,cAAc,GAAGrC,aAAjB,IAAkC,CAAtC,EAAyC;AACvCsB,YAAAA,QAAQ,CAACW,QAAD,CAAR,GAAsBf,IAAI,CAACoB,QAAL,CAAcJ,UAAd,KAA8B,IAAIlC,aAAL,GAAsBqC,cAApD,GAAsEd,OAA3F;AACD,WAFD,MAEO,IAAIc,cAAc,GAAGrC,aAAjB,IAAkC,EAAtC,EAA0C;AAC/CsB,YAAAA,QAAQ,CAACW,QAAD,CAAR,GAAsBf,IAAI,CAACqB,SAAL,CAAeL,UAAf,KAA+B,KAAKlC,aAAN,GAAuBqC,cAAtD,GAAwEd,OAA7F;AACD,WAFM,MAEA,IAAIc,cAAc,GAAGrC,aAAjB,IAAkC,EAAtC,EAA0C;AAC/C,kBAAMwC,GAAG,GAAItB,IAAI,CAACqB,SAAL,CAAeL,UAAf,KAA8B,CAA/B,GAAqChB,IAAI,CAACoB,QAAL,CAAcJ,UAAU,GAAG,CAA3B,CAAjD;AACAZ,YAAAA,QAAQ,CAACW,QAAD,CAAR,GAAsBO,GAAG,IAAK,KAAKxC,aAAN,GAAuBqC,cAA/B,GAAiDd,OAAtE;AACD,WAHM,MAGA;AACLD,YAAAA,QAAQ,CAACW,QAAD,CAAR,GAAsBf,IAAI,CAACuB,SAAL,CAAeP,UAAf,KAA+B,KAAKlC,aAAN,GAAuBqC,cAAtD,GAAwEd,OAA7F;AACD,WAfyC,CAiB1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACD,SA/BiC,CAgClC;;AACD;AACF;AACF,GAtDD,MAsDO,IAAIxB,MAAM,KAAK,CAAf,EAAkB,CAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AAED,SAAOuB,QAAQ,CAACoB,MAAhB;AACD;AAED;AACA;AACA;;;AACA,MAAMC,YAAN,CAAmB;AACjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,aAAD,EAAgBC,OAAhB,EAAyBC,QAAzB,EAAmCC,YAAnC,EAAiDC,KAAjD,EAAwDC,MAAxD,EAAgE;AACzE,SAAKL,aAAL,GAAqBA,aAArB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKG,KAAL,GAAaF,KAAK,GAAG,EAAH,GAAQ,IAA1B;AACA,SAAKG,OAAL,GAAe,CAACP,aAAa,CAACQ,YAA9B;AACA,UAAMvC,mBAAmB,GAAG+B,aAAa,CAACS,mBAA1C;AACA,SAAKxC,mBAAL,GAA4B,OAAOA,mBAAP,KAA+B,WAAhC,GAA+C,CAA/C,GAAmDA,mBAA9E;;AACA,QAAI,KAAKA,mBAAL,KAA6B,CAA7B,IAAkC,KAAKA,mBAAL,KAA6B,CAAnE,EAAsE;AACpE,YAAM,IAAIJ,KAAJ,CAAU,+BAAV,CAAN;AACD;;AAED,SAAKwC,MAAL,GAAcA,MAAd;AACD;AAED;AACF;AACA;AACA;;;AACEK,EAAAA,gBAAgB,GAAG;AACjB,WAAO,KAAKV,aAAZ;AACD;AAED;AACF;AACA;AACA;;;AACEW,EAAAA,UAAU,GAAG;AACX,WAAO,KAAKV,OAAZ;AACD;AAED;AACF;AACA;AACA;;;AACEW,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKZ,aAAL,CAAmBa,UAA1B;AACD;AAED;AACF;AACA;AACA;;;AACEC,EAAAA,SAAS,GAAG;AACV,WAAO,KAAKd,aAAL,CAAmBe,WAA1B;AACD;AAED;AACF;AACA;AACA;;;AACEC,EAAAA,kBAAkB,GAAG;AACnB,WAAO,OAAO,KAAKhB,aAAL,CAAmBiB,eAA1B,KAA8C,WAA9C,GACH,KAAKjB,aAAL,CAAmBiB,eADhB,GACkC,CADzC;AAED;AAED;AACF;AACA;AACA;;;AACEC,EAAAA,YAAY,GAAG;AACb,WAAO,KAAKX,OAAL,GAAe,KAAKP,aAAL,CAAmBmB,SAAlC,GAA8C,KAAKP,QAAL,EAArD;AACD;AAED;AACF;AACA;AACA;;;AACEQ,EAAAA,aAAa,GAAG;AACd,QAAI,KAAKb,OAAT,EAAkB;AAChB,aAAO,KAAKP,aAAL,CAAmBqB,UAA1B;AACD;;AACD,QAAI,OAAO,KAAKrB,aAAL,CAAmBsB,YAA1B,KAA2C,WAA/C,EAA4D;AAC1D,aAAOhC,IAAI,CAACiC,GAAL,CAAS,KAAKvB,aAAL,CAAmBsB,YAA5B,EAA0C,KAAKR,SAAL,EAA1C,CAAP;AACD;;AACD,WAAO,KAAKA,SAAL,EAAP;AACD;;AAEDU,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKN,YAAL,EAAP;AACD;;AAEDO,EAAAA,cAAc,CAAC1C,CAAD,EAAI;AAChB,QAAI,KAAKwB,OAAL,IAAgB,CAACxB,CAAC,GAAG,CAAL,IAAU,KAAKqC,aAAL,EAAV,IAAkC,KAAKN,SAAL,EAAtD,EAAwE;AACtE,aAAO,KAAKM,aAAL,EAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKN,SAAL,KAAoB/B,CAAC,GAAG,KAAKqC,aAAL,EAA/B;AACD;AACF;AAED;AACF;AACA;AACA;AACA;;;AACEM,EAAAA,gBAAgB,GAAG;AACjB,QAAIC,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAI3E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKgD,aAAL,CAAmB4B,aAAnB,CAAiCC,MAArD,EAA6D,EAAE7E,CAA/D,EAAkE;AAChE2E,MAAAA,KAAK,IAAI,KAAKG,iBAAL,CAAuB9E,CAAvB,CAAT;AACD;;AACD,WAAO2E,KAAP;AACD;;AAEDG,EAAAA,iBAAiB,CAAC9E,CAAD,EAAI;AACnB,QAAIA,CAAC,IAAI,KAAKgD,aAAL,CAAmB4B,aAAnB,CAAiCC,MAA1C,EAAkD;AAChD,YAAM,IAAIE,UAAJ,CAAgB,gBAAe/E,CAAE,mBAAjC,CAAN;AACD;;AACD,WAAOsC,IAAI,CAAC0C,IAAL,CAAU,KAAKhC,aAAL,CAAmB4B,aAAnB,CAAiC5E,CAAjC,IAAsC,CAAhD,CAAP;AACD;;AAEDiF,EAAAA,kBAAkB,CAACC,WAAD,EAAc;AAC9B,UAAMhF,MAAM,GAAG,KAAK8C,aAAL,CAAmBmC,YAAnB,GACX,KAAKnC,aAAL,CAAmBmC,YAAnB,CAAgCD,WAAhC,CADW,GACoC,CADnD;AAEA,UAAM/E,aAAa,GAAG,KAAK6C,aAAL,CAAmB4B,aAAnB,CAAiCM,WAAjC,CAAtB;;AACA,YAAQhF,MAAR;AACE,WAAK,CAAL;AAAQ;AACN,YAAIC,aAAa,IAAI,CAArB,EAAwB;AACtB,iBAAOmB,QAAQ,CAAC8D,SAAT,CAAmB3C,QAA1B;AACD,SAFD,MAEO,IAAItC,aAAa,IAAI,EAArB,EAAyB;AAC9B,iBAAOmB,QAAQ,CAAC8D,SAAT,CAAmB1C,SAA1B;AACD,SAFM,MAEA,IAAIvC,aAAa,IAAI,EAArB,EAAyB;AAC9B,iBAAOmB,QAAQ,CAAC8D,SAAT,CAAmBxC,SAA1B;AACD;;AACD;;AACF,WAAK,CAAL;AAAQ;AACN,YAAIzC,aAAa,IAAI,CAArB,EAAwB;AACtB,iBAAOmB,QAAQ,CAAC8D,SAAT,CAAmBC,OAA1B;AACD,SAFD,MAEO,IAAIlF,aAAa,IAAI,EAArB,EAAyB;AAC9B,iBAAOmB,QAAQ,CAAC8D,SAAT,CAAmBE,QAA1B;AACD,SAFM,MAEA,IAAInF,aAAa,IAAI,EAArB,EAAyB;AAC9B,iBAAOmB,QAAQ,CAAC8D,SAAT,CAAmBG,QAA1B;AACD;;AACD;;AACF,WAAK,CAAL;AACE,gBAAQpF,aAAR;AACE,eAAK,EAAL;AACE,mBAAO,UAAUqF,MAAV,EAAkBrC,YAAlB,EAAgC;AACrC,qBAAOtE,UAAU,CAAC,IAAD,EAAO2G,MAAP,EAAerC,YAAf,CAAjB;AACD,aAFD;;AAGF,eAAK,EAAL;AACE,mBAAO7B,QAAQ,CAAC8D,SAAT,CAAmBK,UAA1B;;AACF,eAAK,EAAL;AACE,mBAAOnE,QAAQ,CAAC8D,SAAT,CAAmBM,UAA1B;;AACF;AACE;AAVJ;;AAYA;;AACF;AACE;AAlCJ;;AAoCA,UAAM7E,KAAK,CAAC,uCAAD,CAAX;AACD;;AAED8E,EAAAA,eAAe,CAACT,WAAW,GAAG,CAAf,EAAkB;AAC/B,WAAO,KAAKlC,aAAL,CAAmBmC,YAAnB,GACH,KAAKnC,aAAL,CAAmBmC,YAAnB,CAAgCD,WAAhC,CADG,GAC4C,CADnD;AAED;;AAEDU,EAAAA,gBAAgB,CAACV,WAAW,GAAG,CAAf,EAAkB;AAChC,WAAO,KAAKlC,aAAL,CAAmB4B,aAAnB,CAAiCM,WAAjC,CAAP;AACD;;AAEDW,EAAAA,iBAAiB,CAACX,WAAD,EAAc9E,IAAd,EAAoB;AACnC,UAAMF,MAAM,GAAG,KAAKyF,eAAL,CAAqBT,WAArB,CAAf;AACA,UAAM/E,aAAa,GAAG,KAAKyF,gBAAL,CAAsBV,WAAtB,CAAtB;AACA,WAAOjF,YAAY,CAACC,MAAD,EAASC,aAAT,EAAwBC,IAAxB,CAAnB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACsB,QAAd0F,cAAc,CAAC7D,CAAD,EAAIF,CAAJ,EAAOgE,MAAP,EAAeC,aAAf,EAA8BC,MAA9B,EAAsC;AACxD,UAAMC,cAAc,GAAG5D,IAAI,CAAC0C,IAAL,CAAU,KAAKpB,QAAL,KAAkB,KAAKM,YAAL,EAA5B,CAAvB;AACA,UAAMiC,cAAc,GAAG7D,IAAI,CAAC0C,IAAL,CAAU,KAAKlB,SAAL,KAAmB,KAAKM,aAAL,EAA7B,CAAvB;AACA,QAAIgC,KAAJ;AACA,UAAM;AAAE9C,MAAAA;AAAF,QAAY,IAAlB;;AACA,QAAI,KAAKrC,mBAAL,KAA6B,CAAjC,EAAoC;AAClCmF,MAAAA,KAAK,GAAIrE,CAAC,GAAGmE,cAAL,GAAuBjE,CAA/B;AACD,KAFD,MAEO,IAAI,KAAKhB,mBAAL,KAA6B,CAAjC,EAAoC;AACzCmF,MAAAA,KAAK,GAAIL,MAAM,GAAGG,cAAT,GAA0BC,cAA3B,GAA8CpE,CAAC,GAAGmE,cAAlD,GAAoEjE,CAA5E;AACD;;AAED,QAAIuD,MAAJ;AACA,QAAIa,SAAJ;;AACA,QAAI,KAAK9C,OAAT,EAAkB;AAChBiC,MAAAA,MAAM,GAAG,KAAKxC,aAAL,CAAmBsD,WAAnB,CAA+BF,KAA/B,CAAT;AACAC,MAAAA,SAAS,GAAG,KAAKrD,aAAL,CAAmBuD,cAAnB,CAAkCH,KAAlC,CAAZ;AACD,KAHD,MAGO;AACLZ,MAAAA,MAAM,GAAG,KAAKxC,aAAL,CAAmBQ,YAAnB,CAAgC4C,KAAhC,CAAT;AACAC,MAAAA,SAAS,GAAG,KAAKrD,aAAL,CAAmBwD,eAAnB,CAAmCJ,KAAnC,CAAZ;AACD;;AACD,UAAMK,KAAK,GAAG,CAAC,MAAM,KAAKpD,MAAL,CAAYqD,KAAZ,CAAkB,CAAC;AAAElB,MAAAA,MAAF;AAAUX,MAAAA,MAAM,EAAEwB;AAAlB,KAAD,CAAlB,EAAmDJ,MAAnD,CAAP,EAAmE,CAAnE,CAAd;AAEA,QAAIU,OAAJ;;AACA,QAAIrD,KAAK,KAAK,IAAV,IAAkB,CAACA,KAAK,CAAC8C,KAAD,CAA5B,EAAqC;AACrC;AACEO,MAAAA,OAAO,GAAG,CAAC,YAAY;AACrB,YAAIC,IAAI,GAAG,MAAMZ,aAAa,CAACa,MAAd,CAAqB,KAAK7D,aAA1B,EAAyCyD,KAAzC,CAAjB;AACA,cAAMK,YAAY,GAAG,KAAKnB,eAAL,EAArB;AACA,cAAMxF,aAAa,GAAG,KAAKyF,gBAAL,EAAtB;;AACA,YAAI9E,kBAAkB,CAACgG,YAAD,EAAe3G,aAAf,CAAtB,EAAqD;AACnDyG,UAAAA,IAAI,GAAG7F,cAAc,CACnB6F,IADmB,EAEnBE,YAFmB,EAGnB,KAAK7F,mBAHc,EAInB,KAAK+C,kBAAL,EAJmB,EAKnB7D,aALmB,EAMnB,KAAK+D,YAAL,EANmB,EAOnB,KAAKO,cAAL,CAAoB1C,CAApB,CAPmB,CAArB;AASD;;AACD,eAAO6E,IAAP;AACD,OAhBS,GAAV,CAFmC,CAoBnC;;;AACA,UAAItD,KAAK,KAAK,IAAd,EAAoB;AAClBA,QAAAA,KAAK,CAAC8C,KAAD,CAAL,GAAeO,OAAf;AACD;AACF,KAxBD,MAwBO;AACL;AACAA,MAAAA,OAAO,GAAGrD,KAAK,CAAC8C,KAAD,CAAf;AACD,KAlDuD,CAoDxD;;;AACA,WAAO;AAAEnE,MAAAA,CAAF;AAAKF,MAAAA,CAAL;AAAQgE,MAAAA,MAAR;AAAgBa,MAAAA,IAAI,EAAE,MAAMD;AAA5B,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAXI,WAAW,CAACC,WAAD,EAAcC,OAAd,EAAuBC,WAAvB,EAAoCC,UAApC,EAAgDnB,aAAhD,EAA+DoB,KAA/D,EACfC,MADe,EACPC,cADO,EACSrB,MADT,EACiB;AAChC,UAAM9E,SAAS,GAAG,KAAK+C,YAAL,EAAlB;AACA,UAAM9C,UAAU,GAAG,KAAKgD,aAAL,EAAnB;AACA,UAAMmD,UAAU,GAAG,KAAK3D,QAAL,EAAnB;AACA,UAAM4D,WAAW,GAAG,KAAK1D,SAAL,EAApB;AAEA,UAAM2D,QAAQ,GAAGnF,IAAI,CAACoF,GAAL,CAASpF,IAAI,CAACC,KAAL,CAAWyE,WAAW,CAAC,CAAD,CAAX,GAAiB7F,SAA5B,CAAT,EAAiD,CAAjD,CAAjB;AACA,UAAMwG,QAAQ,GAAGrF,IAAI,CAACiC,GAAL,CACfjC,IAAI,CAAC0C,IAAL,CAAUgC,WAAW,CAAC,CAAD,CAAX,GAAiB7F,SAA3B,CADe,EAEfmB,IAAI,CAAC0C,IAAL,CAAUuC,UAAU,GAAGpG,SAAvB,CAFe,CAAjB;AAIA,UAAMyG,QAAQ,GAAGtF,IAAI,CAACoF,GAAL,CAASpF,IAAI,CAACC,KAAL,CAAWyE,WAAW,CAAC,CAAD,CAAX,GAAiB5F,UAA5B,CAAT,EAAkD,CAAlD,CAAjB;AACA,UAAMyG,QAAQ,GAAGvF,IAAI,CAACiC,GAAL,CACfjC,IAAI,CAAC0C,IAAL,CAAUgC,WAAW,CAAC,CAAD,CAAX,GAAiB5F,UAA3B,CADe,EAEfkB,IAAI,CAAC0C,IAAL,CAAUwC,WAAW,GAAGpG,UAAxB,CAFe,CAAjB;AAIA,UAAM0G,WAAW,GAAGd,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAAhD;AAEA,QAAIe,aAAa,GAAG,KAAKrD,gBAAL,EAApB;AAEA,UAAMsD,gBAAgB,GAAG,EAAzB;AACA,UAAMC,aAAa,GAAG,EAAtB;;AACA,SAAK,IAAIjI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiH,OAAO,CAACpC,MAA5B,EAAoC,EAAE7E,CAAtC,EAAyC;AACvC,UAAI,KAAKiB,mBAAL,KAA6B,CAAjC,EAAoC;AAClC+G,QAAAA,gBAAgB,CAACE,IAAjB,CAAsBvI,GAAG,CAAC,KAAKqD,aAAL,CAAmB4B,aAApB,EAAmC,CAAnC,EAAsCqC,OAAO,CAACjH,CAAD,CAA7C,CAAH,GAAuD,CAA7E;AACD,OAFD,MAEO;AACLgI,QAAAA,gBAAgB,CAACE,IAAjB,CAAsB,CAAtB;AACD;;AACDD,MAAAA,aAAa,CAACC,IAAd,CAAmB,KAAKjD,kBAAL,CAAwBgC,OAAO,CAACjH,CAAD,CAA/B,CAAnB;AACD;;AAED,UAAMmI,QAAQ,GAAG,EAAjB;AACA,UAAM;AAAEhF,MAAAA;AAAF,QAAmB,IAAzB;;AAEA,SAAK,IAAIiF,KAAK,GAAGR,QAAjB,EAA2BQ,KAAK,GAAGP,QAAnC,EAA6C,EAAEO,KAA/C,EAAsD;AACpD,WAAK,IAAIC,KAAK,GAAGZ,QAAjB,EAA2BY,KAAK,GAAGV,QAAnC,EAA6C,EAAEU,KAA/C,EAAsD;AACpD,aAAK,IAAInD,WAAW,GAAG,CAAvB,EAA0BA,WAAW,GAAG+B,OAAO,CAACpC,MAAhD,EAAwD,EAAEK,WAA1D,EAAuE;AACrE,gBAAMoD,EAAE,GAAGpD,WAAX;AACA,gBAAMa,MAAM,GAAGkB,OAAO,CAAC/B,WAAD,CAAtB;;AACA,cAAI,KAAKjE,mBAAL,KAA6B,CAAjC,EAAoC;AAClC8G,YAAAA,aAAa,GAAG,KAAKjD,iBAAL,CAAuBI,WAAvB,CAAhB;AACD;;AACD,gBAAMqD,OAAO,GAAG,KAAKzC,cAAL,CAAoBuC,KAApB,EAA2BD,KAA3B,EAAkCrC,MAAlC,EAA0CC,aAA1C,EAAyDC,MAAzD,CAAhB;AACAkC,UAAAA,QAAQ,CAACD,IAAT,CAAcK,OAAd;AACAA,UAAAA,OAAO,CAACC,IAAR,CAAcC,IAAD,IAAU;AACrB,kBAAM5F,MAAM,GAAG4F,IAAI,CAAC7B,IAApB;AACA,kBAAM1D,QAAQ,GAAG,IAAI5B,QAAJ,CAAauB,MAAb,CAAjB;AACA,kBAAM6F,WAAW,GAAG,KAAKjE,cAAL,CAAoBgE,IAAI,CAAC1G,CAAzB,CAApB;AACA,kBAAM4G,SAAS,GAAGF,IAAI,CAAC1G,CAAL,GAASX,UAA3B;AACA,kBAAMwH,QAAQ,GAAGH,IAAI,CAACxG,CAAL,GAASd,SAA1B;AACA,kBAAM0H,QAAQ,GAAGF,SAAS,GAAGD,WAA7B;AACA,kBAAMI,OAAO,GAAG,CAACL,IAAI,CAACxG,CAAL,GAAS,CAAV,IAAed,SAA/B;AACA,kBAAM4H,MAAM,GAAGd,aAAa,CAACK,EAAD,CAA5B;AAEA,kBAAMU,IAAI,GAAG1G,IAAI,CAACiC,GAAL,CAASmE,WAAT,EAAsBA,WAAW,IAAIG,QAAQ,GAAG7B,WAAW,CAAC,CAAD,CAA1B,CAAjC,EAAiEQ,WAAW,GAAGmB,SAA/E,CAAb;AACA,kBAAMM,IAAI,GAAG3G,IAAI,CAACiC,GAAL,CAASpD,SAAT,EAAoBA,SAAS,IAAI2H,OAAO,GAAG9B,WAAW,CAAC,CAAD,CAAzB,CAA7B,EAA4DO,UAAU,GAAGqB,QAAzE,CAAb;;AAEA,iBAAK,IAAI7G,CAAC,GAAGO,IAAI,CAACoF,GAAL,CAAS,CAAT,EAAYV,WAAW,CAAC,CAAD,CAAX,GAAiB2B,SAA7B,CAAb,EAAsD5G,CAAC,GAAGiH,IAA1D,EAAgE,EAAEjH,CAAlE,EAAqE;AACnE,mBAAK,IAAIE,CAAC,GAAGK,IAAI,CAACoF,GAAL,CAAS,CAAT,EAAYV,WAAW,CAAC,CAAD,CAAX,GAAiB4B,QAA7B,CAAb,EAAqD3G,CAAC,GAAGgH,IAAzD,EAA+D,EAAEhH,CAAjE,EAAoE;AAClE,sBAAMiH,WAAW,GAAG,CAAEnH,CAAC,GAAGZ,SAAL,GAAkBc,CAAnB,IAAwB8F,aAA5C;AACA,sBAAMoB,KAAK,GAAGJ,MAAM,CAACK,IAAP,CACZlG,QADY,EACFgG,WAAW,GAAGlB,gBAAgB,CAACM,EAAD,CAD5B,EACkCnF,YADlC,CAAd;AAGA,oBAAIkG,gBAAJ;;AACA,oBAAIlC,UAAJ,EAAgB;AACdkC,kBAAAA,gBAAgB,GAAI,CAACtH,CAAC,GAAG4G,SAAJ,GAAgB3B,WAAW,CAAC,CAAD,CAA5B,IAAmCc,WAAnC,GAAiDb,OAAO,CAACpC,MAA1D,GACd,CAAC5C,CAAC,GAAG2G,QAAJ,GAAe5B,WAAW,CAAC,CAAD,CAA3B,IAAkCC,OAAO,CAACpC,MAD5B,GAEfyD,EAFJ;AAGApB,kBAAAA,WAAW,CAACmC,gBAAD,CAAX,GAAgCF,KAAhC;AACD,iBALD,MAKO;AACLE,kBAAAA,gBAAgB,GACd,CAACtH,CAAC,GAAG4G,SAAJ,GAAgB3B,WAAW,CAAC,CAAD,CAA5B,IAAmCc,WADlB,GAEf7F,CAFe,GAEX2G,QAFW,GAEA5B,WAAW,CAAC,CAAD,CAF9B;AAGAE,kBAAAA,WAAW,CAACoB,EAAD,CAAX,CAAgBe,gBAAhB,IAAoCF,KAApC;AACD;AACF;AACF;AACF,WAjCD;AAkCD;AACF;AACF;;AACD,UAAMG,OAAO,CAACC,GAAR,CAAYpB,QAAZ,CAAN;;AAEA,QAAKf,KAAK,IAAKJ,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA7B,KAAsCI,KAAhD,IACIC,MAAM,IAAKL,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA7B,KAAsCK,MADxD,EACiE;AAC/D,UAAImC,SAAJ;;AACA,UAAIrC,UAAJ,EAAgB;AACdqC,QAAAA,SAAS,GAAG9J,mBAAmB,CAC7BwH,WAD6B,EAE7BF,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAFC,EAG7BA,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAHC,EAI7BI,KAJ6B,EAItBC,MAJsB,EAK7BJ,OAAO,CAACpC,MALqB,EAM7ByC,cAN6B,CAA/B;AAQD,OATD,MASO;AACLkC,QAAAA,SAAS,GAAG/J,QAAQ,CAClByH,WADkB,EAElBF,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAFV,EAGlBA,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAHV,EAIlBI,KAJkB,EAIXC,MAJW,EAKlBC,cALkB,CAApB;AAOD;;AACDkC,MAAAA,SAAS,CAACpC,KAAV,GAAkBA,KAAlB;AACAoC,MAAAA,SAAS,CAACnC,MAAV,GAAmBA,MAAnB;AACA,aAAOmC,SAAP;AACD;;AAEDtC,IAAAA,WAAW,CAACE,KAAZ,GAAoBA,KAAK,IAAIJ,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAAzD;AACAE,IAAAA,WAAW,CAACG,MAAZ,GAAqBA,MAAM,IAAIL,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA3D;AAEA,WAAOE,WAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAXuC,WAAW,CAAC;AAChBC,IAAAA,MAAM,EAAEC,GADQ;AACH1C,IAAAA,OAAO,GAAG,EADP;AACWE,IAAAA,UADX;AACuByC,IAAAA,IAAI,GAAG,IAD9B;AAEhBxC,IAAAA,KAFgB;AAETC,IAAAA,MAFS;AAEDC,IAAAA,cAFC;AAEeuC,IAAAA,SAFf;AAE0B5D,IAAAA;AAF1B,MAGd,EAHa,EAGT;AACN,UAAMe,WAAW,GAAG2C,GAAG,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,KAAK/F,QAAL,EAAP,EAAwB,KAAKE,SAAL,EAAxB,CAA3B,CADM,CAGN;;AACA,QAAIkD,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA5B,IAAmCA,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAAnE,EAAwE;AACtE,YAAM,IAAInG,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED,UAAMiJ,gBAAgB,GAAG9C,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAArD;AACA,UAAM+C,iBAAiB,GAAG/C,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAAtD;AACA,UAAMgD,SAAS,GAAGF,gBAAgB,GAAGC,iBAArC;AACA,UAAM7I,eAAe,GAAG,KAAK8C,kBAAL,EAAxB;;AAEA,QAAI,CAACiD,OAAD,IAAY,CAACA,OAAO,CAACpC,MAAzB,EAAiC;AAC/B,WAAK,IAAI7E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkB,eAApB,EAAqC,EAAElB,CAAvC,EAA0C;AACxCiH,QAAAA,OAAO,CAACiB,IAAR,CAAalI,CAAb;AACD;AACF,KAJD,MAIO;AACL,WAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiH,OAAO,CAACpC,MAA5B,EAAoC,EAAE7E,CAAtC,EAAyC;AACvC,YAAIiH,OAAO,CAACjH,CAAD,CAAP,IAAckB,eAAlB,EAAmC;AACjC,iBAAOoI,OAAO,CAACW,MAAR,CAAe,IAAIlF,UAAJ,CAAgB,yBAAwBkC,OAAO,CAACjH,CAAD,CAAI,IAAnD,CAAf,CAAP;AACD;AACF;AACF;;AACD,QAAIkH,WAAJ;;AACA,QAAIC,UAAJ,EAAgB;AACd,YAAMjH,MAAM,GAAG,KAAK8C,aAAL,CAAmBmC,YAAnB,GACX7C,IAAI,CAACoF,GAAL,CAASwC,KAAT,CAAe,IAAf,EAAqB,KAAKlH,aAAL,CAAmBmC,YAAxC,CADW,GAC6C,CAD5D;AAEA,YAAMhF,aAAa,GAAGmC,IAAI,CAACoF,GAAL,CAASwC,KAAT,CAAe,IAAf,EAAqB,KAAKlH,aAAL,CAAmB4B,aAAxC,CAAtB;AACAsC,MAAAA,WAAW,GAAGjH,YAAY,CAACC,MAAD,EAASC,aAAT,EAAwB6J,SAAS,GAAG/C,OAAO,CAACpC,MAA5C,CAA1B;;AACA,UAAIgF,SAAJ,EAAe;AACb3C,QAAAA,WAAW,CAACiD,IAAZ,CAAiBN,SAAjB;AACD;AACF,KARD,MAQO;AACL3C,MAAAA,WAAW,GAAG,EAAd;;AACA,WAAK,IAAIlH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiH,OAAO,CAACpC,MAA5B,EAAoC,EAAE7E,CAAtC,EAAyC;AACvC,cAAMoK,UAAU,GAAG,KAAKvE,iBAAL,CAAuBoB,OAAO,CAACjH,CAAD,CAA9B,EAAmCgK,SAAnC,CAAnB;;AACA,YAAIK,KAAK,CAACC,OAAN,CAAcT,SAAd,KAA4B7J,CAAC,GAAG6J,SAAS,CAAChF,MAA9C,EAAsD;AACpDuF,UAAAA,UAAU,CAACD,IAAX,CAAgBN,SAAS,CAAC7J,CAAD,CAAzB;AACD,SAFD,MAEO,IAAI6J,SAAS,IAAI,CAACQ,KAAK,CAACC,OAAN,CAAcT,SAAd,CAAlB,EAA4C;AACjDO,UAAAA,UAAU,CAACD,IAAX,CAAgBN,SAAhB;AACD;;AACD3C,QAAAA,WAAW,CAACgB,IAAZ,CAAiBkC,UAAjB;AACD;AACF;;AAED,UAAMpE,aAAa,GAAG4D,IAAI,KAAI,MAAMpK,UAAU,CAAC,KAAKwD,aAAN,CAApB,CAA1B;AAEA,UAAMuH,MAAM,GAAG,MAAM,KAAKxD,WAAL,CACnBC,WADmB,EACNC,OADM,EACGC,WADH,EACgBC,UADhB,EAC4BnB,aAD5B,EAC2CoB,KAD3C,EACkDC,MADlD,EAC0DC,cAD1D,EAC0ErB,MAD1E,CAArB;AAGA,WAAOsE,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,QAAPC,OAAO,CAAC;AAAEd,IAAAA,MAAF;AAAUvC,IAAAA,UAAU,GAAG,IAAvB;AAA6ByC,IAAAA,IAAI,GAAG,IAApC;AAA0CxC,IAAAA,KAA1C;AAAiDC,IAAAA,MAAjD;AACZC,IAAAA,cADY;AACImD,IAAAA,WAAW,GAAG,KADlB;AACyBxE,IAAAA;AADzB,MACoC,EADrC,EACyC;AACpD,UAAMe,WAAW,GAAG0C,MAAM,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,KAAK9F,QAAL,EAAP,EAAwB,KAAKE,SAAL,EAAxB,CAA9B,CADoD,CAGpD;;AACA,QAAIkD,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA5B,IAAmCA,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAAnE,EAAwE;AACtE,YAAM,IAAInG,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED,UAAM6J,EAAE,GAAG,KAAK1H,aAAL,CAAmB2H,yBAA9B;;AAEA,QAAID,EAAE,KAAK1L,0BAA0B,CAAC4L,GAAtC,EAA2C;AACzC,UAAI7K,CAAC,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAR;;AACA,UAAK,EAAE,KAAKiD,aAAL,CAAmB6H,YAAnB,KAAoC5L,kBAAkB,CAAC6L,WAAzD,CAAD,IAA2EL,WAA/E,EAA4F;AAC1F1K,QAAAA,CAAC,GAAG,EAAJ;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKgD,aAAL,CAAmB4B,aAAnB,CAAiCC,MAArD,EAA6D7E,CAAC,IAAI,CAAlE,EAAqE;AACnED,UAAAA,CAAC,CAACmI,IAAF,CAAOlI,CAAP;AACD;AACF;;AACD,aAAO,KAAKyJ,WAAL,CAAiB;AACtBC,QAAAA,MADsB;AAEtBvC,QAAAA,UAFsB;AAGtBF,QAAAA,OAAO,EAAElH,CAHa;AAItB6J,QAAAA,IAJsB;AAKtBxC,QAAAA,KALsB;AAMtBC,QAAAA,MANsB;AAOtBC,QAAAA,cAPsB;AAQtBrB,QAAAA;AARsB,OAAjB,CAAP;AAUD;;AAED,QAAIgB,OAAJ;;AACA,YAAQyD,EAAR;AACE,WAAK1L,0BAA0B,CAAC+L,WAAhC;AACA,WAAK/L,0BAA0B,CAACgM,WAAhC;AACA,WAAKhM,0BAA0B,CAACiM,OAAhC;AACEhE,QAAAA,OAAO,GAAG,CAAC,CAAD,CAAV;AACA;;AACF,WAAKjI,0BAA0B,CAACkM,IAAhC;AACEjE,QAAAA,OAAO,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAV;AACA;;AACF,WAAKjI,0BAA0B,CAACmM,KAAhC;AACA,WAAKnM,0BAA0B,CAACoM,MAAhC;AACEnE,QAAAA,OAAO,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAV;AACA;;AACF;AACE,cAAM,IAAIpG,KAAJ,CAAU,oDAAV,CAAN;AAdJ;;AAiBA,UAAMwK,UAAU,GAAG;AACjB3B,MAAAA,MAAM,EAAE1C,WADS;AAEjBG,MAAAA,UAAU,EAAE,IAFK;AAGjBF,MAAAA,OAHiB;AAIjB2C,MAAAA,IAJiB;AAKjBxC,MAAAA,KALiB;AAMjBC,MAAAA,MANiB;AAOjBC,MAAAA,cAPiB;AAQjBrB,MAAAA;AARiB,KAAnB;AAUA,UAAM;AAAEjD,MAAAA;AAAF,QAAoB,IAA1B;AACA,UAAMsI,MAAM,GAAG,MAAM,KAAK7B,WAAL,CAAiB4B,UAAjB,CAArB;AAEA,UAAM3D,GAAG,GAAG,KAAK,KAAK1E,aAAL,CAAmB4B,aAAnB,CAAiC,CAAjC,CAAjB;AACA,QAAIgC,IAAJ;;AACA,YAAQ8D,EAAR;AACE,WAAK1L,0BAA0B,CAAC+L,WAAhC;AACEnE,QAAAA,IAAI,GAAG1H,eAAe,CAACoM,MAAD,EAAS5D,GAAT,CAAtB;AACA;;AACF,WAAK1I,0BAA0B,CAACgM,WAAhC;AACEpE,QAAAA,IAAI,GAAGzH,eAAe,CAACmM,MAAD,EAAS5D,GAAT,CAAtB;AACA;;AACF,WAAK1I,0BAA0B,CAACiM,OAAhC;AACErE,QAAAA,IAAI,GAAGxH,WAAW,CAACkM,MAAD,EAAStI,aAAa,CAACuI,QAAvB,CAAlB;AACA;;AACF,WAAKvM,0BAA0B,CAACkM,IAAhC;AACEtE,QAAAA,IAAI,GAAGvH,QAAQ,CAACiM,MAAD,CAAf;AACA;;AACF,WAAKtM,0BAA0B,CAACmM,KAAhC;AACEvE,QAAAA,IAAI,GAAGtH,SAAS,CAACgM,MAAD,CAAhB;AACA;;AACF,WAAKtM,0BAA0B,CAACoM,MAAhC;AACExE,QAAAA,IAAI,GAAGrH,UAAU,CAAC+L,MAAD,CAAjB;AACA;;AACF;AACE,cAAM,IAAIzK,KAAJ,CAAU,yCAAV,CAAN;AApBJ,KA/DoD,CAsFpD;AACA;;;AACA,QAAI,CAACsG,UAAL,EAAiB;AACf,YAAMqE,GAAG,GAAG,IAAInL,UAAJ,CAAeuG,IAAI,CAAC/B,MAAL,GAAc,CAA7B,CAAZ;AACA,YAAM4G,KAAK,GAAG,IAAIpL,UAAJ,CAAeuG,IAAI,CAAC/B,MAAL,GAAc,CAA7B,CAAd;AACA,YAAM6G,IAAI,GAAG,IAAIrL,UAAJ,CAAeuG,IAAI,CAAC/B,MAAL,GAAc,CAA7B,CAAb;;AACA,WAAK,IAAI7E,CAAC,GAAG,CAAR,EAAW2L,CAAC,GAAG,CAApB,EAAuB3L,CAAC,GAAG4G,IAAI,CAAC/B,MAAhC,EAAwC7E,CAAC,IAAI,CAAL,EAAQ,EAAE2L,CAAlD,EAAqD;AACnDH,QAAAA,GAAG,CAACG,CAAD,CAAH,GAAS/E,IAAI,CAAC5G,CAAD,CAAb;AACAyL,QAAAA,KAAK,CAACE,CAAD,CAAL,GAAW/E,IAAI,CAAC5G,CAAC,GAAG,CAAL,CAAf;AACA0L,QAAAA,IAAI,CAACC,CAAD,CAAJ,GAAU/E,IAAI,CAAC5G,CAAC,GAAG,CAAL,CAAd;AACD;;AACD4G,MAAAA,IAAI,GAAG,CAAC4E,GAAD,EAAMC,KAAN,EAAaC,IAAb,CAAP;AACD;;AAED9E,IAAAA,IAAI,CAACQ,KAAL,GAAakE,MAAM,CAAClE,KAApB;AACAR,IAAAA,IAAI,CAACS,MAAL,GAAciE,MAAM,CAACjE,MAArB;AACA,WAAOT,IAAP;AACD;AAED;AACF;AACA;AACA;;;AACEgF,EAAAA,YAAY,GAAG;AACb,QAAI,CAAC,KAAK5I,aAAL,CAAmB6I,aAAxB,EAAuC;AACrC,aAAO,EAAP;AACD;;AAED,UAAMC,SAAS,GAAG,EAAlB;;AACA,SAAK,IAAI9L,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKgD,aAAL,CAAmB6I,aAAnB,CAAiChH,MAArD,EAA6D7E,CAAC,IAAI,CAAlE,EAAqE;AACnE8L,MAAAA,SAAS,CAAC5D,IAAV,CAAe;AACblI,QAAAA,CAAC,EAAE,KAAKgD,aAAL,CAAmB6I,aAAnB,CAAiC7L,CAAjC,CADU;AAEb2L,QAAAA,CAAC,EAAE,KAAK3I,aAAL,CAAmB6I,aAAnB,CAAiC7L,CAAC,GAAG,CAArC,CAFU;AAGb+L,QAAAA,CAAC,EAAE,KAAK/I,aAAL,CAAmB6I,aAAnB,CAAiC7L,CAAC,GAAG,CAArC,CAHU;AAIbiC,QAAAA,CAAC,EAAE,KAAKe,aAAL,CAAmB6I,aAAnB,CAAiC7L,CAAC,GAAG,CAArC,CAJU;AAKb+B,QAAAA,CAAC,EAAE,KAAKiB,aAAL,CAAmB6I,aAAnB,CAAiC7L,CAAC,GAAG,CAArC,CALU;AAMbgM,QAAAA,CAAC,EAAE,KAAKhJ,aAAL,CAAmB6I,aAAnB,CAAiC7L,CAAC,GAAG,CAArC;AANU,OAAf;AAQD;;AACD,WAAO8L,SAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEG,EAAAA,eAAe,CAAClG,MAAM,GAAG,IAAV,EAAgB;AAC7B,UAAMmG,QAAQ,GAAG,EAAjB;;AACA,QAAI,CAAC,KAAKlJ,aAAL,CAAmBmJ,aAAxB,EAAuC;AACrC,aAAO,IAAP;AACD;;AACD,UAAMC,MAAM,GAAG,KAAKpJ,aAAL,CAAmBmJ,aAAlC;AAEA,QAAIE,KAAK,GAAGtN,cAAc,CAACqN,MAAD,EAAS,MAAT,CAA1B;;AAEA,QAAIrG,MAAM,KAAK,IAAf,EAAqB;AACnBsG,MAAAA,KAAK,GAAGA,KAAK,CAACC,MAAN,CAAcC,IAAD,IAAUzN,YAAY,CAACyN,IAAD,EAAO,QAAP,CAAZ,KAAiCC,SAAxD,CAAR;AACD,KAFD,MAEO;AACLH,MAAAA,KAAK,GAAGA,KAAK,CAACC,MAAN,CAAcC,IAAD,IAAUE,MAAM,CAAC3N,YAAY,CAACyN,IAAD,EAAO,QAAP,CAAb,CAAN,KAAyCxG,MAAhE,CAAR;AACD;;AAED,SAAK,IAAI/F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqM,KAAK,CAACxH,MAA1B,EAAkC,EAAE7E,CAApC,EAAuC;AACrC,YAAMuM,IAAI,GAAGF,KAAK,CAACrM,CAAD,CAAlB;AACAkM,MAAAA,QAAQ,CAACpN,YAAY,CAACyN,IAAD,EAAO,MAAP,CAAb,CAAR,GAAuCA,IAAI,CAACG,KAA5C;AACD;;AACD,WAAOR,QAAP;AACD;AAED;AACF;AACA;AACA;;;AACES,EAAAA,aAAa,GAAG;AACd,QAAI,CAAC,KAAK3J,aAAL,CAAmB4J,WAAxB,EAAqC;AACnC,aAAO,IAAP;AACD;;AACD,UAAMR,MAAM,GAAG,KAAKpJ,aAAL,CAAmB4J,WAAlC;AACA,WAAOH,MAAM,CAACL,MAAM,CAACS,SAAP,CAAiB,CAAjB,EAAoBT,MAAM,CAACvH,MAAP,GAAgB,CAApC,CAAD,CAAb;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEiI,EAAAA,SAAS,GAAG;AACV,UAAMhB,SAAS,GAAG,KAAK9I,aAAL,CAAmB6I,aAArC;AACA,UAAMkB,mBAAmB,GAAG,KAAK/J,aAAL,CAAmBgK,mBAA/C;;AACA,QAAIlB,SAAS,IAAIA,SAAS,CAACjH,MAAV,KAAqB,CAAtC,EAAyC;AACvC,aAAO,CACLiH,SAAS,CAAC,CAAD,CADJ,EAELA,SAAS,CAAC,CAAD,CAFJ,EAGLA,SAAS,CAAC,CAAD,CAHJ,CAAP;AAKD;;AACD,QAAIiB,mBAAJ,EAAyB;AACvB,aAAO,CACLA,mBAAmB,CAAC,CAAD,CADd,EAELA,mBAAmB,CAAC,CAAD,CAFd,EAGLA,mBAAmB,CAAC,EAAD,CAHd,CAAP;AAKD;;AACD,UAAM,IAAIlM,KAAJ,CAAU,mDAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEoM,EAAAA,aAAa,CAACC,cAAc,GAAG,IAAlB,EAAwB;AACnC,UAAMC,eAAe,GAAG,KAAKnK,aAAL,CAAmBoK,eAA3C;AACA,UAAML,mBAAmB,GAAG,KAAK/J,aAAL,CAAmBgK,mBAA/C;;AAEA,QAAIG,eAAJ,EAAqB;AACnB,aAAO,CACLA,eAAe,CAAC,CAAD,CADV,EAEL,CAACA,eAAe,CAAC,CAAD,CAFX,EAGLA,eAAe,CAAC,CAAD,CAHV,CAAP;AAKD;;AACD,QAAIJ,mBAAJ,EAAyB;AACvB,aAAO,CACLA,mBAAmB,CAAC,CAAD,CADd,EAELA,mBAAmB,CAAC,CAAD,CAFd,EAGLA,mBAAmB,CAAC,EAAD,CAHd,CAAP;AAKD;;AAED,QAAIG,cAAJ,EAAoB;AAClB,YAAM,CAACG,OAAD,EAAUC,OAAV,EAAmBC,OAAnB,IAA8BL,cAAc,CAACD,aAAf,EAApC;AACA,aAAO,CACLI,OAAO,GAAGH,cAAc,CAACtJ,QAAf,EAAV,GAAsC,KAAKA,QAAL,EADjC,EAEL0J,OAAO,GAAGJ,cAAc,CAACpJ,SAAf,EAAV,GAAuC,KAAKA,SAAL,EAFlC,EAGLyJ,OAAO,GAAGL,cAAc,CAACtJ,QAAf,EAAV,GAAsC,KAAKA,QAAL,EAHjC,CAAP;AAKD;;AAED,UAAM,IAAI/C,KAAJ,CAAU,mDAAV,CAAN;AACD;AAED;AACF;AACA;AACA;;;AACE2M,EAAAA,WAAW,GAAG;AACZ,WAAO,KAAKvK,OAAL,CAAawK,kBAAb,KAAoC,CAA3C;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,cAAc,GAAG;AACf,UAAMC,MAAM,GAAG,KAAKb,SAAL,EAAf;AACA,UAAMc,UAAU,GAAG,KAAKX,aAAL,EAAnB;AAEA,UAAMY,EAAE,GAAGF,MAAM,CAAC,CAAD,CAAjB;AACA,UAAMG,EAAE,GAAGH,MAAM,CAAC,CAAD,CAAjB;AAEA,UAAMI,EAAE,GAAGF,EAAE,GAAID,UAAU,CAAC,CAAD,CAAV,GAAgB,KAAKhK,QAAL,EAAjC;AACA,UAAMoK,EAAE,GAAGF,EAAE,GAAIF,UAAU,CAAC,CAAD,CAAV,GAAgB,KAAK9J,SAAL,EAAjC;AAEA,WAAO,CACLxB,IAAI,CAACiC,GAAL,CAASsJ,EAAT,EAAaE,EAAb,CADK,EAELzL,IAAI,CAACiC,GAAL,CAASuJ,EAAT,EAAaE,EAAb,CAFK,EAGL1L,IAAI,CAACoF,GAAL,CAASmG,EAAT,EAAaE,EAAb,CAHK,EAILzL,IAAI,CAACoF,GAAL,CAASoG,EAAT,EAAaE,EAAb,CAJK,CAAP;AAMD;;AA5tBgB;;AA+tBnB,eAAelL,YAAf","sourcesContent":["/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          promises.push(promise);\n          promise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n"]},"metadata":{},"sourceType":"module"}