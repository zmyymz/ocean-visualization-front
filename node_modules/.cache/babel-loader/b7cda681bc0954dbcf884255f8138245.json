{"ast":null,"code":"import \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.concat.js\";\nvar FOCUSABLE_ELEMENT_SELECTORS = \"a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\\\"-1\\\"]),input:not([disabled]),input:not([type=\\\"hidden\\\"]),select:not([disabled]),textarea:not([disabled])\";\n\nvar isVisible = function isVisible(element) {\n  if (process.env.NODE_ENV === \"test\") return true;\n  var computed = getComputedStyle(element);\n  return computed.position === \"fixed\" ? false : element.offsetParent !== null;\n};\n\nvar obtainAllFocusableElements = function obtainAllFocusableElements(element) {\n  return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter(function (item) {\n    return isFocusable(item) && isVisible(item);\n  });\n};\n\nvar isFocusable = function isFocusable(element) {\n  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute(\"tabIndex\") !== null) {\n    return true;\n  }\n\n  if (element.disabled) {\n    return false;\n  }\n\n  switch (element.nodeName) {\n    case \"A\":\n      {\n        return !!element.href && element.rel !== \"ignore\";\n      }\n\n    case \"INPUT\":\n      {\n        return !(element.type === \"hidden\" || element.type === \"file\");\n      }\n\n    case \"BUTTON\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      {\n        return true;\n      }\n\n    default:\n      {\n        return false;\n      }\n  }\n};\n\nvar attemptFocus = function attemptFocus(element) {\n  var _a;\n\n  if (!isFocusable(element)) {\n    return false;\n  }\n\n  (_a = element.focus) == null ? void 0 : _a.call(element);\n  return document.activeElement === element;\n};\n\nvar triggerEvent = function triggerEvent(elm, name) {\n  var eventName;\n\n  if (name.includes(\"mouse\") || name.includes(\"click\")) {\n    eventName = \"MouseEvents\";\n  } else if (name.includes(\"key\")) {\n    eventName = \"KeyboardEvent\";\n  } else {\n    eventName = \"HTMLEvents\";\n  }\n\n  var evt = document.createEvent(eventName);\n\n  for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    opts[_key - 2] = arguments[_key];\n  }\n\n  evt.initEvent.apply(evt, [name].concat(opts));\n  elm.dispatchEvent(evt);\n  return elm;\n};\n\nvar isLeaf = function isLeaf(el) {\n  return !el.getAttribute(\"aria-owns\");\n};\n\nvar getSibling = function getSibling(el, distance, elClass) {\n  var parentNode = el.parentNode;\n  if (!parentNode) return null;\n  var siblings = parentNode.querySelectorAll(elClass);\n  var index = Array.prototype.indexOf.call(siblings, el);\n  return siblings[index + distance] || null;\n};\n\nvar focusNode = function focusNode(el) {\n  if (!el) return;\n  el.focus();\n  !isLeaf(el) && el.click();\n};\n\nexport { attemptFocus, focusNode, getSibling, isFocusable, isLeaf, isVisible, obtainAllFocusableElements, triggerEvent };","map":{"version":3,"mappings":"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","names":["FOCUSABLE_ELEMENT_SELECTORS","isVisible","element","process","env","NODE_ENV","computed","getComputedStyle","position","offsetParent","obtainAllFocusableElements","Array","from","querySelectorAll","filter","item","isFocusable","tabIndex","getAttribute","disabled","nodeName","href","rel","type","attemptFocus","_a","focus","call","document","activeElement","triggerEvent","elm","name","eventName","includes","evt","createEvent","opts","initEvent","dispatchEvent","isLeaf","el","getSibling","distance","elClass","parentNode","siblings","index","prototype","indexOf","focusNode","click"],"sources":["../../../../../packages/utils/dom/aria.ts"],"sourcesContent":["import type { Nullable } from '../typescript'\n\nconst FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`\n\n/**\n * Determine if the testing element is visible on screen no matter if its on the viewport or not\n */\nexport const isVisible = (element: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return true\n  const computed = getComputedStyle(element)\n  // element.offsetParent won't work on fix positioned\n  // WARNING: potential issue here, going to need some expert advices on this issue\n  return computed.position === 'fixed' ? false : element.offsetParent !== null\n}\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  return Array.from(\n    element.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENT_SELECTORS)\n  ).filter((item: HTMLElement) => isFocusable(item) && isVisible(item))\n}\n\n/**\n * @desc Determine if target element is focusable\n * @param element {HTMLElement}\n * @returns {Boolean} true if it is focusable\n */\nexport const isFocusable = (element: HTMLElement): boolean => {\n  if (\n    element.tabIndex > 0 ||\n    (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)\n  ) {\n    return true\n  }\n  // HTMLButtonElement has disabled\n  if ((element as HTMLButtonElement).disabled) {\n    return false\n  }\n\n  switch (element.nodeName) {\n    case 'A': {\n      // casting current element to Specific HTMLElement in order to be more type precise\n      return (\n        !!(element as HTMLAnchorElement).href &&\n        (element as HTMLAnchorElement).rel !== 'ignore'\n      )\n    }\n    case 'INPUT': {\n      return !(\n        (element as HTMLInputElement).type === 'hidden' ||\n        (element as HTMLInputElement).type === 'file'\n      )\n    }\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA': {\n      return true\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * @desc Set Attempt to set focus on the current node.\n * @param element\n *          The node to attempt to focus on.\n * @returns\n *  true if element is focused.\n */\nexport const attemptFocus = (element: HTMLElement): boolean => {\n  if (!isFocusable(element)) {\n    return false\n  }\n  // Remove the old try catch block since there will be no error to be thrown\n  element.focus?.()\n  return document.activeElement === element\n}\n\n/**\n * Trigger an event\n * mouseenter, mouseleave, mouseover, keyup, change, click, etc.\n * @param  {HTMLElement} elm\n * @param  {String} name\n * @param  {*} opts\n */\nexport const triggerEvent = function (\n  elm: HTMLElement,\n  name: string,\n  ...opts: Array<boolean>\n): HTMLElement {\n  let eventName: string\n\n  if (name.includes('mouse') || name.includes('click')) {\n    eventName = 'MouseEvents'\n  } else if (name.includes('key')) {\n    eventName = 'KeyboardEvent'\n  } else {\n    eventName = 'HTMLEvents'\n  }\n  const evt = document.createEvent(eventName)\n\n  evt.initEvent(name, ...opts)\n  elm.dispatchEvent(evt)\n  return elm\n}\n\nexport const isLeaf = (el: HTMLElement) => !el.getAttribute('aria-owns')\n\nexport const getSibling = (\n  el: HTMLElement,\n  distance: number,\n  elClass: string\n): Nullable<Element> => {\n  const { parentNode } = el\n  if (!parentNode) return null\n  const siblings = parentNode.querySelectorAll(elClass)\n  const index = Array.prototype.indexOf.call(siblings, el)\n  return siblings[index + distance] || null\n}\n\nexport const focusNode = (el) => {\n  if (!el) return\n  el.focus()\n  !isLeaf(el) && el.click()\n}\n"]},"metadata":{},"sourceType":"module"}