{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n\n\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {// TODO: split into multiple multi-range requests\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    } // otherwise make a single request for each slice\n\n\n    return Promise.all(slices.map(slice => this.fetchSlice(slice, signal)));\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: { ...this.headers,\n        Range: `bytes=${slices.map(({\n          offset,\n          length\n        }) => `${offset}-${offset + length}`).join(',')}`\n      },\n      signal\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const {\n        type,\n        params\n      } = parseContentType(response.getHeader('content-type'));\n\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n      const {\n        start,\n        end,\n        total\n      } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map(slice => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const {\n      offset,\n      length\n    } = slice;\n    const response = await this.client.request({\n      headers: { ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`\n      },\n      signal\n    }); // check the response was okay and if the server actually understands range requests\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n      const {\n        total\n      } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n\n}\n\nfunction maybeWrapInBlockedSource(source, {\n  blockSize,\n  cacheSize\n}) {\n  if (blockSize === null) {\n    return source;\n  }\n\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, {\n  headers = {},\n  credentials,\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeXHRSource(url, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeHttpSource(url, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n/**\n *\n * @param {string} url\n * @param {object} options\n */\n\nexport function makeRemoteSource(url, {\n  forceXHR = false,\n  ...clientOptions\n} = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n\n  return makeHttpSource(url, clientOptions);\n}","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/source/remote.js"],"names":["parseByteRanges","parseContentRange","parseContentType","BaseSource","BlockedSource","FetchClient","XHRClient","HttpClient","RemoteSource","constructor","client","headers","maxRanges","allowFullFile","_fileSize","fetch","slices","signal","length","fetchSlices","Promise","all","map","slice","fetchSlice","response","request","Range","offset","join","ok","Error","status","type","params","getHeader","byteRanges","getData","boundary","fileSize","data","start","end","total","first","others","concat","byteLength","maybeWrapInBlockedSource","source","blockSize","cacheSize","makeFetchSource","url","credentials","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","XMLHttpRequest"],"mappings":"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","sourcesContent":["import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n"]},"metadata":{},"sourceType":"module"}