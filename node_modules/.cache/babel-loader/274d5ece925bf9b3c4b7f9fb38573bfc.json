{"ast":null,"code":"import _typeof from \"D:/MyFile/WebCode/ocean-vis/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _classCallCheck from \"D:/MyFile/WebCode/ocean-vis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/MyFile/WebCode/ocean-vis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport '../../../../utils/index.mjs';\nimport Node from './node.mjs';\nimport { getNodeKey } from './util.mjs';\nimport { hasOwn } from '@vue/shared';\n\nvar TreeStore = /*#__PURE__*/function () {\n  function TreeStore(options) {\n    _classCallCheck(this, TreeStore);\n\n    this.currentNode = null;\n    this.currentNodeKey = null;\n\n    for (var option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option];\n      }\n    }\n\n    this.nodesMap = {};\n  }\n\n  _createClass(TreeStore, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n\n      this.root = new Node({\n        data: this.data,\n        store: this\n      });\n      this.root.initialize();\n\n      if (this.lazy && this.load) {\n        var loadFn = this.load;\n        loadFn(this.root, function (data) {\n          _this.root.doCreateChildren(data);\n\n          _this._initDefaultCheckedNodes();\n        });\n      } else {\n        this._initDefaultCheckedNodes();\n      }\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(value) {\n      var filterNodeMethod = this.filterNodeMethod;\n      var lazy = this.lazy;\n\n      var traverse = function traverse(node) {\n        var childNodes = node.root ? node.root.childNodes : node.childNodes;\n        childNodes.forEach(function (child) {\n          child.visible = filterNodeMethod.call(child, value, child.data, child);\n          traverse(child);\n        });\n\n        if (!node.visible && childNodes.length) {\n          var allHidden = true;\n          allHidden = !childNodes.some(function (child) {\n            return child.visible;\n          });\n\n          if (node.root) {\n            ;\n            node.root.visible = allHidden === false;\n          } else {\n            ;\n            node.visible = allHidden === false;\n          }\n        }\n\n        if (!value) return;\n        if (node.visible && !node.isLeaf && !lazy) node.expand();\n      };\n\n      traverse(this);\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(newVal) {\n      var instanceChanged = newVal !== this.root.data;\n\n      if (instanceChanged) {\n        this.root.setData(newVal);\n\n        this._initDefaultCheckedNodes();\n      } else {\n        this.root.updateChildren();\n      }\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(data) {\n      if (data instanceof Node) return data;\n      var key = _typeof(data) !== \"object\" ? data : getNodeKey(this.key, data);\n      return this.nodesMap[key] || null;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(data, refData) {\n      var refNode = this.getNode(refData);\n      refNode.parent.insertBefore({\n        data: data\n      }, refNode);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(data, refData) {\n      var refNode = this.getNode(refData);\n      refNode.parent.insertAfter({\n        data: data\n      }, refNode);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(data) {\n      var node = this.getNode(data);\n\n      if (node && node.parent) {\n        if (node === this.currentNode) {\n          this.currentNode = null;\n        }\n\n        node.parent.removeChild(node);\n      }\n    }\n  }, {\n    key: \"append\",\n    value: function append(data, parentData) {\n      var parentNode = parentData ? this.getNode(parentData) : this.root;\n\n      if (parentNode) {\n        parentNode.insertChild({\n          data: data\n        });\n      }\n    }\n  }, {\n    key: \"_initDefaultCheckedNodes\",\n    value: function _initDefaultCheckedNodes() {\n      var _this2 = this;\n\n      var defaultCheckedKeys = this.defaultCheckedKeys || [];\n      var nodesMap = this.nodesMap;\n      defaultCheckedKeys.forEach(function (checkedKey) {\n        var node = nodesMap[checkedKey];\n\n        if (node) {\n          node.setChecked(true, !_this2.checkStrictly);\n        }\n      });\n    }\n  }, {\n    key: \"_initDefaultCheckedNode\",\n    value: function _initDefaultCheckedNode(node) {\n      var defaultCheckedKeys = this.defaultCheckedKeys || [];\n\n      if (defaultCheckedKeys.indexOf(node.key) !== -1) {\n        node.setChecked(true, !this.checkStrictly);\n      }\n    }\n  }, {\n    key: \"setDefaultCheckedKey\",\n    value: function setDefaultCheckedKey(newVal) {\n      if (newVal !== this.defaultCheckedKeys) {\n        this.defaultCheckedKeys = newVal;\n\n        this._initDefaultCheckedNodes();\n      }\n    }\n  }, {\n    key: \"registerNode\",\n    value: function registerNode(node) {\n      var key = this.key;\n      if (!node || !node.data) return;\n\n      if (!key) {\n        this.nodesMap[node.id] = node;\n      } else {\n        var nodeKey = node.key;\n        if (nodeKey !== void 0) this.nodesMap[node.key] = node;\n      }\n    }\n  }, {\n    key: \"deregisterNode\",\n    value: function deregisterNode(node) {\n      var _this3 = this;\n\n      var key = this.key;\n      if (!key || !node || !node.data) return;\n      node.childNodes.forEach(function (child) {\n        _this3.deregisterNode(child);\n      });\n      delete this.nodesMap[node.key];\n    }\n  }, {\n    key: \"getCheckedNodes\",\n    value: function getCheckedNodes() {\n      var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeHalfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var checkedNodes = [];\n\n      var traverse = function traverse(node) {\n        var childNodes = node.root ? node.root.childNodes : node.childNodes;\n        childNodes.forEach(function (child) {\n          if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {\n            checkedNodes.push(child.data);\n          }\n\n          traverse(child);\n        });\n      };\n\n      traverse(this);\n      return checkedNodes;\n    }\n  }, {\n    key: \"getCheckedKeys\",\n    value: function getCheckedKeys() {\n      var _this4 = this;\n\n      var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this.getCheckedNodes(leafOnly).map(function (data) {\n        return (data || {})[_this4.key];\n      });\n    }\n  }, {\n    key: \"getHalfCheckedNodes\",\n    value: function getHalfCheckedNodes() {\n      var nodes = [];\n\n      var traverse = function traverse(node) {\n        var childNodes = node.root ? node.root.childNodes : node.childNodes;\n        childNodes.forEach(function (child) {\n          if (child.indeterminate) {\n            nodes.push(child.data);\n          }\n\n          traverse(child);\n        });\n      };\n\n      traverse(this);\n      return nodes;\n    }\n  }, {\n    key: \"getHalfCheckedKeys\",\n    value: function getHalfCheckedKeys() {\n      var _this5 = this;\n\n      return this.getHalfCheckedNodes().map(function (data) {\n        return (data || {})[_this5.key];\n      });\n    }\n  }, {\n    key: \"_getAllNodes\",\n    value: function _getAllNodes() {\n      var allNodes = [];\n      var nodesMap = this.nodesMap;\n\n      for (var nodeKey in nodesMap) {\n        if (hasOwn(nodesMap, nodeKey)) {\n          allNodes.push(nodesMap[nodeKey]);\n        }\n      }\n\n      return allNodes;\n    }\n  }, {\n    key: \"updateChildren\",\n    value: function updateChildren(key, data) {\n      var node = this.nodesMap[key];\n      if (!node) return;\n      var childNodes = node.childNodes;\n\n      for (var i = childNodes.length - 1; i >= 0; i--) {\n        var child = childNodes[i];\n        this.remove(child.data);\n      }\n\n      for (var _i = 0, j = data.length; _i < j; _i++) {\n        var _child = data[_i];\n        this.append(_child, node.data);\n      }\n    }\n  }, {\n    key: \"_setCheckedKeys\",\n    value: function _setCheckedKeys(key) {\n      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var checkedKeys = arguments.length > 2 ? arguments[2] : undefined;\n\n      var allNodes = this._getAllNodes().sort(function (a, b) {\n        return b.level - a.level;\n      });\n\n      var cache = /* @__PURE__ */Object.create(null);\n      var keys = Object.keys(checkedKeys);\n      allNodes.forEach(function (node) {\n        return node.setChecked(false, false);\n      });\n\n      for (var i = 0, j = allNodes.length; i < j; i++) {\n        var node = allNodes[i];\n        var nodeKey = node.data[key].toString();\n        var checked = keys.indexOf(nodeKey) > -1;\n\n        if (!checked) {\n          if (node.checked && !cache[nodeKey]) {\n            node.setChecked(false, false);\n          }\n\n          continue;\n        }\n\n        var parent = node.parent;\n\n        while (parent && parent.level > 0) {\n          cache[parent.data[key]] = true;\n          parent = parent.parent;\n        }\n\n        if (node.isLeaf || this.checkStrictly) {\n          node.setChecked(true, false);\n          continue;\n        }\n\n        node.setChecked(true, true);\n\n        if (leafOnly) {\n          (function () {\n            node.setChecked(false, false);\n\n            var traverse = function traverse(node2) {\n              var childNodes = node2.childNodes;\n              childNodes.forEach(function (child) {\n                if (!child.isLeaf) {\n                  child.setChecked(false, false);\n                }\n\n                traverse(child);\n              });\n            };\n\n            traverse(node);\n          })();\n        }\n      }\n    }\n  }, {\n    key: \"setCheckedNodes\",\n    value: function setCheckedNodes(array) {\n      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var key = this.key;\n      var checkedKeys = {};\n      array.forEach(function (item) {\n        checkedKeys[(item || {})[key]] = true;\n      });\n\n      this._setCheckedKeys(key, leafOnly, checkedKeys);\n    }\n  }, {\n    key: \"setCheckedKeys\",\n    value: function setCheckedKeys(keys) {\n      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.defaultCheckedKeys = keys;\n      var key = this.key;\n      var checkedKeys = {};\n      keys.forEach(function (key2) {\n        checkedKeys[key2] = true;\n      });\n\n      this._setCheckedKeys(key, leafOnly, checkedKeys);\n    }\n  }, {\n    key: \"setDefaultExpandedKeys\",\n    value: function setDefaultExpandedKeys(keys) {\n      var _this6 = this;\n\n      keys = keys || [];\n      this.defaultExpandedKeys = keys;\n      keys.forEach(function (key) {\n        var node = _this6.getNode(key);\n\n        if (node) node.expand(null, _this6.autoExpandParent);\n      });\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked(data, checked, deep) {\n      var node = this.getNode(data);\n\n      if (node) {\n        node.setChecked(!!checked, deep);\n      }\n    }\n  }, {\n    key: \"getCurrentNode\",\n    value: function getCurrentNode() {\n      return this.currentNode;\n    }\n  }, {\n    key: \"setCurrentNode\",\n    value: function setCurrentNode(currentNode) {\n      var prevCurrentNode = this.currentNode;\n\n      if (prevCurrentNode) {\n        prevCurrentNode.isCurrent = false;\n      }\n\n      this.currentNode = currentNode;\n      this.currentNode.isCurrent = true;\n    }\n  }, {\n    key: \"setUserCurrentNode\",\n    value: function setUserCurrentNode(node) {\n      var shouldAutoExpandParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var key = node[this.key];\n      var currNode = this.nodesMap[key];\n      this.setCurrentNode(currNode);\n\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true);\n      }\n    }\n  }, {\n    key: \"setCurrentNodeKey\",\n    value: function setCurrentNodeKey(key) {\n      var shouldAutoExpandParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (key === null || key === void 0) {\n        this.currentNode && (this.currentNode.isCurrent = false);\n        this.currentNode = null;\n        return;\n      }\n\n      var node = this.getNode(key);\n\n      if (node) {\n        this.setCurrentNode(node);\n\n        if (shouldAutoExpandParent && this.currentNode.level > 1) {\n          this.currentNode.parent.expand(null, true);\n        }\n      }\n    }\n  }]);\n\n  return TreeStore;\n}();\n\nexport { TreeStore as default };","map":{"version":3,"mappings":"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","names":["TreeStore","options","currentNode","currentNodeKey","option","hasOwn","nodesMap","root","Node","data","store","initialize","lazy","load","loadFn","doCreateChildren","_initDefaultCheckedNodes","value","filterNodeMethod","traverse","node","childNodes","forEach","child","visible","call","length","allHidden","some","isLeaf","expand","newVal","instanceChanged","setData","updateChildren","key","getNodeKey","refData","refNode","getNode","parent","insertBefore","insertAfter","removeChild","parentData","parentNode","insertChild","defaultCheckedKeys","checkedKey","setChecked","checkStrictly","indexOf","id","nodeKey","deregisterNode","leafOnly","includeHalfChecked","checkedNodes","checked","indeterminate","push","getCheckedNodes","map","nodes","getHalfCheckedNodes","allNodes","i","remove","j","append","checkedKeys","_getAllNodes","sort","a","b","level","cache","Object","create","keys","toString","node2","array","item","_setCheckedKeys","key2","defaultExpandedKeys","autoExpandParent","deep","prevCurrentNode","isCurrent","shouldAutoExpandParent","currNode","setCurrentNode"],"sources":["../../../../../../../packages/components/tree/src/model/tree-store.ts"],"sourcesContent":["import { hasOwn } from '@element-plus/utils'\nimport Node from './node'\nimport { getNodeKey } from './util'\n\nimport type {\n  TreeKey,\n  TreeData,\n  TreeStoreNodesMap,\n  LoadFunction,\n  FilterNodeMethodFunction,\n  TreeOptionProps,\n  TreeStoreOptions,\n  FilterValue,\n  TreeNodeData,\n} from '../tree.type'\n\nexport default class TreeStore {\n  currentNode: Node\n  currentNodeKey: TreeKey\n  nodesMap: TreeStoreNodesMap\n  root: Node\n  data: TreeData\n  lazy: boolean\n  load: LoadFunction\n  filterNodeMethod: FilterNodeMethodFunction\n  key: TreeKey\n  defaultCheckedKeys: TreeKey[]\n  checkStrictly: boolean\n  defaultExpandedKeys: TreeKey[]\n  autoExpandParent: boolean\n  defaultExpandAll: boolean\n  checkDescendants: boolean\n  props: TreeOptionProps\n\n  constructor(options: TreeStoreOptions) {\n    this.currentNode = null\n    this.currentNodeKey = null\n\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option]\n      }\n    }\n\n    this.nodesMap = {}\n  }\n\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this,\n    })\n    this.root.initialize()\n\n    if (this.lazy && this.load) {\n      const loadFn = this.load\n      loadFn(this.root, (data) => {\n        this.root.doCreateChildren(data)\n        this._initDefaultCheckedNodes()\n      })\n    } else {\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  filter(value: FilterValue): void {\n    const filterNodeMethod = this.filterNodeMethod\n    const lazy = this.lazy\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        child.visible = filterNodeMethod.call(child, value, child.data, child)\n\n        traverse(child)\n      })\n\n      if (!(node as Node).visible && childNodes.length) {\n        let allHidden = true\n        allHidden = !childNodes.some((child) => child.visible)\n\n        if ((node as TreeStore).root) {\n          ;(node as TreeStore).root.visible = allHidden === false\n        } else {\n          ;(node as Node).visible = allHidden === false\n        }\n      }\n      if (!value) return\n\n      if ((node as Node).visible && !(node as Node).isLeaf && !lazy)\n        (node as Node).expand()\n    }\n\n    traverse(this)\n  }\n\n  setData(newVal: TreeData): void {\n    const instanceChanged = newVal !== this.root.data\n    if (instanceChanged) {\n      this.root.setData(newVal)\n      this._initDefaultCheckedNodes()\n    } else {\n      this.root.updateChildren()\n    }\n  }\n\n  getNode(data: TreeKey | TreeNodeData): Node {\n    if (data instanceof Node) return data\n    const key = typeof data !== 'object' ? data : getNodeKey(this.key, data)\n    return this.nodesMap[key] || null\n  }\n\n  insertBefore(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertBefore({ data }, refNode)\n  }\n\n  insertAfter(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertAfter({ data }, refNode)\n  }\n\n  remove(data: TreeNodeData | Node): void {\n    const node = this.getNode(data)\n\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null\n      }\n      node.parent.removeChild(node)\n    }\n  }\n\n  append(data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node): void {\n    const parentNode = parentData ? this.getNode(parentData) : this.root\n\n    if (parentNode) {\n      parentNode.insertChild({ data })\n    }\n  }\n\n  _initDefaultCheckedNodes(): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n    const nodesMap = this.nodesMap\n\n    defaultCheckedKeys.forEach((checkedKey) => {\n      const node = nodesMap[checkedKey]\n\n      if (node) {\n        node.setChecked(true, !this.checkStrictly)\n      }\n    })\n  }\n\n  _initDefaultCheckedNode(node: Node): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n\n    if (defaultCheckedKeys.indexOf(node.key) !== -1) {\n      node.setChecked(true, !this.checkStrictly)\n    }\n  }\n\n  setDefaultCheckedKey(newVal: TreeKey[]): void {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  registerNode(node: Node): void {\n    const key = this.key\n    if (!node || !node.data) return\n\n    if (!key) {\n      this.nodesMap[node.id] = node\n    } else {\n      const nodeKey = node.key\n      if (nodeKey !== undefined) this.nodesMap[node.key] = node\n    }\n  }\n\n  deregisterNode(node: Node): void {\n    const key = this.key\n    if (!key || !node || !node.data) return\n\n    node.childNodes.forEach((child) => {\n      this.deregisterNode(child)\n    })\n\n    delete this.nodesMap[node.key]\n  }\n\n  getCheckedNodes(\n    leafOnly = false,\n    includeHalfChecked = false\n  ): TreeNodeData[] {\n    const checkedNodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (\n          (child.checked || (includeHalfChecked && child.indeterminate)) &&\n          (!leafOnly || (leafOnly && child.isLeaf))\n        ) {\n          checkedNodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return checkedNodes\n  }\n\n  getCheckedKeys(leafOnly = false): TreeKey[] {\n    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key])\n  }\n\n  getHalfCheckedNodes(): TreeNodeData[] {\n    const nodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (child.indeterminate) {\n          nodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return nodes\n  }\n\n  getHalfCheckedKeys(): TreeKey[] {\n    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key])\n  }\n\n  _getAllNodes(): Node[] {\n    const allNodes: Node[] = []\n    const nodesMap = this.nodesMap\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey])\n      }\n    }\n\n    return allNodes\n  }\n\n  updateChildren(key: TreeKey, data: TreeData): void {\n    const node = this.nodesMap[key]\n    if (!node) return\n    const childNodes = node.childNodes\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i]\n      this.remove(child.data)\n    }\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i]\n      this.append(child, node.data)\n    }\n  }\n\n  _setCheckedKeys(\n    key: TreeKey,\n    leafOnly = false,\n    checkedKeys: { [key: string]: boolean }\n  ): void {\n    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level)\n    const cache = Object.create(null)\n    const keys = Object.keys(checkedKeys)\n    allNodes.forEach((node) => node.setChecked(false, false))\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i]\n      const nodeKey = node.data[key].toString()\n      const checked = keys.indexOf(nodeKey) > -1\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false)\n        }\n        continue\n      }\n\n      let parent = node.parent\n      while (parent && parent.level > 0) {\n        cache[parent.data[key]] = true\n        parent = parent.parent\n      }\n\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false)\n        continue\n      }\n      node.setChecked(true, true)\n\n      if (leafOnly) {\n        node.setChecked(false, false)\n        const traverse = function (node: Node): void {\n          const childNodes = node.childNodes\n          childNodes.forEach((child) => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false)\n            }\n            traverse(child)\n          })\n        }\n        traverse(node)\n      }\n    }\n  }\n\n  setCheckedNodes(array: Node[], leafOnly = false): void {\n    const key = this.key\n    const checkedKeys = {}\n    array.forEach((item) => {\n      checkedKeys[(item || {})[key]] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setCheckedKeys(keys: TreeKey[], leafOnly = false): void {\n    this.defaultCheckedKeys = keys\n    const key = this.key\n    const checkedKeys = {}\n    keys.forEach((key) => {\n      checkedKeys[key] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setDefaultExpandedKeys(keys: TreeKey[]) {\n    keys = keys || []\n    this.defaultExpandedKeys = keys\n    keys.forEach((key) => {\n      const node = this.getNode(key)\n      if (node) node.expand(null, this.autoExpandParent)\n    })\n  }\n\n  setChecked(\n    data: TreeKey | TreeNodeData,\n    checked: boolean,\n    deep: boolean\n  ): void {\n    const node = this.getNode(data)\n\n    if (node) {\n      node.setChecked(!!checked, deep)\n    }\n  }\n\n  getCurrentNode(): Node {\n    return this.currentNode\n  }\n\n  setCurrentNode(currentNode: Node): void {\n    const prevCurrentNode = this.currentNode\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false\n    }\n    this.currentNode = currentNode\n    this.currentNode.isCurrent = true\n  }\n\n  setUserCurrentNode(node: Node, shouldAutoExpandParent = true): void {\n    const key = node[this.key]\n    const currNode = this.nodesMap[key]\n    this.setCurrentNode(currNode)\n    if (shouldAutoExpandParent && this.currentNode.level > 1) {\n      this.currentNode.parent.expand(null, true)\n    }\n  }\n\n  setCurrentNodeKey(key: TreeKey, shouldAutoExpandParent = true): void {\n    if (key === null || key === undefined) {\n      this.currentNode && (this.currentNode.isCurrent = false)\n      this.currentNode = null\n      return\n    }\n    const node = this.getNode(key)\n    if (node) {\n      this.setCurrentNode(node)\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}