{"ast":null,"code":"import _objectWithoutProperties from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _excluded = [\"headers\", \"credentials\", \"maxRanges\", \"allowFullFile\"],\n    _excluded2 = [\"headers\", \"maxRanges\", \"allowFullFile\"],\n    _excluded3 = [\"headers\", \"maxRanges\", \"allowFullFile\"],\n    _excluded4 = [\"forceXHR\"];\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nvar RemoteSource = /*#__PURE__*/function (_BaseSource) {\n  _inherits(RemoteSource, _BaseSource);\n\n  var _super = _createSuper(RemoteSource);\n\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  function RemoteSource(client, headers, maxRanges, allowFullFile) {\n    var _this;\n\n    _classCallCheck(this, RemoteSource);\n\n    _this = _super.call(this);\n    _this.client = client;\n    _this.headers = headers;\n    _this.maxRanges = maxRanges;\n    _this.allowFullFile = allowFullFile;\n    _this._fileSize = null;\n    return _this;\n  }\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n\n\n  _createClass(RemoteSource, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(slices, signal) {\n        var _this2 = this;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.maxRanges >= slices.length)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.fetchSlices(slices, signal));\n\n              case 4:\n                if (this.maxRanges > 0 && slices.length > 1) {// TODO: split into multiple multi-range requests\n                  // const subSlicesRequests = [];\n                  // for (let i = 0; i < slices.length; i += this.maxRanges) {\n                  //   subSlicesRequests.push(\n                  //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n                  //   );\n                  // }\n                  // return (await Promise.all(subSlicesRequests)).flat();\n                }\n\n              case 5:\n                return _context.abrupt(\"return\", Promise.all(slices.map(function (slice) {\n                  return _this2.fetchSlice(slice, signal);\n                })));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetch(_x, _x2) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n  }, {\n    key: \"fetchSlices\",\n    value: function () {\n      var _fetchSlices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(slices, signal) {\n        var _this3 = this;\n\n        var response, _parseContentType, type, params, byteRanges, data, _parseContentRange, start, end, total, first, others, _data;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.client.request({\n                  headers: _objectSpread(_objectSpread({}, this.headers), {}, {\n                    Range: \"bytes=\".concat(slices.map(function (_ref) {\n                      var offset = _ref.offset,\n                          length = _ref.length;\n                      return \"\".concat(offset, \"-\").concat(offset + length);\n                    }).join(','))\n                  }),\n                  signal: signal\n                });\n\n              case 2:\n                response = _context2.sent;\n\n                if (response.ok) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                throw new Error('Error fetching data.');\n\n              case 7:\n                if (!(response.status === 206)) {\n                  _context2.next = 32;\n                  break;\n                }\n\n                _parseContentType = parseContentType(response.getHeader('content-type')), type = _parseContentType.type, params = _parseContentType.params;\n\n                if (!(type === 'multipart/byteranges')) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                _context2.t0 = parseByteRanges;\n                _context2.next = 13;\n                return response.getData();\n\n              case 13:\n                _context2.t1 = _context2.sent;\n                _context2.t2 = params.boundary;\n                byteRanges = (0, _context2.t0)(_context2.t1, _context2.t2);\n                this._fileSize = byteRanges[0].fileSize || null;\n                return _context2.abrupt(\"return\", byteRanges);\n\n              case 18:\n                _context2.next = 20;\n                return response.getData();\n\n              case 20:\n                data = _context2.sent;\n                _parseContentRange = parseContentRange(response.getHeader('content-range')), start = _parseContentRange.start, end = _parseContentRange.end, total = _parseContentRange.total;\n                this._fileSize = total || null;\n                first = [{\n                  data: data,\n                  offset: start,\n                  length: end - start\n                }];\n\n                if (!(slices.length > 1)) {\n                  _context2.next = 29;\n                  break;\n                }\n\n                _context2.next = 27;\n                return Promise.all(slices.slice(1).map(function (slice) {\n                  return _this3.fetchSlice(slice, signal);\n                }));\n\n              case 27:\n                others = _context2.sent;\n                return _context2.abrupt(\"return\", first.concat(others));\n\n              case 29:\n                return _context2.abrupt(\"return\", first);\n\n              case 32:\n                if (this.allowFullFile) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                throw new Error('Server responded with full file');\n\n              case 34:\n                _context2.next = 36;\n                return response.getData();\n\n              case 36:\n                _data = _context2.sent;\n                this._fileSize = _data.byteLength;\n                return _context2.abrupt(\"return\", [{\n                  data: _data,\n                  offset: 0,\n                  length: _data.byteLength\n                }]);\n\n              case 39:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetchSlices(_x3, _x4) {\n        return _fetchSlices.apply(this, arguments);\n      }\n\n      return fetchSlices;\n    }()\n  }, {\n    key: \"fetchSlice\",\n    value: function () {\n      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(slice, signal) {\n        var offset, length, response, data, _parseContentRange2, total, _data2;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                offset = slice.offset, length = slice.length;\n                _context3.next = 3;\n                return this.client.request({\n                  headers: _objectSpread(_objectSpread({}, this.headers), {}, {\n                    Range: \"bytes=\".concat(offset, \"-\").concat(offset + length)\n                  }),\n                  signal: signal\n                });\n\n              case 3:\n                response = _context3.sent;\n\n                if (response.ok) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw new Error('Error fetching data.');\n\n              case 8:\n                if (!(response.status === 206)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                _context3.next = 11;\n                return response.getData();\n\n              case 11:\n                data = _context3.sent;\n                _parseContentRange2 = parseContentRange(response.getHeader('content-range')), total = _parseContentRange2.total;\n                this._fileSize = total || null;\n                return _context3.abrupt(\"return\", {\n                  data: data,\n                  offset: offset,\n                  length: length\n                });\n\n              case 17:\n                if (this.allowFullFile) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                throw new Error('Server responded with full file');\n\n              case 19:\n                _context3.next = 21;\n                return response.getData();\n\n              case 21:\n                _data2 = _context3.sent;\n                this._fileSize = _data2.byteLength;\n                return _context3.abrupt(\"return\", {\n                  data: _data2,\n                  offset: 0,\n                  length: _data2.byteLength\n                });\n\n              case 24:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function fetchSlice(_x5, _x6) {\n        return _fetchSlice.apply(this, arguments);\n      }\n\n      return fetchSlice;\n    }()\n  }, {\n    key: \"fileSize\",\n    get: function get() {\n      return this._fileSize;\n    }\n  }]);\n\n  return RemoteSource;\n}(BaseSource);\n\nfunction maybeWrapInBlockedSource(source, _ref2) {\n  var blockSize = _ref2.blockSize,\n      cacheSize = _ref2.cacheSize;\n\n  if (blockSize === null) {\n    return source;\n  }\n\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref3$headers = _ref3.headers,\n      headers = _ref3$headers === void 0 ? {} : _ref3$headers,\n      credentials = _ref3.credentials,\n      _ref3$maxRanges = _ref3.maxRanges,\n      maxRanges = _ref3$maxRanges === void 0 ? 0 : _ref3$maxRanges,\n      _ref3$allowFullFile = _ref3.allowFullFile,\n      allowFullFile = _ref3$allowFullFile === void 0 ? false : _ref3$allowFullFile,\n      blockOptions = _objectWithoutProperties(_ref3, _excluded);\n\n  var client = new FetchClient(url, credentials);\n  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeXHRSource(url) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref4$headers = _ref4.headers,\n      headers = _ref4$headers === void 0 ? {} : _ref4$headers,\n      _ref4$maxRanges = _ref4.maxRanges,\n      maxRanges = _ref4$maxRanges === void 0 ? 0 : _ref4$maxRanges,\n      _ref4$allowFullFile = _ref4.allowFullFile,\n      allowFullFile = _ref4$allowFullFile === void 0 ? false : _ref4$allowFullFile,\n      blockOptions = _objectWithoutProperties(_ref4, _excluded2);\n\n  var client = new XHRClient(url);\n  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeHttpSource(url) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref5$headers = _ref5.headers,\n      headers = _ref5$headers === void 0 ? {} : _ref5$headers,\n      _ref5$maxRanges = _ref5.maxRanges,\n      maxRanges = _ref5$maxRanges === void 0 ? 0 : _ref5$maxRanges,\n      _ref5$allowFullFile = _ref5.allowFullFile,\n      allowFullFile = _ref5$allowFullFile === void 0 ? false : _ref5$allowFullFile,\n      blockOptions = _objectWithoutProperties(_ref5, _excluded3);\n\n  var client = new HttpClient(url);\n  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n/**\n *\n * @param {string} url\n * @param {object} options\n */\n\nexport function makeRemoteSource(url) {\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref6$forceXHR = _ref6.forceXHR,\n      forceXHR = _ref6$forceXHR === void 0 ? false : _ref6$forceXHR,\n      clientOptions = _objectWithoutProperties(_ref6, _excluded4);\n\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n\n  return makeHttpSource(url, clientOptions);\n}","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/source/remote.js"],"names":["parseByteRanges","parseContentRange","parseContentType","BaseSource","BlockedSource","FetchClient","XHRClient","HttpClient","RemoteSource","client","headers","maxRanges","allowFullFile","_fileSize","slices","signal","length","fetchSlices","Promise","all","map","slice","fetchSlice","request","Range","offset","join","response","ok","Error","status","getHeader","type","params","getData","boundary","byteRanges","fileSize","data","start","end","total","first","others","concat","byteLength","maybeWrapInBlockedSource","source","blockSize","cacheSize","makeFetchSource","url","credentials","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","fetch","XMLHttpRequest"],"mappings":"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","sourcesContent":["import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n"]},"metadata":{},"sourceType":"module"}