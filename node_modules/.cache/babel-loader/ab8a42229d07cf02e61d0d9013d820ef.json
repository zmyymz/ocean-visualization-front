{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\n\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var x1 = 0;\n  var y1 = 0;\n  var segmentLength = 0;\n  var segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  var beginX = lerp(x1, x2, interpolate);\n  var beginY = lerp(y1, y2, interpolate);\n  var startOffset = offset - stride;\n  var startLength = segmentM;\n  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  var endX = lerp(x1, x2, interpolate);\n  var endY = lerp(y1, y2, interpolate); // Keep text upright\n\n  var reverse;\n\n  if (rotation) {\n    var flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  var PI = Math.PI;\n  var result = [];\n  var singleSegment = startOffset + stride === offset;\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n  var previousAngle; // All on the same segment\n\n  if (singleSegment) {\n    advance();\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n\n    var x = (endX + beginX) / 2;\n    var y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n\n  for (var i = 0, ii = text.length; i < ii;) {\n    advance();\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n\n    previousAngle = angle;\n    var iStart = i;\n    var charLength = 0;\n\n    for (; i < ii; ++i) {\n      var index = reverse ? ii - i - 1 : i;\n      var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n\n      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {\n        break;\n      }\n\n      charLength += len;\n    }\n\n    if (i === iStart) {\n      continue;\n    }\n\n    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);\n    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["lerp","rotate","drawTextOnPath","flatCoordinates","offset","end","stride","text","startM","maxAngle","scale","measureAndCacheTextWidth","font","cache","rotation","x2","y2","x1","y1","segmentLength","segmentM","advance","Math","sqrt","interpolate","beginX","beginY","startOffset","startLength","endM","endX","endY","reverse","flat","PI","result","singleSegment","previousAngle","atan2","x","y","i","ii","length","angle","undefined","delta","abs","iStart","charLength","index","len","chars","substring","push"],"sourceRoot":"","sources":["../../src/geom/flat/textpath.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}