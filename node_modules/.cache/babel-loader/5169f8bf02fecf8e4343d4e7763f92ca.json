{"ast":null,"code":"import _toArray from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _slicedToArray from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.object.from-entries.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nvar CRLFCRLF = '\\r\\n\\r\\n';\n/*\n * Shim for 'Object.fromEntries'\n */\n\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n\n  var obj = {};\n\n  var _iterator = _createForOfIteratorHelper(items),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          key = _step$value[0],\n          value = _step$value[1];\n\n      obj[key.toLowerCase()] = value;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return obj;\n}\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\n\n\nfunction parseHeaders(text) {\n  var items = text.split('\\r\\n').map(function (line) {\n    var kv = line.split(':').map(function (str) {\n      return str.trim();\n    });\n    kv[0] = kv[0].toLowerCase();\n    return kv;\n  });\n  return itemsToObject(items);\n}\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\n\n\nexport function parseContentType(rawContentType) {\n  var _rawContentType$split = rawContentType.split(';').map(function (s) {\n    return s.trim();\n  }),\n      _rawContentType$split2 = _toArray(_rawContentType$split),\n      type = _rawContentType$split2[0],\n      rawParams = _rawContentType$split2.slice(1);\n\n  var paramsItems = rawParams.map(function (param) {\n    return param.split('=');\n  });\n  return {\n    type: type,\n    params: itemsToObject(paramsItems)\n  };\n}\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\n\nexport function parseContentRange(rawContentRange) {\n  var start;\n  var end;\n  var total;\n\n  if (rawContentRange) {\n    var _rawContentRange$matc = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n\n    var _rawContentRange$matc2 = _slicedToArray(_rawContentRange$matc, 4);\n\n    start = _rawContentRange$matc2[1];\n    end = _rawContentRange$matc2[2];\n    total = _rawContentRange$matc2[3];\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return {\n    start: start,\n    end: end,\n    total: total\n  };\n}\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\n\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  var offset = null;\n  var decoder = new TextDecoder('ascii');\n  var out = [];\n  var startBoundary = \"--\".concat(boundary);\n  var endBoundary = \"\".concat(startBoundary, \"--\"); // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n\n  for (var i = 0; i < 10; ++i) {\n    var text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));\n\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    var _text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset))); // break if we arrived at the end\n\n\n    if (_text.length === 0 || _text.startsWith(endBoundary)) {\n      break;\n    } // assert that we are actually dealing with a byterange and are at the correct offset\n\n\n    if (!_text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    } // get a substring from where we read the headers\n\n\n    var innerText = _text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    } // find the double linebreak that denotes the end of the headers\n\n\n    var endOfHeaders = innerText.indexOf(CRLFCRLF); // parse the headers to get the content range size\n\n    var headers = parseHeaders(innerText.substr(0, endOfHeaders));\n\n    var _parseContentRange = parseContentRange(headers['content-range']),\n        start = _parseContentRange.start,\n        end = _parseContentRange.end,\n        total = _parseContentRange.total; // calculate the length of the slice and the next offset\n\n\n    var startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    var length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers: headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length: length,\n      fileSize: total\n    });\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/source/httputils.js"],"names":["CRLFCRLF","itemsToObject","items","Object","fromEntries","obj","key","value","toLowerCase","parseHeaders","text","split","map","line","kv","str","trim","parseContentType","rawContentType","s","type","rawParams","paramsItems","param","params","parseContentRange","rawContentRange","start","end","total","match","parseInt","parseByteRanges","responseArrayBuffer","boundary","offset","decoder","TextDecoder","out","startBoundary","endBoundary","i","decode","Uint8Array","length","Error","byteLength","Math","min","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","push","data","slice","fileSize"],"mappings":"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","sourcesContent":["const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n"]},"metadata":{},"sourceType":"module"}