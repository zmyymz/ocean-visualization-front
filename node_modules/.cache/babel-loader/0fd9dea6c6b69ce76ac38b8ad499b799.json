{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.error.cause.js\";\nconst CRLFCRLF = '\\r\\n\\r\\n';\n/*\n * Shim for 'Object.fromEntries'\n */\n\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n\n  const obj = {};\n\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n\n  return obj;\n}\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\n\n\nfunction parseHeaders(text) {\n  const items = text.split('\\r\\n').map(line => {\n    const kv = line.split(':').map(str => str.trim());\n    kv[0] = kv[0].toLowerCase();\n    return kv;\n  });\n  return itemsToObject(items);\n}\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\n\n\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map(s => s.trim());\n  const paramsItems = rawParams.map(param => param.split('='));\n  return {\n    type,\n    params: itemsToObject(paramsItems)\n  };\n}\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\n\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return {\n    start,\n    end,\n    total\n  };\n}\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\n\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`; // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));\n\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset))); // break if we arrived at the end\n\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    } // assert that we are actually dealing with a byterange and are at the correct offset\n\n\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    } // get a substring from where we read the headers\n\n\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    } // find the double linebreak that denotes the end of the headers\n\n\n    const endOfHeaders = innerText.indexOf(CRLFCRLF); // parse the headers to get the content range size\n\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const {\n      start,\n      end,\n      total\n    } = parseContentRange(headers['content-range']); // calculate the length of the slice and the next offset\n\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total\n    });\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/source/httputils.js"],"names":["CRLFCRLF","itemsToObject","items","Object","fromEntries","obj","key","value","toLowerCase","parseHeaders","text","split","map","line","kv","str","trim","parseContentType","rawContentType","type","rawParams","s","paramsItems","param","params","parseContentRange","rawContentRange","start","end","total","match","parseInt","parseByteRanges","responseArrayBuffer","boundary","offset","decoder","TextDecoder","out","startBoundary","endBoundary","i","decode","Uint8Array","length","Error","byteLength","Math","min","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","push","data","slice","fileSize"],"mappings":"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","sourcesContent":["const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n"]},"metadata":{},"sourceType":"module"}