{"ast":null,"code":"import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = this.parsedUrl.protocol === 'http:' ? http : https;\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get({ ...this.parsedUrl,\n        headers\n      }, response => {\n        const dataPromise = new Promise(resolveData => {\n          const chunks = []; // collect chunks\n\n          response.on('data', chunk => {\n            chunks.push(chunk);\n          }); // concatenate all chunks and resolve the promise with the resulting buffer\n\n          response.on('end', () => {\n            const data = Buffer.concat(chunks).buffer;\n            resolveData(data);\n          });\n          response.on('error', reject);\n        });\n        resolve(new HttpResponse(response, dataPromise));\n      });\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({\n    headers,\n    signal\n  } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n\n}","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/source/client/http.js"],"names":["http","https","urlMod","BaseClient","BaseResponse","AbortError","HttpResponse","constructor","response","dataPromise","status","statusCode","getHeader","name","headers","getData","data","HttpClient","url","parsedUrl","parse","httpApi","protocol","constructRequest","signal","Promise","resolve","reject","request","get","resolveData","chunks","on","chunk","push","Buffer","concat","buffer","aborted","destroy","addEventListener"],"mappings":"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","sourcesContent":["import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}