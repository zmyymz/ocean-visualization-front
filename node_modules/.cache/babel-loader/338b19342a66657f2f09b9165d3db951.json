{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable } from '../style/expressions.js';\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\n\nvar ShaderBuilder =\n/** @class */\nfunction () {\n  function ShaderBuilder() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n\n    this.attributes = [];\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n\n    this.varyings = [];\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.sizeExpression = 'vec2(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.rotationExpression = '0.0';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.offsetExpression = 'vec2(0.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.colorExpression = 'vec4(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.discardExpression = 'false';\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.rotateWithView = false;\n  }\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.addUniform = function (name) {\n    this.uniforms.push(name);\n    return this;\n  };\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.addAttribute = function (name) {\n    this.attributes.push(name);\n    return this;\n  };\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.addVarying = function (name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  };\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setSizeExpression = function (expression) {\n    this.sizeExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setRotationExpression = function (expression) {\n    this.rotationExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setSymbolOffsetExpression = function (expression) {\n    this.offsetExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setColorExpression = function (expression) {\n    this.colorExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setTextureCoordinateExpression = function (expression) {\n    this.texCoordExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setFragmentDiscardExpression = function (expression) {\n    this.discardExpression = expression;\n    return this;\n  };\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setSymbolRotateWithView = function (rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  };\n  /**\n   * @return {string} Previously set size expression\n   */\n\n\n  ShaderBuilder.prototype.getSizeExpression = function () {\n    return this.sizeExpression;\n  };\n  /**\n   * @return {string} Previously set symbol offset expression\n   */\n\n\n  ShaderBuilder.prototype.getOffsetExpression = function () {\n    return this.offsetExpression;\n  };\n  /**\n   * @return {string} Previously set color expression\n   */\n\n\n  ShaderBuilder.prototype.getColorExpression = function () {\n    return this.colorExpression;\n  };\n  /**\n   * @return {string} Previously set texture coordinate expression\n   */\n\n\n  ShaderBuilder.prototype.getTextureCoordinateExpression = function () {\n    return this.texCoordExpression;\n  };\n  /**\n   * @return {string} Previously set fragment discard expression\n   */\n\n\n  ShaderBuilder.prototype.getFragmentDiscardExpression = function () {\n    return this.discardExpression;\n  };\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n\n\n  ShaderBuilder.prototype.getSymbolVertexShader = function (forHitDetection) {\n    var offsetMatrix = this.rotateWithView ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';\n    var attributes = this.attributes;\n    var varyings = this.varyings;\n\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n\n    return \"precision mediump float;\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\".concat(this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nattribute vec2 a_position;\\nattribute float a_index;\\n\").concat(attributes.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n'), \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\").concat(varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\nvoid main(void) {\\n  mat4 offsetMatrix = \").concat(offsetMatrix, \";\\n  vec2 halfSize = \").concat(this.sizeExpression, \" * 0.5;\\n  vec2 offset = \").concat(this.offsetExpression, \";\\n  float angle = \").concat(this.rotationExpression, \";\\n  float offsetX;\\n  float offsetY;\\n  if (a_index == 0.0) {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  } else if (a_index == 1.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else if (a_index == 2.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  }\\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  vec4 texCoord = \").concat(this.texCoordExpression, \";\\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\\n  v_texCoord = vec2(u, v);\\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v_quadCoord = vec2(u, v);\\n\").concat(varyings.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n'), \"\\n}\");\n  };\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n\n\n  ShaderBuilder.prototype.getSymbolFragmentShader = function (forHitDetection) {\n    var hitDetectionBypass = forHitDetection ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;' : '';\n    var varyings = this.varyings;\n\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n\n    return \"precision mediump float;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\".concat(this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\").concat(varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\nvoid main(void) {\\n  if (\").concat(this.discardExpression, \") { discard; }\\n  gl_FragColor = \").concat(this.colorExpression, \";\\n  gl_FragColor.rgb *= gl_FragColor.a;\\n\").concat(hitDetectionBypass, \"\\n}\");\n  };\n\n  return ShaderBuilder;\n}();\n\nexport { ShaderBuilder };\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\n\nexport function parseLiteralStyle(style) {\n  var symbStyle = style.symbol;\n  var size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  var color = symbStyle.color || 'white';\n  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  var offset = symbStyle.offset || [0, 0];\n  var opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  var rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n\n  var vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {}\n  };\n  var parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n  var parsedOffset = expressionToGlsl(vertContext, offset, ValueTypes.NUMBER_ARRAY);\n  var parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);\n  var parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n\n  var fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {}\n  };\n  var parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  var parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);\n  var opacityFilter = '1.0';\n  var visibleSize = \"vec2(\".concat(expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER), \").x\");\n\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n\n    case 'circle':\n      opacityFilter = \"(1.0-smoothstep(1.-4./\".concat(visibleSize, \",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))\");\n      break;\n\n    case 'triangle':\n      var st = '(v_quadCoord*2.-1.)';\n      var a = \"(atan(\".concat(st, \".x,\").concat(st, \".y))\");\n      opacityFilter = \"(1.0-smoothstep(.5-3./\".concat(visibleSize, \",.5,cos(floor(.5+\").concat(a, \"/2.094395102)*2.094395102-\").concat(a, \")*length(\").concat(st, \")))\");\n      break;\n\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n\n  var builder = new ShaderBuilder().setSizeExpression(\"vec2(\".concat(parsedSize, \")\")).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(\"vec4(\".concat(parsedColor, \".rgb, \").concat(parsedColor, \".a * \").concat(parsedOpacity, \" * \").concat(opacityFilter, \")\"));\n\n  if (style.filter) {\n    var parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(\"!\".concat(parsedFilter));\n  }\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n\n\n  var uniforms = {}; // define one uniform per variable\n\n  fragContext.variables.forEach(function (varName) {\n    var uniformName = uniformNameForVariable(varName);\n    builder.addUniform(\"float \".concat(uniformName));\n\n    uniforms[uniformName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(\"The following variable is missing from the style: \".concat(varName));\n      }\n\n      var value = style.variables[varName];\n\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    var texture = new Image();\n    texture.crossOrigin = symbStyle.crossOrigin === undefined ? 'anonymous' : symbStyle.crossOrigin;\n    texture.src = symbStyle.src;\n    builder.addUniform('sampler2D u_texture').setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');\n    uniforms['u_texture'] = texture;\n  } // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n\n\n  fragContext.attributes.forEach(function (attrName) {\n    if (vertContext.attributes.indexOf(attrName) === -1) {\n      vertContext.attributes.push(attrName);\n    }\n\n    builder.addVarying(\"v_\".concat(attrName), 'float', \"a_\".concat(attrName));\n  }); // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(\"float a_\".concat(attrName));\n  });\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          var value = props[attributeName];\n\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        }\n      };\n    }),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"mappings":";;AAAA;;;;AAKA,SACEA,UADF,EAEEC,gBAFF,EAGEC,yBAHF,EAIEC,sBAJF,QAKO,yBALP;AAOA;;;;;;;;AAQA;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AACE;AACE;;;;;AAKA,SAAKC,QAAL,GAAgB,EAAhB;AAEA;;;;;;AAKA,SAAKC,UAAL,GAAkB,EAAlB;AAEA;;;;;;AAKA,SAAKC,QAAL,GAAgB,EAAhB;AAEA;;;;;AAIA,SAAKC,cAAL,GAAsB,WAAtB;AAEA;;;;;AAIA,SAAKC,kBAAL,GAA0B,KAA1B;AAEA;;;;;AAIA,SAAKC,gBAAL,GAAwB,WAAxB;AAEA;;;;;AAIA,SAAKC,eAAL,GAAuB,WAAvB;AAEA;;;;;AAIA,SAAKC,kBAAL,GAA0B,0BAA1B;AAEA;;;;;AAIA,SAAKC,iBAAL,GAAyB,OAAzB;AAEA;;;;;AAIA,SAAKC,cAAL,GAAsB,KAAtB;AACD;AAED;;;;;;;;AAMAC,iDAAWC,IAAX,EAAe;AACb,SAAKX,QAAL,CAAcY,IAAd,CAAmBD,IAAnB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;;;;AAMAD,mDAAaC,IAAb,EAAiB;AACf,SAAKV,UAAL,CAAgBW,IAAhB,CAAqBD,IAArB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;;;;;;AAQAD,iDAAWC,IAAX,EAAiBE,IAAjB,EAAuBC,UAAvB,EAAiC;AAC/B,SAAKZ,QAAL,CAAcU,IAAd,CAAmB;AACjBD,UAAI,EAAEA,IADW;AAEjBE,UAAI,EAAEA,IAFW;AAGjBC,gBAAU,EAAEA;AAHK,KAAnB;AAKA,WAAO,IAAP;AACD,GAPD;AASA;;;;;;;;;AAOAJ,wDAAkBI,UAAlB,EAA4B;AAC1B,SAAKX,cAAL,GAAsBW,UAAtB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;;;;;AAOAJ,4DAAsBI,UAAtB,EAAgC;AAC9B,SAAKV,kBAAL,GAA0BU,UAA1B;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;;;;;;AAQAJ,gEAA0BI,UAA1B,EAAoC;AAClC,SAAKT,gBAAL,GAAwBS,UAAxB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;;;;;AAOAJ,yDAAmBI,UAAnB,EAA6B;AAC3B,SAAKR,eAAL,GAAuBQ,UAAvB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;;;;;AAOAJ,qEAA+BI,UAA/B,EAAyC;AACvC,SAAKP,kBAAL,GAA0BO,UAA1B;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;;;;;;;AASAJ,mEAA6BI,UAA7B,EAAuC;AACrC,SAAKN,iBAAL,GAAyBM,UAAzB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;;;;AAMAJ,8DAAwBD,cAAxB,EAAsC;AACpC,SAAKA,cAAL,GAAsBA,cAAtB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;;;;;AAGAC;AACE,WAAO,KAAKP,cAAZ;AACD,GAFD;AAIA;;;;;AAGAO;AACE,WAAO,KAAKL,gBAAZ;AACD,GAFD;AAIA;;;;;AAGAK;AACE,WAAO,KAAKJ,eAAZ;AACD,GAFD;AAIA;;;;;AAGAI;AACE,WAAO,KAAKH,kBAAZ;AACD,GAFD;AAIA;;;;;AAGAG;AACE,WAAO,KAAKF,iBAAZ;AACD,GAFD;AAIA;;;;;;;;;;;;;;;;;;;AAiBAE,4DAAsBK,eAAtB,EAAqC;AACnC,QAAMC,YAAY,GAAG,KAAKP,cAAL,GACjB,4CADiB,GAEjB,qBAFJ;AAIA,QAAIR,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAIC,QAAQ,GAAG,KAAKA,QAApB;;AAEA,QAAIa,eAAJ,EAAqB;AACnBd,gBAAU,GAAGA,UAAU,CAACgB,MAAX,CAAkB,iBAAlB,CAAb;AACAf,cAAQ,GAAGA,QAAQ,CAACe,MAAT,CAAgB;AACzBN,YAAI,EAAE,YADmB;AAEzBE,YAAI,EAAE,MAFmB;AAGzBC,kBAAU,EAAE;AAHa,OAAhB,CAAX;AAKD;;AAED,WAAO,wNAOT,KAAKd,QAAL,CACCkB,GADD,CACK,UAAUC,OAAV,EAAiB;AACpB,aAAO,aAAaA,OAAb,GAAuB,GAA9B;AACD,KAHD,EAICC,IAJD,CAIM,IAJN,CAPS,EAWE,0DAXF,EAWEH,MAXF,CAcThB,UAAU,CACTiB,GADD,CACK,UAAUG,SAAV,EAAmB;AACtB,aAAO,eAAeA,SAAf,GAA2B,GAAlC;AACD,KAHD,EAICD,IAJD,CAIM,IAJN,CAdS,EAkBE,yDAlBF,EAkBEH,MAlBF,CAqBTf,QAAQ,CACPgB,GADD,CACK,UAAUI,OAAV,EAAiB;AACpB,aAAO,aAAaA,OAAO,CAACT,IAArB,GAA4B,GAA5B,GAAkCS,OAAO,CAACX,IAA1C,GAAiD,GAAxD;AACD,KAHD,EAICS,IAJD,CAIM,IAJN,CArBS,EAyBE,6CAzBF,EAyBEH,MAzBF,CA2BaD,YA3Bb,EA2ByB,uBA3BzB,EA2ByBC,MA3BzB,CA4BS,KAAKd,cA5Bd,EA4B4B,2BA5B5B,EA4B4Bc,MA5B5B,CA6BO,KAAKZ,gBA7BZ,EA6B4B,qBA7B5B,EA6B4BY,MA7B5B,CA8BO,KAAKb,kBA9BZ,EA8B8B,ohCA9B9B,EA8B8Ba,MA9B9B,CAgDS,KAAKV,kBAhDd,EAgDgC,0TAhDhC,EAgDgCU,MAhDhC,CAuDTf,QAAQ,CACPgB,GADD,CACK,UAAUI,OAAV,EAAiB;AACpB,aAAO,OAAOA,OAAO,CAACX,IAAf,GAAsB,KAAtB,GAA8BW,OAAO,CAACR,UAAtC,GAAmD,GAA1D;AACD,KAHD,EAICM,IAJD,CAIM,IAJN,CAvDS,EA2DE,KA3DF,CAAP;AA6DD,GA9ED;AAgFA;;;;;;;;;;;;;AAWAV,8DAAwBK,eAAxB,EAAuC;AACrC,QAAMQ,kBAAkB,GAAGR,eAAe,GACtC,qEADsC,GAEtC,EAFJ;AAIA,QAAIb,QAAQ,GAAG,KAAKA,QAApB;;AAEA,QAAIa,eAAJ,EAAqB;AACnBb,cAAQ,GAAGA,QAAQ,CAACe,MAAT,CAAgB;AACzBN,YAAI,EAAE,YADmB;AAEzBE,YAAI,EAAE,MAFmB;AAGzBC,kBAAU,EAAE;AAHa,OAAhB,CAAX;AAKD;;AAED,WAAO,+GAIT,KAAKd,QAAL,CACCkB,GADD,CACK,UAAUC,OAAV,EAAiB;AACpB,aAAO,aAAaA,OAAb,GAAuB,GAA9B;AACD,KAHD,EAICC,IAJD,CAIM,IAJN,CAJS,EAQE,yDARF,EAQEH,MARF,CAWTf,QAAQ,CACPgB,GADD,CACK,UAAUI,OAAV,EAAiB;AACpB,aAAO,aAAaA,OAAO,CAACT,IAArB,GAA4B,GAA5B,GAAkCS,OAAO,CAACX,IAA1C,GAAiD,GAAxD;AACD,KAHD,EAICS,IAJD,CAIM,IAJN,CAXS,EAeE,6BAfF,EAeEH,MAfF,CAiBH,KAAKT,iBAjBF,EAiBmB,mCAjBnB,EAiBmBS,MAjBnB,CAkBQ,KAAKX,eAlBb,EAkB4B,4CAlB5B,EAkB4BW,MAlB5B,CAoBTM,kBApBS,EAoBS,KApBT,CAAP;AAsBD,GArCD;;AAsCF;AAAC,CApXD;;;AAsXA;;;;;;;AAOA;;;;;;;;;;;;AAWA,OAAM,SAAUC,iBAAV,CAA4BC,KAA5B,EAAiC;AACrC,MAAMC,SAAS,GAAGD,KAAK,CAACE,MAAxB;AACA,MAAMC,IAAI,GAAGF,SAAS,CAACE,IAAV,KAAmBC,SAAnB,GAA+BH,SAAS,CAACE,IAAzC,GAAgD,CAA7D;AACA,MAAME,KAAK,GAAGJ,SAAS,CAACI,KAAV,IAAmB,OAAjC;AACA,MAAMC,QAAQ,GAAGL,SAAS,CAACM,YAAV,IAA0B,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAA3C;AACA,MAAMC,MAAM,GAAGP,SAAS,CAACO,MAAV,IAAoB,CAAC,CAAD,EAAI,CAAJ,CAAnC;AACA,MAAMC,OAAO,GAAGR,SAAS,CAACQ,OAAV,KAAsBL,SAAtB,GAAkCH,SAAS,CAACQ,OAA5C,GAAsD,CAAtE;AACA,MAAMC,QAAQ,GAAGT,SAAS,CAACS,QAAV,KAAuBN,SAAvB,GAAmCH,SAAS,CAACS,QAA7C,GAAwD,CAAzE;AAEA;;;;AAGA,MAAMC,WAAW,GAAG;AAClBC,oBAAgB,EAAE,KADA;AAElBC,aAAS,EAAE,EAFO;AAGlBrC,cAAU,EAAE,EAHM;AAIlBsC,qBAAiB,EAAE,EAJD;AAKlBC,aAAS,EAAE;AALO,GAApB;AAOA,MAAMC,UAAU,GAAG5C,gBAAgB,CACjCuC,WADiC,EAEjCR,IAFiC,EAGjChC,UAAU,CAAC8C,YAAX,GAA0B9C,UAAU,CAAC+C,MAHJ,CAAnC;AAKA,MAAMC,YAAY,GAAG/C,gBAAgB,CACnCuC,WADmC,EAEnCH,MAFmC,EAGnCrC,UAAU,CAAC8C,YAHwB,CAArC;AAKA,MAAMG,cAAc,GAAGhD,gBAAgB,CACrCuC,WADqC,EAErCL,QAFqC,EAGrCnC,UAAU,CAAC8C,YAH0B,CAAvC;AAKA,MAAMI,cAAc,GAAGjD,gBAAgB,CACrCuC,WADqC,EAErCD,QAFqC,EAGrCvC,UAAU,CAAC+C,MAH0B,CAAvC;AAMA;;;;AAGA,MAAMI,WAAW,GAAG;AAClBV,oBAAgB,EAAE,IADA;AAElBC,aAAS,EAAEF,WAAW,CAACE,SAFL;AAGlBrC,cAAU,EAAE,EAHM;AAIlBsC,qBAAiB,EAAEH,WAAW,CAACG,iBAJb;AAKlBC,aAAS,EAAE;AALO,GAApB;AAOA,MAAMQ,WAAW,GAAGnD,gBAAgB,CAACkD,WAAD,EAAcjB,KAAd,EAAqBlC,UAAU,CAACqD,KAAhC,CAApC;AACA,MAAMC,aAAa,GAAGrD,gBAAgB,CACpCkD,WADoC,EAEpCb,OAFoC,EAGpCtC,UAAU,CAAC+C,MAHyB,CAAtC;AAMA,MAAIQ,aAAa,GAAG,KAApB;AACA,MAAMC,WAAW,GAAG,eAAQvD,gBAAgB,CAC1CkD,WAD0C,EAE1CnB,IAF0C,EAG1ChC,UAAU,CAAC8C,YAAX,GAA0B9C,UAAU,CAAC+C,MAHK,CAAxB,EAInB,KAJmB,CAApB;;AAKA,UAAQjB,SAAS,CAAC2B,UAAlB;AACE,SAAK,QAAL;AACE;;AACF,SAAK,OAAL;AACE;AACF;;AACA,SAAK,QAAL;AACEF,mBAAa,GAAG,gCAAyBC,WAAzB,EAAoC,6CAApC,CAAhB;AACA;;AACF,SAAK,UAAL;AACE,UAAME,EAAE,GAAG,qBAAX;AACA,UAAMC,CAAC,GAAG,gBAASD,EAAT,EAAW,KAAX,EAAWrC,MAAX,CAAiBqC,EAAjB,EAAmB,MAAnB,CAAV;AACAH,mBAAa,GAAG,gCAAyBC,WAAzB,EAAoC,mBAApC,EAAoCnC,MAApC,CAAwDsC,CAAxD,EAAyD,4BAAzD,EAAyDtC,MAAzD,CAAsFsC,CAAtF,EAAuF,WAAvF,EAAuFtC,MAAvF,CAAmGqC,EAAnG,EAAqG,KAArG,CAAhB;AACA;;AAEF;AACE,YAAM,IAAIE,KAAJ,CAAU,6BAA6B9B,SAAS,CAAC2B,UAAjD,CAAN;AAhBJ;;AAmBA,MAAMI,OAAO,GAAG,IAAI/C,aAAJ,GACbgD,iBADa,CACK,eAAQjB,UAAR,EAAkB,GAAlB,CADL,EAEbkB,qBAFa,CAESb,cAFT,EAGbc,yBAHa,CAGahB,YAHb,EAIbiB,8BAJa,CAIkBhB,cAJlB,EAKbiB,uBALa,CAKW,CAAC,CAACpC,SAAS,CAACjB,cALvB,EAMbsD,kBANa,CAOZ,eAAQf,WAAR,EAAmB,QAAnB,EAAmB/B,MAAnB,CAA4B+B,WAA5B,EAAuC,OAAvC,EAAuC/B,MAAvC,CAA+CiC,aAA/C,EAA4D,KAA5D,EAA4DjC,MAA5D,CAAkEkC,aAAlE,EAA+E,GAA/E,CAPY,CAAhB;;AAUA,MAAI1B,KAAK,CAACuC,MAAV,EAAkB;AAChB,QAAMC,YAAY,GAAGpE,gBAAgB,CACnCkD,WADmC,EAEnCtB,KAAK,CAACuC,MAF6B,EAGnCpE,UAAU,CAACsE,OAHwB,CAArC;AAKAT,WAAO,CAACU,4BAAR,CAAqC,WAAIF,YAAJ,CAArC;AACD;AAED;;;AACA,MAAMjE,QAAQ,GAAG,EAAjB,CAtGqC,CAwGrC;;AACA+C,aAAW,CAACT,SAAZ,CAAsB8B,OAAtB,CAA8B,UAAUC,OAAV,EAAiB;AAC7C,QAAMC,WAAW,GAAGvE,sBAAsB,CAACsE,OAAD,CAA1C;AACAZ,WAAO,CAACc,UAAR,CAAmB,gBAASD,WAAT,CAAnB;;AACAtE,YAAQ,CAACsE,WAAD,CAAR,GAAwB;AACtB,UAAI,CAAC7C,KAAK,CAACa,SAAP,IAAoBb,KAAK,CAACa,SAAN,CAAgB+B,OAAhB,MAA6BxC,SAArD,EAAgE;AAC9D,cAAM,IAAI2B,KAAJ,CACJ,4DAAqDa,OAArD,CADI,CAAN;AAGD;;AACD,UAAIG,KAAK,GAAG/C,KAAK,CAACa,SAAN,CAAgB+B,OAAhB,CAAZ;;AACA,UAAI,OAAOG,KAAP,KAAiB,QAArB,EAA+B;AAC7BA,aAAK,GAAG1E,yBAAyB,CAACsC,WAAD,EAAcoC,KAAd,CAAjC;AACD;;AACD,aAAOA,KAAK,KAAK3C,SAAV,GAAsB2C,KAAtB,GAA8B,CAAC,OAAtC,CAVsB,CAUyB;AAChD,KAXD;AAYD,GAfD;;AAiBA,MAAI9C,SAAS,CAAC2B,UAAV,KAAyB,OAAzB,IAAoC3B,SAAS,CAAC+C,GAAlD,EAAuD;AACrD,QAAMC,OAAO,GAAG,IAAIC,KAAJ,EAAhB;AACAD,WAAO,CAACE,WAAR,GACElD,SAAS,CAACkD,WAAV,KAA0B/C,SAA1B,GAAsC,WAAtC,GAAoDH,SAAS,CAACkD,WADhE;AAEAF,WAAO,CAACD,GAAR,GAAc/C,SAAS,CAAC+C,GAAxB;AACAhB,WAAO,CACJc,UADH,CACc,qBADd,EAEGR,kBAFH,CAGIN,OAAO,CAACoB,kBAAR,KAA+B,qCAHnC;AAKA7E,YAAQ,CAAC,WAAD,CAAR,GAAwB0E,OAAxB;AACD,GArIoC,CAuIrC;AACA;;;AACA3B,aAAW,CAAC9C,UAAZ,CAAuBmE,OAAvB,CAA+B,UAAUU,QAAV,EAAkB;AAC/C,QAAI1C,WAAW,CAACnC,UAAZ,CAAuB8E,OAAvB,CAA+BD,QAA/B,MAA6C,CAAC,CAAlD,EAAqD;AACnD1C,iBAAW,CAACnC,UAAZ,CAAuBW,IAAvB,CAA4BkE,QAA5B;AACD;;AACDrB,WAAO,CAACuB,UAAR,CAAmB,YAAKF,QAAL,CAAnB,EAAoC,OAApC,EAA6C,YAAKA,QAAL,CAA7C;AACD,GALD,EAzIqC,CAgJrC;;AACA1C,aAAW,CAACnC,UAAZ,CAAuBmE,OAAvB,CAA+B,UAAUU,QAAV,EAAkB;AAC/CrB,WAAO,CAACwB,YAAR,CAAqB,kBAAWH,QAAX,CAArB;AACD,GAFD;AAIA,SAAO;AACLrB,WAAO,EAAEA,OADJ;AAELxD,cAAU,EAAEmC,WAAW,CAACnC,UAAZ,CAAuBiB,GAAvB,CAA2B,UAAUgE,aAAV,EAAuB;AAC5D,aAAO;AACLvE,YAAI,EAAEuE,aADD;AAELC,gBAAQ,EAAE,UAAUC,OAAV,EAAmBC,KAAnB,EAAwB;AAChC,cAAIb,KAAK,GAAGa,KAAK,CAACH,aAAD,CAAjB;;AACA,cAAI,OAAOV,KAAP,KAAiB,QAArB,EAA+B;AAC7BA,iBAAK,GAAG1E,yBAAyB,CAACsC,WAAD,EAAcoC,KAAd,CAAjC;AACD;;AACD,iBAAOA,KAAK,KAAK3C,SAAV,GAAsB2C,KAAtB,GAA8B,CAAC,OAAtC,CALgC,CAKe;AAChD;AARI,OAAP;AAUD,KAXW,CAFP;AAcLxE,YAAQ,EAAEA;AAdL,GAAP;AAgBD","names":["ValueTypes","expressionToGlsl","getStringNumberEquivalent","uniformNameForVariable","uniforms","attributes","varyings","sizeExpression","rotationExpression","offsetExpression","colorExpression","texCoordExpression","discardExpression","rotateWithView","ShaderBuilder","name","push","type","expression","forHitDetection","offsetMatrix","concat","map","uniform","join","attribute","varying","hitDetectionBypass","parseLiteralStyle","style","symbStyle","symbol","size","undefined","color","texCoord","textureCoord","offset","opacity","rotation","vertContext","inFragmentShader","variables","stringLiteralsMap","functions","parsedSize","NUMBER_ARRAY","NUMBER","parsedOffset","parsedTexCoord","parsedRotation","fragContext","parsedColor","COLOR","parsedOpacity","opacityFilter","visibleSize","symbolType","st","a","Error","builder","setSizeExpression","setRotationExpression","setSymbolOffsetExpression","setTextureCoordinateExpression","setSymbolRotateWithView","setColorExpression","filter","parsedFilter","BOOLEAN","setFragmentDiscardExpression","forEach","varName","uniformName","addUniform","value","src","texture","Image","crossOrigin","getColorExpression","attrName","indexOf","addVarying","addAttribute","attributeName","callback","feature","props"],"sourceRoot":"","sources":["../src/webgl/ShaderBuilder.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}