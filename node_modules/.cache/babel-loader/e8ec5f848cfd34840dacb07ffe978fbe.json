{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/**\n * @module resample\n */\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\n\n\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map(array => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[cy * inWidth + cx];\n        newArray[y * outWidth + x] = value;\n      }\n    }\n\n    return newArray;\n  });\n} // simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n\nfunction lerp(v0, v1, t) {\n  return (1 - t) * v0 + t * v1;\n}\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\n\n\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map(array => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), inHeight - 1);\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), inWidth - 1);\n        const ll = array[yl * inWidth + xl];\n        const hl = array[yl * inWidth + xh];\n        const lh = array[yh * inWidth + xl];\n        const hh = array[yh * inWidth + xh];\n        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);\n        newArray[y * outWidth + x] = value;\n      }\n    }\n\n    return newArray;\n  });\n}\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\n\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\n\nexport function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[cy * inWidth * samples + cx * samples + i];\n        newArray[y * outWidth * samples + x * samples + i] = value;\n      }\n    }\n  }\n\n  return newArray;\n}\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\n\nexport function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), inHeight - 1);\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), inWidth - 1);\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[yl * inWidth * samples + xl * samples + i];\n        const hl = valueArray[yl * inWidth * samples + xh * samples + i];\n        const lh = valueArray[yh * inWidth * samples + xl * samples + i];\n        const hh = valueArray[yh * inWidth * samples + xh * samples + i];\n        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);\n        newArray[y * outWidth * samples + x * samples + i] = value;\n      }\n    }\n  }\n\n  return newArray;\n}\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\n\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);\n\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);\n\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/resample.js"],"names":["copyNewSize","array","width","height","samplesPerPixel","Object","getPrototypeOf","constructor","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","y","cy","Math","min","round","x","cx","value","lerp","v0","v1","t","resampleBilinear","rawY","yl","floor","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","Error","resampleNearestInterleaved","valueArray","samples","i","resampleBilinearInterleaved","resampleInterleaved"],"mappings":"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","sourcesContent":["/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}