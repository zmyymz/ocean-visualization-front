{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/source/GeoTIFF\n */\n\n\nimport DataTile from './DataTile.js';\nimport State from './State.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { Pool, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls } from 'geotiff';\nimport { Projection, get as getCachedProjection, toUserCoordinate, toUserExtent } from '../proj.js';\nimport { clamp } from '../math.js';\nimport { getCenter, getIntersection } from '../extent.js';\nimport { toSize } from '../size.js';\nimport { fromCode as unitsFromCode } from '../proj/Units.js';\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nvar STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nvar STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nvar workerPool;\n\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n\n  return workerPool;\n}\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\n\n\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    var fileDirectory = image.fileDirectory;\n    return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];\n  }\n}\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\n\n\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.fileDirectory.ImageLength];\n  }\n}\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {number} The image resolution.\n */\n\n\nfunction getResolution(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage)[0];\n  } catch (_) {\n    return referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth;\n  }\n}\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\n\n\nfunction getProjection(image) {\n  var geoKeys = image.geoKeys;\n\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (geoKeys.ProjectedCSTypeGeoKey) {\n    var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    var projection = getCachedProjection(code);\n\n    if (!projection) {\n      var units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey) {\n    var code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    var projection = getCachedProjection(code);\n\n    if (!projection) {\n      var units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n\n    return projection;\n  }\n\n  return null;\n}\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\n\n\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    var requests = new Array(count);\n\n    for (var i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n\n    return Promise.all(requests);\n  });\n}\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\n\n\nfunction getImagesForSource(source, options) {\n  var request;\n\n  if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n\n  return request.then(getImagesForTIFF);\n}\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\n\n\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    var length_1 = expected.length;\n\n    if (!Array.isArray(got) || length_1 != got.length) {\n      var error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n\n    for (var i = 0; i < length_1; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n\n    return;\n  }\n\n  got =\n  /** @type {number} */\n  got;\n\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\n\n\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n\n  return 0;\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\n\n\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n\n  return 255;\n}\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * @api\n */\n\n\nvar GeoTIFFSource =\n/** @class */\nfunction (_super) {\n  __extends(GeoTIFFSource, _super);\n  /**\n   * @param {Options} options Data tile options.\n   */\n\n\n  function GeoTIFFSource(options) {\n    var _this = _super.call(this, {\n      state: State.LOADING,\n      tileGrid: null,\n      projection: null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n\n\n    _this.sourceInfo_ = options.sources;\n    var numSources = _this.sourceInfo_.length;\n    /**\n     * @type {object}\n     * @private\n     */\n\n    _this.sourceOptions_ = options.sourceOptions;\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n\n    _this.sourceImagery_ = new Array(numSources);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    _this.resolutionFactors_ = new Array(numSources);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    _this.samplesPerPixel_;\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n\n    _this.nodataValues_;\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n\n    _this.metadata_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.normalize_ = options.normalize !== false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.addAlpha_ = false;\n    /**\n     * @type {Error}\n     * @private\n     */\n\n    _this.error_ = null;\n    /**\n     * @type {'readRasters' | 'readRGB'}\n     */\n\n    _this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';\n\n    _this.setKey(_this.sourceInfo_.map(function (source) {\n      return source.url;\n    }).join(','));\n\n    var self = _this;\n    var requests = new Array(numSources);\n\n    for (var i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(_this.sourceInfo_[i], _this.sourceOptions_);\n    }\n\n    Promise.all(requests).then(function (sources) {\n      self.configure_(sources);\n    }).catch(function (error) {\n      console.error(error); // eslint-disable-line no-console\n\n      self.error_ = error;\n      self.setState(State.ERROR);\n    });\n    return _this;\n  }\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n\n\n  GeoTIFFSource.prototype.getError = function () {\n    return this.error_;\n  };\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n\n\n  GeoTIFFSource.prototype.configure_ = function (sources) {\n    var extent;\n    var origin;\n    var tileSizes;\n    var resolutions;\n    var samplesPerPixel = new Array(sources.length);\n    var nodataValues = new Array(sources.length);\n    var metadata = new Array(sources.length);\n    var minZoom = 0;\n    var sourceCount = sources.length;\n\n    var _loop_1 = function (sourceIndex) {\n      var images = sources[sourceIndex];\n      var imageCount = images.length;\n      var sourceExtent = void 0;\n      var sourceOrigin = void 0;\n      var sourceTileSizes = new Array(imageCount);\n      var sourceResolutions = new Array(imageCount);\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (var imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        var image = images[imageIndex];\n        var nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue === null ? NaN : nodataValue;\n        var wantedSamples = this_1.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();\n        var level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        sourceResolutions[level] = getResolution(image, images[0]);\n        sourceTileSizes[level] = [image.getTileWidth(), image.getTileHeight()];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        var message = \"Origin mismatch for source \".concat(sourceIndex, \", got [\").concat(sourceOrigin, \"] but expected [\").concat(origin, \"]\");\n        assertEqual(origin, sourceOrigin, 0, message, this_1.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this_1.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n\n        var resolutionFactor_1 = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];\n        this_1.resolutionFactors_[sourceIndex] = resolutionFactor_1;\n        var scaledSourceResolutions = sourceResolutions.map(function (resolution) {\n          return resolution *= resolutionFactor_1;\n        });\n        var message = \"Resolution mismatch for source \".concat(sourceIndex, \", got [\").concat(scaledSourceResolutions, \"] but expected [\").concat(resolutions, \"]\");\n        assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this_1.viewRejector);\n      }\n\n      if (!tileSizes) {\n        tileSizes = sourceTileSizes;\n      } else {\n        assertEqual(tileSizes.slice(minZoom, tileSizes.length), sourceTileSizes, 0, \"Tile size mismatch for source \".concat(sourceIndex), this_1.viewRejector);\n      }\n\n      this_1.sourceImagery_[sourceIndex] = images.reverse();\n    };\n\n    var this_1 = this;\n\n    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      _loop_1(sourceIndex);\n    }\n\n    for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      var sourceImagery = this.sourceImagery_[i];\n\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      var firstSource = sources[0];\n\n      for (var i = firstSource.length - 1; i >= 0; --i) {\n        var image = firstSource[i];\n        var projection = getProjection(image);\n\n        if (projection) {\n          this.projection = projection;\n          break;\n        }\n      }\n    }\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata; // decide if we need to add an alpha band to handle nodata\n\n    outer: for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      var values = nodataValues[sourceIndex]; // option 2: check image metadata for limited bands\n\n      var bands = this.sourceInfo_[sourceIndex].bands;\n\n      if (bands) {\n        for (var i = 0; i < bands.length; ++i) {\n          if (!isNaN(values[bands[i] - 1])) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n\n        continue;\n      } // option 3: check image metadata for all bands\n\n\n      for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (!isNaN(values[imageIndex])) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    var additionalBands = this.addAlpha_ ? 1 : 0;\n    this.bandCount = samplesPerPixel.reduce(function (accumulator, value) {\n      accumulator += value;\n      return accumulator;\n    }, 0) + additionalBands;\n    var tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: tileSizes\n    });\n    this.tileGrid = tileGrid;\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState(State.READY);\n    this.viewResolver({\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: 0\n    });\n  };\n\n  GeoTIFFSource.prototype.loadTile_ = function (z, x, y) {\n    var size = toSize(this.tileGrid.getTileSize(z));\n    var sourceCount = this.sourceImagery_.length;\n    var requests = new Array(sourceCount);\n    var addAlpha = this.addAlpha_;\n    var bandCount = this.bandCount;\n    var samplesPerPixel = this.samplesPerPixel_;\n    var nodataValues = this.nodataValues_;\n    var sourceInfo = this.sourceInfo_;\n\n    var _loop_2 = function (sourceIndex) {\n      var source = sourceInfo[sourceIndex];\n      var resolutionFactor = this_2.resolutionFactors_[sourceIndex];\n      var pixelBounds = [Math.round(x * (size[0] * resolutionFactor)), Math.round(y * (size[1] * resolutionFactor)), Math.round((x + 1) * (size[0] * resolutionFactor)), Math.round((y + 1) * (size[1] * resolutionFactor))];\n      var image = this_2.sourceImagery_[sourceIndex][z];\n      var samples = void 0;\n\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n      /** @type {number|Array<number>} */\n\n\n      var fillValue = void 0;\n\n      if (!isNaN(source.nodata)) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      requests[sourceIndex] = image[this_2.readMethod_]({\n        window: pixelBounds,\n        width: size[0],\n        height: size[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: getWorkerPool(),\n        interleave: false\n      });\n    };\n\n    var this_2 = this;\n\n    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      _loop_2(sourceIndex);\n    }\n\n    var pixelCount = size[0] * size[1];\n    var dataLength = pixelCount * bandCount;\n    var normalize = this.normalize_;\n    var metadata = this.metadata_;\n    return Promise.all(requests).then(function (sourceSamples) {\n      /** @type {Uint8Array|Float32Array} */\n      var data;\n\n      if (normalize) {\n        data = new Uint8Array(dataLength);\n      } else {\n        data = new Float32Array(dataLength);\n      }\n\n      var dataIndex = 0;\n\n      for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n        var transparent = addAlpha;\n\n        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n          var source = sourceInfo[sourceIndex];\n          var min = source.min;\n          var max = source.max;\n          var gain = void 0,\n              bias = void 0;\n\n          if (normalize) {\n            var stats = metadata[sourceIndex][0];\n\n            if (min === undefined) {\n              if (stats && STATISTICS_MINIMUM in stats) {\n                min = parseFloat(stats[STATISTICS_MINIMUM]);\n              } else {\n                min = getMinForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n\n            if (max === undefined) {\n              if (stats && STATISTICS_MAXIMUM in stats) {\n                max = parseFloat(stats[STATISTICS_MAXIMUM]);\n              } else {\n                max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n\n            gain = 255 / (max - min);\n            bias = -min * gain;\n          }\n\n          for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n            var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n            var value = void 0;\n\n            if (normalize) {\n              value = clamp(gain * sourceValue + bias, 0, 255);\n            } else {\n              value = sourceValue;\n            }\n\n            if (!addAlpha) {\n              data[dataIndex] = value;\n            } else {\n              var nodata = source.nodata;\n\n              if (nodata === undefined) {\n                var bandIndex = void 0;\n\n                if (source.bands) {\n                  bandIndex = source.bands[sampleIndex] - 1;\n                } else {\n                  bandIndex = sampleIndex;\n                }\n\n                nodata = nodataValues[sourceIndex][bandIndex];\n              }\n\n              if (sourceValue !== nodata) {\n                transparent = false;\n                data[dataIndex] = value;\n              }\n            }\n\n            dataIndex++;\n          }\n        }\n\n        if (addAlpha) {\n          if (!transparent) {\n            data[dataIndex] = 255;\n          }\n\n          dataIndex++;\n        }\n      }\n\n      return data;\n    });\n  };\n\n  return GeoTIFFSource;\n}(DataTile);\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\n\n\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;","map":{"version":3,"mappings":"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","names":["DataTile","State","TileGrid","Pool","fromUrl","tiffFromUrl","fromUrls","tiffFromUrls","Projection","get","getCachedProjection","toUserCoordinate","toUserExtent","clamp","getCenter","getIntersection","toSize","fromCode","unitsFromCode","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","workerPool","getWorkerPool","getBoundingBox","image","_","fileDirectory","ImageWidth","ImageLength","getOrigin","slice","getResolution","referenceImage","getProjection","geoKeys","ProjectedCSTypeGeoKey","code","projection","units","ProjLinearUnitsGeoKey","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImageCount","then","count","requests","Array","i","getImage","Promise","all","getImagesForSource","source","options","request","overviews","url","assertEqual","expected","got","tolerance","message","rejector","isArray","length_1","length","error","Error","Math","abs","getMinForDataType","array","Int8Array","Int16Array","Int32Array","Float32Array","getMaxForDataType","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","__extends","_super","state","LOADING","tileGrid","opaque","transition","interpolate","wrapX","_this","sourceInfo_","sources","numSources","sourceOptions_","sourceOptions","sourceImagery_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","error_","readMethod_","convertToRGB","setKey","map","join","self","configure_","catch","console","setState","ERROR","GeoTIFFSource","extent","origin","tileSizes","resolutions","samplesPerPixel","nodataValues","metadata","minZoom","sourceCount","sourceIndex","images","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","sourceResolutions","imageIndex","nodataValue","getGDALNoData","getGDALMetadata","NaN","wantedSamples","this_1","bands","getSamplesPerPixel","level","getTileWidth","getTileHeight","concat","viewRejector","resolutionFactor_1","scaledSourceResolutions","resolution","reverse","ii","sourceImagery","unshift","undefined","firstSource","outer","nodata","values","isNaN","additionalBands","bandCount","reduce","accumulator","value","setLoader","loadTile_","bind","READY","viewResolver","center","zoom","z","x","y","size","getTileSize","addAlpha","sourceInfo","resolutionFactor","this_2","pixelBounds","round","samples","bandNumber","fillValue","sampleIndex","window","width","height","pool","interleave","pixelCount","dataLength","sourceSamples","data","dataIndex","pixelIndex","transparent","min","max","gain","bias","stats","parseFloat","sourceValue","bandIndex","prototype","getView"],"sourceRoot":"","sources":["../src/source/GeoTIFF.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}