{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n  /**\n   * @returns {number} the top byte border\n   */\n\n\n  get top() {\n    return this.offset + this.length;\n  }\n\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, {\n    blockSize = 65536,\n    cacheSize = 100\n  } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n    this.blockCache = new LRUCache({\n      max: cacheSize\n    }); // mapping blockId -> Block instance\n\n    this.blockRequests = new Map(); // set of blockIds missing for the current requests\n\n    this.blockIdsToFetch = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n\n\n  async fetch(slices, signal) {\n    const cachedBlocks = new Map();\n    const blockRequests = new Map();\n    const missingBlockIds = new Set();\n\n    for (const {\n      offset,\n      length\n    } of slices) {\n      let top = offset + length;\n      const {\n        fileSize\n      } = this;\n\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize; // chunk the current slice into blocks\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        // check if the block is cached, being requested or still missing\n        const blockId = Math.floor(current / this.blockSize);\n\n        if (this.blockCache.has(blockId)) {\n          cachedBlocks.set(blockId, this.blockCache.get(blockId));\n        } else if (this.blockRequests.has(blockId)) {\n          blockRequests.set(blockId, this.blockRequests.get(blockId));\n        } else if (this.blockIdsToFetch.has(blockId)) {\n          missingBlockIds.add(blockId);\n        } else {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.add(blockId);\n        }\n      }\n    } // allow additional block requests to accumulate\n\n\n    await wait();\n    this.fetchBlocks(signal);\n\n    for (const blockId of missingBlockIds) {\n      const block = this.blockRequests.get(blockId);\n      const cachedBlock = this.blockCache.get(blockId);\n\n      if (block) {\n        blockRequests.set(blockId, block);\n      } else if (cachedBlock) {\n        cachedBlocks.set(blockId, cachedBlock);\n      } else {\n        throw new Error(`Block ${blockId} is not in the block requests`);\n      }\n    } // actually await all pending requests\n\n\n    let results = await Promise.allSettled(Array.from(blockRequests.values())); // perform retries if a block was interrupted by a previous signal\n\n    if (results.some(result => result.status === 'rejected')) {\n      const retriedBlockRequests = new Set();\n\n      for (const [blockId, result] of zip(blockRequests.keys(), results)) {\n        const {\n          rejected,\n          reason\n        } = result;\n\n        if (rejected) {\n          // push some blocks back to the to-fetch list if they were\n          // aborted, but only when a different signal was used\n          if (reason.name === 'AbortError' && reason.signal !== signal) {\n            this.blockIdsToFetch.add(blockId);\n            retriedBlockRequests.add(blockId);\n          }\n        }\n      } // start the retry of some blocks if required\n\n\n      if (this.blockIdsToFetch.length > 0) {\n        this.fetchBlocks(signal);\n\n        for (const blockId of retriedBlockRequests) {\n          const block = this.blockRequests.get(blockId);\n\n          if (!block) {\n            throw new Error(`Block ${blockId} is not in the block requests`);\n          }\n\n          blockRequests.set(blockId, block);\n        }\n\n        results = await Promise.allSettled(Array.from(blockRequests.values()));\n      }\n    } // throw an error (either abort error or AggregateError if no abort was done)\n\n\n    if (results.some(result => result.status === 'rejected')) {\n      if (signal && signal.aborted) {\n        throw new AbortError('Request was aborted');\n      }\n\n      throw new AggregateError(results.filter(result => result.status === 'rejected').map(result => result.reason), 'Request failed');\n    } // extract the actual block responses\n\n\n    const values = results.map(result => result.value); // create a final Map, with all required blocks for this request to satisfy\n\n    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n\n    for (const [blockId, block] of cachedBlocks) {\n      requiredBlocks.set(blockId, block);\n    } // TODO: satisfy each slice\n\n\n    return this.readSliceData(slices, requiredBlocks);\n  }\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n\n\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch); // start requesting slices of data\n\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          const blockRequest = (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(blockOffset, data.byteLength, data);\n              this.blockCache.set(blockId, block);\n              return block;\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n              }\n\n              throw err;\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })();\n\n          this.blockRequests.set(blockId, blockRequest);\n        }\n      }\n\n      this.blockIdsToFetch.clear();\n    }\n  }\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n\n\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n    return groups;\n  }\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n\n\n  readSliceData(slices, blocks) {\n    return slices.map(slice => {\n      const top = slice.offset + slice.length;\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n\n}","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/source/blockedsource.js"],"names":["LRUCache","BaseSource","AbortError","AggregateError","wait","zip","Block","constructor","offset","length","data","top","BlockGroup","blockIds","BlockedSource","source","blockSize","cacheSize","blockCache","max","blockRequests","Map","blockIdsToFetch","Set","fileSize","fetch","slices","signal","cachedBlocks","missingBlockIds","Math","min","firstBlockOffset","floor","current","blockId","has","set","get","add","fetchBlocks","block","cachedBlock","Error","results","Promise","allSettled","Array","from","values","some","result","status","retriedBlockRequests","keys","rejected","reason","name","aborted","filter","map","value","requiredBlocks","readSliceData","size","groups","groupBlocks","groupRequests","groupIndex","group","blockRequest","response","blockOffset","o","t","byteLength","slice","err","delete","clear","sortedBlockIds","sort","a","b","lastBlockId","push","blocks","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","Uint8Array","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView"],"mappings":"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","sourcesContent":["import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new LRUCache({ max: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const cachedBlocks = new Map();\n    const blockRequests = new Map();\n    const missingBlockIds = new Set();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      // chunk the current slice into blocks\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        // check if the block is cached, being requested or still missing\n        const blockId = Math.floor(current / this.blockSize);\n\n        if (this.blockCache.has(blockId)) {\n          cachedBlocks.set(blockId, this.blockCache.get(blockId));\n        } else if (this.blockRequests.has(blockId)) {\n          blockRequests.set(blockId, this.blockRequests.get(blockId));\n        } else if (this.blockIdsToFetch.has(blockId)) {\n          missingBlockIds.add(blockId);\n        } else {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.add(blockId);\n        }\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    for (const blockId of missingBlockIds) {\n      const block = this.blockRequests.get(blockId);\n      const cachedBlock = this.blockCache.get(blockId);\n\n      if (block) {\n        blockRequests.set(blockId, block);\n      } else if (cachedBlock) {\n        cachedBlocks.set(blockId, cachedBlock);\n      } else {\n        throw new Error(`Block ${blockId} is not in the block requests`);\n      }\n    }\n\n    // actually await all pending requests\n    let results = await Promise.allSettled(Array.from(blockRequests.values()));\n\n    // perform retries if a block was interrupted by a previous signal\n    if (results.some((result) => result.status === 'rejected')) {\n      const retriedBlockRequests = new Set();\n      for (const [blockId, result] of zip(blockRequests.keys(), results)) {\n        const { rejected, reason } = result;\n        if (rejected) {\n          // push some blocks back to the to-fetch list if they were\n          // aborted, but only when a different signal was used\n          if (reason.name === 'AbortError' && reason.signal !== signal) {\n            this.blockIdsToFetch.add(blockId);\n            retriedBlockRequests.add(blockId);\n          }\n        }\n      }\n\n      // start the retry of some blocks if required\n      if (this.blockIdsToFetch.length > 0) {\n        this.fetchBlocks(signal);\n        for (const blockId of retriedBlockRequests) {\n          const block = this.blockRequests.get(blockId);\n          if (!block) {\n            throw new Error(`Block ${blockId} is not in the block requests`);\n          }\n          blockRequests.set(blockId, block);\n        }\n        results = await Promise.allSettled(Array.from(blockRequests.values()));\n      }\n    }\n\n    // throw an error (either abort error or AggregateError if no abort was done)\n    if (results.some((result) => result.status === 'rejected')) {\n      if (signal && signal.aborted) {\n        throw new AbortError('Request was aborted');\n      }\n      throw new AggregateError(\n        results.filter((result) => result.status === 'rejected').map((result) => result.reason),\n        'Request failed',\n      );\n    }\n\n    // extract the actual block responses\n    const values = results.map((result) => result.value);\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n    for (const [blockId, block] of cachedBlocks) {\n      requiredBlocks.set(blockId, block);\n    }\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          const blockRequest = (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n              );\n              this.blockCache.set(blockId, block);\n              return block;\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n              }\n              throw err;\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })();\n          this.blockRequests.set(blockId, blockRequest);\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      const top = slice.offset + slice.length;\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}