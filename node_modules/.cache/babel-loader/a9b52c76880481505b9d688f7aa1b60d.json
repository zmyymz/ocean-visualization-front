{"ast":null,"code":"import _asyncToGenerator from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { getDecoder } from './compression/index.js';\nvar defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 2 : 2;\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\n\nvar Pool = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  function Pool() {\n    var _this = this;\n\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultPoolSize;\n    var createWorker = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, Pool);\n\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise(function (resolve) {\n        import('./worker/decoder.js').then(function (module) {\n          resolve(module.create);\n        });\n      });\n\n      this._awaitingDecoder.then(function (create) {\n        _this._awaitingDecoder = null;\n        _this.workers = [];\n\n        for (var i = 0; i < size; i++) {\n          _this.workers.push({\n            worker: create(),\n            idle: true\n          });\n        }\n      });\n    }\n  }\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n\n\n  _createClass(Pool, [{\n    key: \"decode\",\n    value: function () {\n      var _decode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fileDirectory, buffer) {\n        var _this2 = this;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._awaitingDecoder) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return this._awaitingDecoder;\n\n              case 3:\n                return _context.abrupt(\"return\", this.size === 0 ? getDecoder(fileDirectory).then(function (decoder) {\n                  return decoder.decode(fileDirectory, buffer);\n                }) : new Promise(function (resolve) {\n                  var worker = _this2.workers.find(function (candidate) {\n                    return candidate.idle;\n                  }) || _this2.workers[Math.floor(Math.random() * _this2.size)];\n\n                  worker.idle = false;\n                  var id = _this2.messageId++;\n\n                  var onMessage = function onMessage(e) {\n                    if (e.data.id === id) {\n                      worker.idle = true;\n                      resolve(e.data.decoded);\n                      worker.worker.removeEventListener('message', onMessage);\n                    }\n                  };\n\n                  worker.worker.addEventListener('message', onMessage);\n                  worker.worker.postMessage({\n                    fileDirectory: fileDirectory,\n                    buffer: buffer,\n                    id: id\n                  }, [buffer]);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function decode(_x, _x2) {\n        return _decode.apply(this, arguments);\n      }\n\n      return decode;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.workers) {\n        this.workers.forEach(function (worker) {\n          worker.worker.terminate();\n        });\n        this.workers = null;\n      }\n    }\n  }]);\n\n  return Pool;\n}();\n\nexport default Pool;","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/pool.js"],"names":["getDecoder","defaultPoolSize","navigator","hardwareConcurrency","Pool","size","createWorker","workers","_awaitingDecoder","messageId","Promise","resolve","then","module","create","i","push","worker","idle","fileDirectory","buffer","decoder","decode","find","candidate","Math","floor","random","id","onMessage","e","data","decoded","removeEventListener","addEventListener","postMessage","forEach","terminate"],"mappings":"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","sourcesContent":["import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n"]},"metadata":{},"sourceType":"module"}