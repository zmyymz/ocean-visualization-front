{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\n\nfunction decodeRowAcc(row, stride) {\n  var length = row.length - stride;\n  var offset = 0;\n\n  do {\n    for (var i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  var index = 0;\n  var count = row.length;\n  var wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (var i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n\n    count -= stride;\n  }\n\n  var copy = row.slice();\n\n  for (var _i = 0; _i < wc; ++_i) {\n    for (var b = 0; b < bytesPerSample; ++b) {\n      row[bytesPerSample * _i + b] = copy[(bytesPerSample - b - 1) * wc + _i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (var i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  var bytesPerSample = bitsPerSample[0] / 8;\n  var stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (var _i2 = 0; _i2 < height; ++_i2) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (_i2 * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n\n    var row = void 0;\n\n    if (predictor === 2) {\n      // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample);\n          break;\n\n        case 16:\n          row = new Uint16Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);\n          break;\n\n        case 32:\n          row = new Uint32Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);\n          break;\n\n        default:\n          throw new Error(\"Predictor 2 not allowed with \".concat(bitsPerSample[0], \" bits per sample.\"));\n      }\n\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) {\n      // horizontal floating point\n      row = new Uint8Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample);\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n\n  return block;\n}","map":{"version":3,"sources":["D:/MyFile/WebCode/ocean-vis/node_modules/_geotiff@2.0.4@geotiff/dist-module/predictor.js"],"names":["decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","applyPredictor","block","predictor","width","height","bitsPerSample","planarConfiguration","Error","byteLength","Uint8Array","Uint16Array","Uint32Array"],"mappings":"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","sourcesContent":["function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n"]},"metadata":{},"sourceType":"module"}