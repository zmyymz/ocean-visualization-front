{"ast":null,"code":"import _asyncToGenerator from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport BaseDecoder from './basedecoder.js';\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\n\nvar WebImageDecoder = /*#__PURE__*/function (_BaseDecoder) {\n  _inherits(WebImageDecoder, _BaseDecoder);\n\n  var _super = _createSuper(WebImageDecoder);\n\n  function WebImageDecoder() {\n    var _this;\n\n    _classCallCheck(this, WebImageDecoder);\n\n    _this = _super.call(this);\n\n    if (typeof createImageBitmap === 'undefined') {\n      throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n    } else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n      throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n    }\n\n    return _this;\n  }\n\n  _createClass(WebImageDecoder, [{\n    key: \"decode\",\n    value: function () {\n      var _decode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fileDirectory, buffer) {\n        var blob, imageBitmap, canvas, ctx;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                blob = new Blob([buffer]);\n                _context.next = 3;\n                return createImageBitmap(blob);\n\n              case 3:\n                imageBitmap = _context.sent;\n\n                if (typeof document !== 'undefined') {\n                  canvas = document.createElement('canvas');\n                  canvas.width = imageBitmap.width;\n                  canvas.height = imageBitmap.height;\n                } else {\n                  canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n                }\n\n                ctx = canvas.getContext('2d');\n                ctx.drawImage(imageBitmap, 0, 0); // TODO: check how many samples per pixel we have, and return RGB/RGBA accordingly\n                // it seems like GDAL always encodes via RGBA which does not require a translation\n\n                return _context.abrupt(\"return\", ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function decode(_x, _x2) {\n        return _decode.apply(this, arguments);\n      }\n\n      return decode;\n    }()\n  }]);\n\n  return WebImageDecoder;\n}(BaseDecoder);\n\nexport { WebImageDecoder as default };","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/compression/webimage.js"],"names":["BaseDecoder","WebImageDecoder","createImageBitmap","Error","document","OffscreenCanvas","fileDirectory","buffer","blob","Blob","imageBitmap","canvas","createElement","width","height","ctx","getContext","drawImage","getImageData","data"],"mappings":";;;;;;;AAAA,OAAOA,WAAP,MAAwB,kBAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;;IACqBC,e;;;;;AACnB,6BAAc;AAAA;;AAAA;;AACZ;;AACA,QAAI,OAAOC,iBAAP,KAA6B,WAAjC,EAA8C;AAC5C,YAAM,IAAIC,KAAJ,CAAU,gEAAV,CAAN;AACD,KAFD,MAEO,IAAI,OAAOC,QAAP,KAAoB,WAApB,IAAmC,OAAOC,eAAP,KAA2B,WAAlE,EAA+E;AACpF,YAAM,IAAIF,KAAJ,CAAU,qFAAV,CAAN;AACD;;AANW;AAOb;;;;;4EAED,iBAAaG,aAAb,EAA4BC,MAA5B;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,gBAAAA,IADR,GACe,IAAIC,IAAJ,CAAS,CAACF,MAAD,CAAT,CADf;AAAA;AAAA,uBAE4BL,iBAAiB,CAACM,IAAD,CAF7C;;AAAA;AAEQE,gBAAAA,WAFR;;AAKE,oBAAI,OAAON,QAAP,KAAoB,WAAxB,EAAqC;AACnCO,kBAAAA,MAAM,GAAGP,QAAQ,CAACQ,aAAT,CAAuB,QAAvB,CAAT;AACAD,kBAAAA,MAAM,CAACE,KAAP,GAAeH,WAAW,CAACG,KAA3B;AACAF,kBAAAA,MAAM,CAACG,MAAP,GAAgBJ,WAAW,CAACI,MAA5B;AACD,iBAJD,MAIO;AACLH,kBAAAA,MAAM,GAAG,IAAIN,eAAJ,CAAoBK,WAAW,CAACG,KAAhC,EAAuCH,WAAW,CAACI,MAAnD,CAAT;AACD;;AAEKC,gBAAAA,GAbR,GAacJ,MAAM,CAACK,UAAP,CAAkB,IAAlB,CAbd;AAcED,gBAAAA,GAAG,CAACE,SAAJ,CAAcP,WAAd,EAA2B,CAA3B,EAA8B,CAA9B,EAdF,CAgBE;AACA;;AAjBF,iDAmBSK,GAAG,CAACG,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuBR,WAAW,CAACG,KAAnC,EAA0CH,WAAW,CAACI,MAAtD,EAA8DK,IAA9D,CAAmEZ,MAnB5E;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;EAV2CP,W;;SAAxBC,e","sourcesContent":["import BaseDecoder from './basedecoder.js';\n\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\nexport default class WebImageDecoder extends BaseDecoder {\n  constructor() {\n    super();\n    if (typeof createImageBitmap === 'undefined') {\n      throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n    } else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n      throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n    }\n  }\n\n  async decode(fileDirectory, buffer) {\n    const blob = new Blob([buffer]);\n    const imageBitmap = await createImageBitmap(blob);\n\n    let canvas;\n    if (typeof document !== 'undefined') {\n      canvas = document.createElement('canvas');\n      canvas.width = imageBitmap.width;\n      canvas.height = imageBitmap.height;\n    } else {\n      canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n    }\n\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(imageBitmap, 0, 0);\n\n    // TODO: check how many samples per pixel we have, and return RGB/RGBA accordingly\n    // it seems like GDAL always encodes via RGBA which does not require a translation\n\n    return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}