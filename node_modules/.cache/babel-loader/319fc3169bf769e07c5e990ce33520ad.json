{"ast":null,"code":"import _slicedToArray from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _inherits from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.promise.all-settled.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nvar Block = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  function Block(offset, length) {\n    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, Block);\n\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n  /**\n   * @returns {number} the top byte border\n   */\n\n\n  _createClass(Block, [{\n    key: \"top\",\n    get: function get() {\n      return this.offset + this.length;\n    }\n  }]);\n\n  return Block;\n}();\n\nvar BlockGroup = /*#__PURE__*/_createClass(\n/**\n *\n * @param {number} offset\n * @param {number} length\n * @param {number[]} blockIds\n */\nfunction BlockGroup(offset, length, blockIds) {\n  _classCallCheck(this, BlockGroup);\n\n  this.offset = offset;\n  this.length = length;\n  this.blockIds = blockIds;\n});\n\nexport var BlockedSource = /*#__PURE__*/function (_BaseSource) {\n  _inherits(BlockedSource, _BaseSource);\n\n  var _super = _createSuper(BlockedSource);\n\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  function BlockedSource(source) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$blockSize = _ref.blockSize,\n        blockSize = _ref$blockSize === void 0 ? 65536 : _ref$blockSize,\n        _ref$cacheSize = _ref.cacheSize,\n        cacheSize = _ref$cacheSize === void 0 ? 100 : _ref$cacheSize;\n\n    _classCallCheck(this, BlockedSource);\n\n    _this = _super.call(this);\n    _this.source = source;\n    _this.blockSize = blockSize;\n    _this.blockCache = new LRUCache({\n      max: cacheSize\n    }); // mapping blockId -> Block instance\n\n    _this.blockRequests = new Map(); // set of blockIds missing for the current requests\n\n    _this.blockIdsToFetch = new Set();\n    return _this;\n  }\n\n  _createClass(BlockedSource, [{\n    key: \"fileSize\",\n    get: function get() {\n      return this.source.fileSize;\n    }\n    /**\n     *\n     * @param {basesource/Slice[]} slices\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(slices, signal) {\n        var cachedBlocks, blockRequests, missingBlockIds, _iterator, _step, _step$value, offset, length, top, fileSize, firstBlockOffset, current, _blockId2, _iterator2, _step2, _blockId3, _block, cachedBlock, results, retriedBlockRequests, _iterator3, _step3, _step3$value, _blockId, result, rejected, reason, _iterator4, _step4, blockId, block, values, requiredBlocks, _iterator5, _step5, _step5$value, _blockId4, _block2;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                cachedBlocks = new Map();\n                blockRequests = new Map();\n                missingBlockIds = new Set();\n                _iterator = _createForOfIteratorHelper(slices);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _step$value = _step.value, offset = _step$value.offset, length = _step$value.length;\n                    top = offset + length;\n                    fileSize = this.fileSize;\n\n                    if (fileSize !== null) {\n                      top = Math.min(top, fileSize);\n                    }\n\n                    firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize; // chunk the current slice into blocks\n\n                    for (current = firstBlockOffset; current < top; current += this.blockSize) {\n                      // check if the block is cached, being requested or still missing\n                      _blockId2 = Math.floor(current / this.blockSize);\n\n                      if (this.blockCache.has(_blockId2)) {\n                        cachedBlocks.set(_blockId2, this.blockCache.get(_blockId2));\n                      } else if (this.blockRequests.has(_blockId2)) {\n                        blockRequests.set(_blockId2, this.blockRequests.get(_blockId2));\n                      } else if (this.blockIdsToFetch.has(_blockId2)) {\n                        missingBlockIds.add(_blockId2);\n                      } else {\n                        this.blockIdsToFetch.add(_blockId2);\n                        missingBlockIds.add(_blockId2);\n                      }\n                    }\n                  } // allow additional block requests to accumulate\n\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context.next = 7;\n                return wait();\n\n              case 7:\n                this.fetchBlocks(signal);\n                _iterator2 = _createForOfIteratorHelper(missingBlockIds);\n                _context.prev = 9;\n\n                _iterator2.s();\n\n              case 11:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 26;\n                  break;\n                }\n\n                _blockId3 = _step2.value;\n                _block = this.blockRequests.get(_blockId3);\n                cachedBlock = this.blockCache.get(_blockId3);\n\n                if (!_block) {\n                  _context.next = 19;\n                  break;\n                }\n\n                blockRequests.set(_blockId3, _block);\n                _context.next = 24;\n                break;\n\n              case 19:\n                if (!cachedBlock) {\n                  _context.next = 23;\n                  break;\n                }\n\n                cachedBlocks.set(_blockId3, cachedBlock);\n                _context.next = 24;\n                break;\n\n              case 23:\n                throw new Error(\"Block \".concat(_blockId3, \" is not in the block requests\"));\n\n              case 24:\n                _context.next = 11;\n                break;\n\n              case 26:\n                _context.next = 31;\n                break;\n\n              case 28:\n                _context.prev = 28;\n                _context.t0 = _context[\"catch\"](9);\n\n                _iterator2.e(_context.t0);\n\n              case 31:\n                _context.prev = 31;\n\n                _iterator2.f();\n\n                return _context.finish(31);\n\n              case 34:\n                _context.next = 36;\n                return Promise.allSettled(Array.from(blockRequests.values()));\n\n              case 36:\n                results = _context.sent;\n\n                if (!results.some(function (result) {\n                  return result.status === 'rejected';\n                })) {\n                  _context.next = 65;\n                  break;\n                }\n\n                retriedBlockRequests = new Set();\n                _iterator3 = _createForOfIteratorHelper(zip(blockRequests.keys(), results));\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _step3$value = _slicedToArray(_step3.value, 2), _blockId = _step3$value[0], result = _step3$value[1];\n                    rejected = result.rejected, reason = result.reason;\n\n                    if (rejected) {\n                      // push some blocks back to the to-fetch list if they were\n                      // aborted, but only when a different signal was used\n                      if (reason.name === 'AbortError' && reason.signal !== signal) {\n                        this.blockIdsToFetch.add(_blockId);\n                        retriedBlockRequests.add(_blockId);\n                      }\n                    }\n                  } // start the retry of some blocks if required\n\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                if (!(this.blockIdsToFetch.length > 0)) {\n                  _context.next = 65;\n                  break;\n                }\n\n                this.fetchBlocks(signal);\n                _iterator4 = _createForOfIteratorHelper(retriedBlockRequests);\n                _context.prev = 44;\n\n                _iterator4.s();\n\n              case 46:\n                if ((_step4 = _iterator4.n()).done) {\n                  _context.next = 54;\n                  break;\n                }\n\n                blockId = _step4.value;\n                block = this.blockRequests.get(blockId);\n\n                if (block) {\n                  _context.next = 51;\n                  break;\n                }\n\n                throw new Error(\"Block \".concat(blockId, \" is not in the block requests\"));\n\n              case 51:\n                blockRequests.set(blockId, block);\n\n              case 52:\n                _context.next = 46;\n                break;\n\n              case 54:\n                _context.next = 59;\n                break;\n\n              case 56:\n                _context.prev = 56;\n                _context.t1 = _context[\"catch\"](44);\n\n                _iterator4.e(_context.t1);\n\n              case 59:\n                _context.prev = 59;\n\n                _iterator4.f();\n\n                return _context.finish(59);\n\n              case 62:\n                _context.next = 64;\n                return Promise.allSettled(Array.from(blockRequests.values()));\n\n              case 64:\n                results = _context.sent;\n\n              case 65:\n                if (!results.some(function (result) {\n                  return result.status === 'rejected';\n                })) {\n                  _context.next = 69;\n                  break;\n                }\n\n                if (!(signal && signal.aborted)) {\n                  _context.next = 68;\n                  break;\n                }\n\n                throw new AbortError('Request was aborted');\n\n              case 68:\n                throw new AggregateError(results.filter(function (result) {\n                  return result.status === 'rejected';\n                }).map(function (result) {\n                  return result.reason;\n                }), 'Request failed');\n\n              case 69:\n                // extract the actual block responses\n                values = results.map(function (result) {\n                  return result.value;\n                }); // create a final Map, with all required blocks for this request to satisfy\n\n                requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n                _iterator5 = _createForOfIteratorHelper(cachedBlocks);\n\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    _step5$value = _slicedToArray(_step5.value, 2), _blockId4 = _step5$value[0], _block2 = _step5$value[1];\n                    requiredBlocks.set(_blockId4, _block2);\n                  } // TODO: satisfy each slice\n\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n\n                return _context.abrupt(\"return\", this.readSliceData(slices, requiredBlocks));\n\n              case 74:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[9, 28, 31, 34], [44, 56, 59, 62]]);\n      }));\n\n      function fetch(_x, _x2) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n    /**\n     *\n     * @param {AbortSignal} signal\n     */\n\n  }, {\n    key: \"fetchBlocks\",\n    value: function fetchBlocks(signal) {\n      var _this2 = this;\n\n      // check if we still need to\n      if (this.blockIdsToFetch.size > 0) {\n        (function () {\n          var groups = _this2.groupBlocks(_this2.blockIdsToFetch); // start requesting slices of data\n\n\n          var groupRequests = _this2.source.fetch(groups, signal);\n\n          var _loop = function _loop(groupIndex) {\n            var group = groups[groupIndex];\n\n            var _iterator6 = _createForOfIteratorHelper(group.blockIds),\n                _step6;\n\n            try {\n              var _loop2 = function _loop2() {\n                var blockId = _step6.value;\n\n                // make an async IIFE for each block\n                var blockRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n                  var response, blockOffset, o, t, data, block;\n                  return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.prev = 0;\n                          _context2.next = 3;\n                          return groupRequests;\n\n                        case 3:\n                          _context2.t0 = groupIndex;\n                          response = _context2.sent[_context2.t0];\n                          blockOffset = blockId * _this2.blockSize;\n                          o = blockOffset - response.offset;\n                          t = Math.min(o + _this2.blockSize, response.data.byteLength);\n                          data = response.data.slice(o, t);\n                          block = new Block(blockOffset, data.byteLength, data);\n\n                          _this2.blockCache.set(blockId, block);\n\n                          return _context2.abrupt(\"return\", block);\n\n                        case 14:\n                          _context2.prev = 14;\n                          _context2.t1 = _context2[\"catch\"](0);\n\n                          if (_context2.t1.name === 'AbortError') {\n                            // store the signal here, we need it to determine later if an\n                            // error was caused by this signal\n                            _context2.t1.signal = signal;\n                          }\n\n                          throw _context2.t1;\n\n                        case 18:\n                          _context2.prev = 18;\n\n                          _this2.blockRequests.delete(blockId);\n\n                          return _context2.finish(18);\n\n                        case 21:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, null, [[0, 14, 18, 21]]);\n                }))();\n\n                _this2.blockRequests.set(blockId, blockRequest);\n              };\n\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          };\n\n          for (var groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n            _loop(groupIndex);\n          }\n\n          _this2.blockIdsToFetch.clear();\n        })();\n      }\n    }\n    /**\n     *\n     * @param {Set} blockIds\n     * @returns {BlockGroup[]}\n     */\n\n  }, {\n    key: \"groupBlocks\",\n    value: function groupBlocks(blockIds) {\n      var sortedBlockIds = Array.from(blockIds).sort(function (a, b) {\n        return a - b;\n      });\n\n      if (sortedBlockIds.length === 0) {\n        return [];\n      }\n\n      var current = [];\n      var lastBlockId = null;\n      var groups = [];\n\n      var _iterator7 = _createForOfIteratorHelper(sortedBlockIds),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var blockId = _step7.value;\n\n          if (lastBlockId === null || lastBlockId + 1 === blockId) {\n            current.push(blockId);\n            lastBlockId = blockId;\n          } else {\n            groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n            current = [blockId];\n            lastBlockId = blockId;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n      return groups;\n    }\n    /**\n     *\n     * @param {Slice[]} slices\n     * @param {Map} blocks\n     */\n\n  }, {\n    key: \"readSliceData\",\n    value: function readSliceData(slices, blocks) {\n      var _this3 = this;\n\n      return slices.map(function (slice) {\n        var top = slice.offset + slice.length;\n        var blockIdLow = Math.floor(slice.offset / _this3.blockSize);\n        var blockIdHigh = Math.floor((slice.offset + slice.length) / _this3.blockSize);\n        var sliceData = new ArrayBuffer(slice.length);\n        var sliceView = new Uint8Array(sliceData);\n\n        for (var blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n          var block = blocks.get(blockId);\n          var delta = block.offset - slice.offset;\n          var topDelta = block.top - top;\n          var blockInnerOffset = 0;\n          var rangeInnerOffset = 0;\n          var usedBlockLength = void 0;\n\n          if (delta < 0) {\n            blockInnerOffset = -delta;\n          } else if (delta > 0) {\n            rangeInnerOffset = delta;\n          }\n\n          if (topDelta < 0) {\n            usedBlockLength = block.length - blockInnerOffset;\n          } else {\n            usedBlockLength = top - block.offset - blockInnerOffset;\n          }\n\n          var blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n          sliceView.set(blockView, rangeInnerOffset);\n        }\n\n        return sliceData;\n      });\n    }\n  }]);\n\n  return BlockedSource;\n}(BaseSource);","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/source/blockedsource.js"],"names":["LRUCache","BaseSource","AbortError","AggregateError","wait","zip","Block","offset","length","data","BlockGroup","blockIds","BlockedSource","source","blockSize","cacheSize","blockCache","max","blockRequests","Map","blockIdsToFetch","Set","fileSize","slices","signal","cachedBlocks","missingBlockIds","top","Math","min","firstBlockOffset","floor","current","blockId","has","set","get","add","fetchBlocks","block","cachedBlock","Error","Promise","allSettled","Array","from","values","results","some","result","status","retriedBlockRequests","keys","rejected","reason","name","aborted","filter","map","value","requiredBlocks","readSliceData","size","groups","groupBlocks","groupRequests","fetch","groupIndex","group","blockRequest","response","blockOffset","o","t","byteLength","slice","delete","clear","sortedBlockIds","sort","a","b","lastBlockId","push","blocks","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","Uint8Array","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView"],"mappings":"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","sourcesContent":["import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new LRUCache({ max: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const cachedBlocks = new Map();\n    const blockRequests = new Map();\n    const missingBlockIds = new Set();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      // chunk the current slice into blocks\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        // check if the block is cached, being requested or still missing\n        const blockId = Math.floor(current / this.blockSize);\n\n        if (this.blockCache.has(blockId)) {\n          cachedBlocks.set(blockId, this.blockCache.get(blockId));\n        } else if (this.blockRequests.has(blockId)) {\n          blockRequests.set(blockId, this.blockRequests.get(blockId));\n        } else if (this.blockIdsToFetch.has(blockId)) {\n          missingBlockIds.add(blockId);\n        } else {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.add(blockId);\n        }\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    for (const blockId of missingBlockIds) {\n      const block = this.blockRequests.get(blockId);\n      const cachedBlock = this.blockCache.get(blockId);\n\n      if (block) {\n        blockRequests.set(blockId, block);\n      } else if (cachedBlock) {\n        cachedBlocks.set(blockId, cachedBlock);\n      } else {\n        throw new Error(`Block ${blockId} is not in the block requests`);\n      }\n    }\n\n    // actually await all pending requests\n    let results = await Promise.allSettled(Array.from(blockRequests.values()));\n\n    // perform retries if a block was interrupted by a previous signal\n    if (results.some((result) => result.status === 'rejected')) {\n      const retriedBlockRequests = new Set();\n      for (const [blockId, result] of zip(blockRequests.keys(), results)) {\n        const { rejected, reason } = result;\n        if (rejected) {\n          // push some blocks back to the to-fetch list if they were\n          // aborted, but only when a different signal was used\n          if (reason.name === 'AbortError' && reason.signal !== signal) {\n            this.blockIdsToFetch.add(blockId);\n            retriedBlockRequests.add(blockId);\n          }\n        }\n      }\n\n      // start the retry of some blocks if required\n      if (this.blockIdsToFetch.length > 0) {\n        this.fetchBlocks(signal);\n        for (const blockId of retriedBlockRequests) {\n          const block = this.blockRequests.get(blockId);\n          if (!block) {\n            throw new Error(`Block ${blockId} is not in the block requests`);\n          }\n          blockRequests.set(blockId, block);\n        }\n        results = await Promise.allSettled(Array.from(blockRequests.values()));\n      }\n    }\n\n    // throw an error (either abort error or AggregateError if no abort was done)\n    if (results.some((result) => result.status === 'rejected')) {\n      if (signal && signal.aborted) {\n        throw new AbortError('Request was aborted');\n      }\n      throw new AggregateError(\n        results.filter((result) => result.status === 'rejected').map((result) => result.reason),\n        'Request failed',\n      );\n    }\n\n    // extract the actual block responses\n    const values = results.map((result) => result.value);\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n    for (const [blockId, block] of cachedBlocks) {\n      requiredBlocks.set(blockId, block);\n    }\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          const blockRequest = (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n              );\n              this.blockCache.set(blockId, block);\n              return block;\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n              }\n              throw err;\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })();\n          this.blockRequests.set(blockId, blockRequest);\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      const top = slice.offset + slice.length;\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}