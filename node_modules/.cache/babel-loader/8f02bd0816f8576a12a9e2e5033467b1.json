{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.float64-array.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\n\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\nvar tagName2Code = invert(fieldTagNames);\nvar geoKeyName2Code = invert(geoKeyNames);\nvar name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nvar typeName2byte = invert(fieldTypeNames); // config variables\n\nvar numBytesInIfd = 1000;\nvar _binBE = {\n  nextZero: function nextZero(data, o) {\n    var oincr = o;\n\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n\n    return oincr;\n  },\n  readUshort: function readUshort(buff, p) {\n    return buff[p] << 8 | buff[p + 1];\n  },\n  readShort: function readShort(buff, p) {\n    var a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: function readInt(buff, p) {\n    var a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: function readUint(buff, p) {\n    var a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: function readASCII(buff, p, l) {\n    return l.map(function (i) {\n      return String.fromCharCode(buff[p + i]);\n    }).join('');\n  },\n  readFloat: function readFloat(buff, p) {\n    var a = _binBE.ui8;\n    times(4, function (i) {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: function readDouble(buff, p) {\n    var a = _binBE.ui8;\n    times(8, function (i) {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: function writeUshort(buff, p, n) {\n    buff[p] = n >> 8 & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: function writeUint(buff, p, n) {\n    buff[p] = n >> 24 & 255;\n    buff[p + 1] = n >> 16 & 255;\n    buff[p + 2] = n >> 8 & 255;\n    buff[p + 3] = n >> 0 & 255;\n  },\n  writeASCII: function writeASCII(buff, p, s) {\n    times(s.length, function (i) {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8)\n};\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = function (buff, p, n) {\n  _binBE.fl64[0] = n;\n  times(8, function (i) {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nvar _writeIFD = function _writeIFD(bin, data, _offset, ifd) {\n  var offset = _offset;\n  var keys = Object.keys(ifd).filter(function (key) {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n  var eoff = offset + 12 * keys.length + 4;\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var key = _step.value;\n      var tag = null;\n\n      if (typeof key === 'number') {\n        tag = key;\n      } else if (typeof key === 'string') {\n        tag = parseInt(key, 10);\n      }\n\n      var typeName = fieldTagTypes[tag];\n      var typeNum = typeName2byte[typeName];\n\n      if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n        throw new Error(\"unknown type of tag: \".concat(tag));\n      }\n\n      var val = ifd[key];\n\n      if (val === undefined) {\n        throw new Error(\"failed to get value for key \".concat(key));\n      } // ASCIIZ format with trailing 0 character\n      // http://www.fileformat.info/format/tiff/corion.htm\n      // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n\n\n      if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, \"\\0\") === false) {\n        val += \"\\0\";\n      }\n\n      var num = val.length;\n      bin.writeUshort(data, offset, tag);\n      offset += 2;\n      bin.writeUshort(data, offset, typeNum);\n      offset += 2;\n      bin.writeUint(data, offset, num);\n      offset += 4;\n      var dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n      var toff = offset;\n\n      if (dlen > 4) {\n        bin.writeUint(data, offset, eoff);\n        toff = eoff;\n      }\n\n      if (typeName === 'ASCII') {\n        bin.writeASCII(data, toff, val);\n      } else if (typeName === 'SHORT') {\n        times(num, function (i) {\n          bin.writeUshort(data, toff + 2 * i, val[i]);\n        });\n      } else if (typeName === 'LONG') {\n        times(num, function (i) {\n          bin.writeUint(data, toff + 4 * i, val[i]);\n        });\n      } else if (typeName === 'RATIONAL') {\n        times(num, function (i) {\n          bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 10000));\n          bin.writeUint(data, toff + 8 * i + 4, 10000);\n        });\n      } else if (typeName === 'DOUBLE') {\n        times(num, function (i) {\n          bin.writeDouble(data, toff + 8 * i, val[i]);\n        });\n      }\n\n      if (dlen > 4) {\n        dlen += dlen & 1;\n        eoff += dlen;\n      }\n\n      offset += 4;\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return [offset, eoff];\n};\n\nvar encodeIfds = function encodeIfds(ifds) {\n  var data = new Uint8Array(numBytesInIfd);\n  var offset = 4;\n  var bin = _binBE; // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n\n  data[0] = 77;\n  data[1] = 77; // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n\n  data[3] = 42;\n  var ifdo = 8;\n  bin.writeUint(data, offset, ifdo);\n  offset += 4;\n  ifds.forEach(function (ifd, i) {\n    var noffs = _writeIFD(bin, data, ifdo, ifd);\n\n    ifdo = noffs[1];\n\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  } // node hasn't implemented slice on Uint8Array yet\n\n\n  var result = new Uint8Array(ifdo);\n\n  for (var i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n\n  return result.buffer;\n};\n\nvar encodeImage = function encodeImage(values, width, height, metadata) {\n  if (height === undefined || height === null) {\n    throw new Error(\"you passed into encodeImage a width of type \".concat(height));\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(\"you passed into encodeImage a width of type \".concat(width));\n  }\n\n  var ifd = {\n    256: [width],\n    // ImageWidth\n    257: [height],\n    // ImageLength\n    273: [numBytesInIfd],\n    // strips offset\n    278: [height],\n    // RowsPerStrip\n    305: 'geotiff.js' // no array for ASCII(Z)\n\n  };\n\n  if (metadata) {\n    for (var i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  var prfx = new Uint8Array(encodeIfds([ifd]));\n  var img = new Uint8Array(values);\n  var samplesPerPixel = ifd[277];\n  var data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);\n  times(prfx.length, function (i) {\n    data[i] = prfx[i];\n  });\n  forEach(img, function (value, i) {\n    data[numBytesInIfd + i] = value;\n  });\n  return data.buffer;\n};\n\nvar convertToTids = function convertToTids(input) {\n  var result = {};\n\n  for (var key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n\n      result[name2code[key]] = input[key];\n    }\n  }\n\n  return result;\n};\n\nvar toArray = function toArray(input) {\n  if (Array.isArray(input)) {\n    return input;\n  }\n\n  return [input];\n};\n\nvar metadataDefaults = [['Compression', 1], // no compression\n['PlanarConfiguration', 1], ['ExtraSamples', 0]];\nexport function writeGeotiff(data, metadata) {\n  var isFlattened = typeof data[0] === 'number';\n  var height;\n  var numBands;\n  var width;\n  var flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, function (rowIndex) {\n      times(width, function (columnIndex) {\n        times(numBands, function (bandIndex) {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width; // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, function () {\n      return 8;\n    });\n  }\n\n  metadataDefaults.forEach(function (tag) {\n    var key = tag[0];\n\n    if (!metadata[key]) {\n      var value = tag[1];\n      metadata[key] = value;\n    }\n  }); // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  } // The number of components per pixel.\n\n\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, function () {\n      return 1;\n    });\n  } // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n\n\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  var geoKeys = Object.keys(metadata).filter(function (key) {\n    return endsWith(key, 'GeoKey');\n  }).sort(function (a, b) {\n    return name2code[a] - name2code[b];\n  });\n\n  if (!metadata.GeoAsciiParams) {\n    var geoAsciiParams = '';\n    geoKeys.forEach(function (name) {\n      var code = Number(name2code[name]);\n      var tagType = fieldTagTypes[code];\n\n      if (tagType === 'ASCII') {\n        geoAsciiParams += \"\".concat(metadata[name].toString(), \"\\0\");\n      }\n    });\n\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    var NumberOfKeys = geoKeys.length;\n    var GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach(function (geoKey) {\n      var KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n      var Count;\n      var TIFFTagLocation;\n      var valueOffset;\n\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(\"[geotiff.js] couldn't get TIFFTagLocation for \".concat(geoKey));\n      }\n\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  } // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n\n\n  for (var geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  ['Compression', 'ExtraSamples', 'GeographicTypeGeoKey', 'GTModelTypeGeoKey', 'GTRasterTypeGeoKey', 'ImageLength', // synonym of ImageHeight\n  'ImageWidth', 'Orientation', 'PhotometricInterpretation', 'ProjectedCSTypeGeoKey', 'PlanarConfiguration', 'ResolutionUnit', 'SamplesPerPixel', 'XPosition', 'YPosition'].forEach(function (name) {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n  var encodedMetadata = convertToTids(metadata);\n  var outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n  return outputImage;\n}","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/geotiffwriter.js"],"names":["fieldTagNames","fieldTagTypes","fieldTypeNames","geoKeyNames","assign","endsWith","forEach","invert","times","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","nextZero","data","o","oincr","readUshort","buff","p","readShort","a","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","map","i","String","fromCharCode","join","readFloat","fl32","readDouble","fl64","writeUshort","n","writeUint","writeASCII","s","length","charCodeAt","Uint8Array","Float64Array","buffer","writeDouble","_writeIFD","bin","_offset","ifd","offset","keys","Object","filter","key","undefined","eoff","tag","parseInt","typeName","typeNum","Error","val","num","dlen","toff","Math","round","encodeIfds","ifds","ifdo","noffs","slice","result","encodeImage","values","width","height","metadata","hasOwnProperty","prfx","img","samplesPerPixel","value","convertToTids","input","console","error","toArray","Array","isArray","metadataDefaults","writeGeotiff","isFlattened","numBands","flattenedValues","ImageLength","ImageWidth","rowIndex","columnIndex","bandIndex","push","BitsPerSample","PhotometricInterpretation","SamplesPerPixel","StripByteCounts","ModelPixelScale","SampleFormat","GeographicTypeGeoKey","ModelTiepoint","GeogCitationGeoKey","GTModelTypeGeoKey","geoKeys","sort","b","GeoAsciiParams","geoAsciiParams","name","code","Number","tagType","toString","GeoKeyDirectory","NumberOfKeys","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","log","encodedMetadata","outputImage"],"mappings":"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","sourcesContent":["/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n"]},"metadata":{},"sourceType":"module"}