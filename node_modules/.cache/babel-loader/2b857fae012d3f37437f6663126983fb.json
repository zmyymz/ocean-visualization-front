{"ast":null,"code":"import _objectSpread from \"D:/ocean-vis/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"D:/ocean-vis/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/ocean-vis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/ocean-vis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/ocean-vis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/ocean-vis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nvar HttpResponse = /*#__PURE__*/function (_BaseResponse) {\n  _inherits(HttpResponse, _BaseResponse);\n\n  var _super = _createSuper(HttpResponse);\n\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  function HttpResponse(response, dataPromise) {\n    var _this;\n\n    _classCallCheck(this, HttpResponse);\n\n    _this = _super.call(this);\n    _this.response = response;\n    _this.dataPromise = dataPromise;\n    return _this;\n  }\n\n  _createClass(HttpResponse, [{\n    key: \"status\",\n    get: function get() {\n      return this.response.statusCode;\n    }\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(name) {\n      return this.response.headers[name];\n    }\n  }, {\n    key: \"getData\",\n    value: function () {\n      var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var data;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.dataPromise;\n\n              case 2:\n                data = _context.sent;\n                return _context.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getData() {\n        return _getData.apply(this, arguments);\n      }\n\n      return getData;\n    }()\n  }]);\n\n  return HttpResponse;\n}(BaseResponse);\n\nexport var HttpClient = /*#__PURE__*/function (_BaseClient) {\n  _inherits(HttpClient, _BaseClient);\n\n  var _super2 = _createSuper(HttpClient);\n\n  function HttpClient(url) {\n    var _this2;\n\n    _classCallCheck(this, HttpClient);\n\n    _this2 = _super2.call(this, url);\n    _this2.parsedUrl = urlMod.parse(_this2.url);\n    _this2.httpApi = _this2.parsedUrl.protocol === 'http:' ? http : https;\n    return _this2;\n  }\n\n  _createClass(HttpClient, [{\n    key: \"constructRequest\",\n    value: function constructRequest(headers, signal) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        var request = _this3.httpApi.get(_objectSpread(_objectSpread({}, _this3.parsedUrl), {}, {\n          headers: headers\n        }), function (response) {\n          var dataPromise = new Promise(function (resolveData) {\n            var chunks = []; // collect chunks\n\n            response.on('data', function (chunk) {\n              chunks.push(chunk);\n            }); // concatenate all chunks and resolve the promise with the resulting buffer\n\n            response.on('end', function () {\n              var data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        });\n\n        request.on('error', reject);\n\n        if (signal) {\n          if (signal.aborted) {\n            request.destroy(new AbortError('Request aborted'));\n          }\n\n          signal.addEventListener('abort', function () {\n            return request.destroy(new AbortError('Request aborted'));\n          });\n        }\n      });\n    }\n  }, {\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var _ref,\n            headers,\n            signal,\n            response,\n            _args2 = arguments;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, signal = _ref.signal;\n                _context2.next = 3;\n                return this.constructRequest(headers, signal);\n\n              case 3:\n                response = _context2.sent;\n                return _context2.abrupt(\"return\", response);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function request() {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n  }]);\n\n  return HttpClient;\n}(BaseClient);","map":{"version":3,"sources":["D:/ocean-vis/node_modules/geotiff/dist-module/source/client/http.js"],"names":["http","https","urlMod","BaseClient","BaseResponse","AbortError","HttpResponse","response","dataPromise","statusCode","name","headers","data","HttpClient","url","parsedUrl","parse","httpApi","protocol","signal","Promise","resolve","reject","request","get","resolveData","chunks","on","chunk","push","Buffer","concat","buffer","aborted","destroy","addEventListener","constructRequest"],"mappings":"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","sourcesContent":["import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}