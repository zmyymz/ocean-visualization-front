{"ast":null,"code":"/**\n * @module ol/xml\n */\nimport { extend } from './array.js';\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\n\nexport var XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\n\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\n\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\n\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    var n = void 0;\n\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n\n  return accumulator;\n}\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\n\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\n\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\n\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeArrayExtender(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        var array =\n        /** @type {Array<*>} */\n        objectStack[objectStack.length - 1];\n        extend(array, value);\n      }\n    }\n  );\n}\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeArrayPusher(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        var array =\n        /** @type {Array<*>} */\n        objectStack[objectStack.length - 1];\n        array.push(value);\n      }\n    }\n  );\n}\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeReplacer(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        var object =\n        /** @type {!Object} */\n        objectStack[objectStack.length - 1];\n        var property = opt_property !== undefined ? opt_property : node.localName;\n        var array = void 0;\n\n        if (property in object) {\n          array = object[property];\n        } else {\n          array = [];\n          object[property] = array;\n        }\n\n        array.push(value);\n      }\n    }\n  );\n}\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        var object =\n        /** @type {!Object} */\n        objectStack[objectStack.length - 1];\n        var property = opt_property !== undefined ? opt_property : node.localName;\n        object[property] = value;\n      }\n    }\n  );\n}\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\n\nexport function makeChildAppender(nodeWriter, opt_this) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);\n    var parent =\n    /** @type {NodeStackItem} */\n    objectStack[objectStack.length - 1];\n    var parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\n\nexport function makeArraySerializer(nodeWriter, opt_this) {\n  var serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      var serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n/**\n * Create a node factory which can use the `opt_keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [opt_nodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [opt_namespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\n\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n  var fixedNodeName = opt_nodeName;\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [opt_nodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, opt_nodeName) {\n      var context =\n      /** @type {NodeStackItem} */\n      objectStack[objectStack.length - 1];\n      var node = context.node;\n      var nodeName = fixedNodeName;\n\n      if (nodeName === undefined) {\n        nodeName = opt_nodeName;\n      }\n\n      var namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI,\n      /** @type {string} */\n      nodeName);\n    }\n  );\n}\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\n\nexport var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `opt_key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\n\nexport function makeSequence(object, orderedKeys) {\n  var length = orderedKeys.length;\n  var sequence = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n\n  return sequence;\n}\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [opt_structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\n\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n  /**\n   * @type {Object<string, T>}\n   */\n  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n  var i, ii;\n\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n\n  return structureNS;\n}\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n */\n\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\n  var n;\n\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    var parsers = parsersNS[n.namespaceURI];\n\n    if (parsers !== undefined) {\n      var parser = parsers[n.localName];\n\n      if (parser !== undefined) {\n        parser.call(opt_this, n, objectStack);\n      }\n    }\n  }\n}\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\n\nexport function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, opt_this);\n  return (\n    /** @type {T} */\n    objectStack.pop()\n  );\n}\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\n\nexport function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  var length = (opt_keys !== undefined ? opt_keys : values).length;\n  var value, node;\n\n  for (var i = 0; i < length; ++i) {\n    value = values[i];\n\n    if (value !== undefined) {\n      node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);\n\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);\n      }\n    }\n  }\n}\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\n\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\n  return (\n    /** @type {O|undefined} */\n    objectStack.pop()\n  );\n}\nvar xmlSerializer_ = undefined;\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\n\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\n\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n\n  return xmlSerializer_;\n}\nvar document_ = undefined;\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\n\nexport function registerDocument(document) {\n  document_ = document;\n}\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\n\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n\n  return document_;\n}","map":{"version":3,"mappings":"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","names":["extend","XML_SCHEMA_INSTANCE_URI","createElementNS","namespaceURI","qualifiedName","getDocument","getAllTextContent","node","normalizeWhitespace","getAllTextContent_","join","accumulator","nodeType","Node","CDATA_SECTION_NODE","TEXT_NODE","push","String","nodeValue","replace","n","firstChild","nextSibling","isDocument","object","getAttributeNS","name","parse","xml","DOMParser","parseFromString","makeArrayExtender","valueReader","opt_this","objectStack","value","call","undefined","array","length","makeArrayPusher","makeReplacer","makeObjectPropertyPusher","opt_property","property","localName","makeObjectPropertySetter","makeChildAppender","nodeWriter","parent","parentNode","appendChild","makeArraySerializer","serializersNS","nodeFactory","serializers","makeSimpleNodeFactory","serialize","opt_nodeName","opt_namespaceURI","fixedNodeName","context","nodeName","OBJECT_PROPERTY_NODE_FACTORY","makeSequence","orderedKeys","sequence","Array","i","makeStructureNS","namespaceURIs","structure","opt_structureNS","structureNS","ii","parseNode","parsersNS","firstElementChild","nextElementSibling","parsers","parser","pushParseAndPop","pop","values","opt_keys","pushSerializeAndPop","xmlSerializer_","registerXMLSerializer","xmlSerializer","getXMLSerializer","XMLSerializer","document_","registerDocument","document","implementation","createDocument"],"sourceRoot":"","sources":["src/xml.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}