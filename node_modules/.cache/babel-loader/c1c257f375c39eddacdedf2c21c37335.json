{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/Layer\n */\n\n\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport SourceState from '../source/State.js';\nimport { abstract } from '../util.js';\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\n\nvar LayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(LayerRenderer, _super);\n  /**\n   * @param {LayerType} layer Layer.\n   */\n\n\n  function LayerRenderer(layer) {\n    var _this = _super.call(this) || this;\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n\n\n    _this.ready = true;\n    /** @private */\n\n    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n\n    _this.layer_ = layer;\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n\n    _this.declutterExecutorGroup = null;\n    return _this;\n  }\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n\n\n  LayerRenderer.prototype.getFeatures = function (pixel) {\n    return abstract();\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n\n\n  LayerRenderer.prototype.getData = function (pixel) {\n    return null;\n  };\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  LayerRenderer.prototype.prepareFrame = function (frameState) {\n    return abstract();\n  };\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  LayerRenderer.prototype.renderFrame = function (frameState, target) {\n    return abstract();\n  };\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n\n\n  LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  };\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       * @this {LayerRenderer}\n       */\n      function (zoom, tileRange) {\n        var callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  };\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n    return undefined;\n  };\n  /**\n   * @abstract\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n   *    location, null will be returned.  If there is data, but pixel values cannot be\n   *    returned, and empty array will be returned.\n   */\n\n\n  LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n    return null;\n  };\n  /**\n   * @return {LayerType} Layer.\n   */\n\n\n  LayerRenderer.prototype.getLayer = function () {\n    return this.layer_;\n  };\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n\n\n  LayerRenderer.prototype.handleFontsChanged = function () {};\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n\n\n  LayerRenderer.prototype.handleImageChange_ = function (event) {\n    var image =\n    /** @type {import(\"../Image.js\").default} */\n    event.target;\n\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.loadImage = function (image) {\n    var imageState = image.getState();\n\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n\n    return imageState == ImageState.LOADED;\n  };\n  /**\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.renderIfReadyAndVisible = function () {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      layer.changed();\n    }\n  };\n  /**\n   * Clean up.\n   */\n\n\n  LayerRenderer.prototype.disposeInternal = function () {\n    delete this.layer_;\n\n    _super.prototype.disposeInternal.call(this);\n  };\n\n  return LayerRenderer;\n}(Observable);\n\nexport default LayerRenderer;","map":{"version":3,"mappings":"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","names":["EventType","ImageState","Observable","SourceState","abstract","__extends","layer","_super","_this","ready","boundHandleImageChange_","handleImageChange_","bind","layer_","declutterExecutorGroup","LayerRenderer","pixel","frameState","target","tiles","zoom","tile","tileCoord","toString","undefined","source","projection","tileRange","callback","loadedTileCallback","forEachLoadedTile","coordinate","hitTolerance","matches","event","image","getState","LOADED","renderIfReadyAndVisible","imageState","ERROR","addEventListener","CHANGE","IDLE","load","getLayer","getVisible","getSourceState","READY","changed","disposeInternal","call"],"sourceRoot":"","sources":["../src/renderer/Layer.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}