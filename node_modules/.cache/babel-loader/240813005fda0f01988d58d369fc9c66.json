{"ast":null,"code":"import _objectSpread from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _inherits from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _createClass from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.int8-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.int16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.float64-array.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\n/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\nimport { makeRemoteSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\nexport { globals };\nexport { rgb };\nexport { getDecoder, addDecoder };\nexport { setLogger };\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.SBYTE:\n    case fieldTypes.UNDEFINED:\n      return 1;\n\n    case fieldTypes.SHORT:\n    case fieldTypes.SSHORT:\n      return 2;\n\n    case fieldTypes.LONG:\n    case fieldTypes.SLONG:\n    case fieldTypes.FLOAT:\n    case fieldTypes.IFD:\n      return 4;\n\n    case fieldTypes.RATIONAL:\n    case fieldTypes.SRATIONAL:\n    case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8:\n    case fieldTypes.SLONG8:\n    case fieldTypes.IFD8:\n      return 8;\n\n    default:\n      throw new RangeError(\"Invalid field type: \".concat(fieldType));\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  var rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  var geoKeyDirectory = {};\n\n  for (var i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    var key = geoKeyNames[rawGeoKeyDirectory[i]];\n    var location = rawGeoKeyDirectory[i + 1] ? fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;\n    var count = rawGeoKeyDirectory[i + 2];\n    var offset = rawGeoKeyDirectory[i + 3];\n    var value = null;\n\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(\"Could not get value of geoKey '\".concat(key, \"'.\"));\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n\n    geoKeyDirectory[key] = value;\n  }\n\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  var values = null;\n  var readMethod = null;\n  var fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count);\n      readMethod = dataSlice.readUint8;\n      break;\n\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count);\n      readMethod = dataSlice.readInt8;\n      break;\n\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count);\n      readMethod = dataSlice.readUint16;\n      break;\n\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count);\n      readMethod = dataSlice.readInt16;\n      break;\n\n    case fieldTypes.LONG:\n    case fieldTypes.IFD:\n      values = new Uint32Array(count);\n      readMethod = dataSlice.readUint32;\n      break;\n\n    case fieldTypes.SLONG:\n      values = new Int32Array(count);\n      readMethod = dataSlice.readInt32;\n      break;\n\n    case fieldTypes.LONG8:\n    case fieldTypes.IFD8:\n      values = new Array(count);\n      readMethod = dataSlice.readUint64;\n      break;\n\n    case fieldTypes.SLONG8:\n      values = new Array(count);\n      readMethod = dataSlice.readInt64;\n      break;\n\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2);\n      readMethod = dataSlice.readUint32;\n      break;\n\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2);\n      readMethod = dataSlice.readInt32;\n      break;\n\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count);\n      readMethod = dataSlice.readFloat32;\n      break;\n\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count);\n      readMethod = dataSlice.readFloat64;\n      break;\n\n    default:\n      throw new RangeError(\"Invalid field type: \".concat(fieldType));\n  } // normal fields\n\n\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (var i = 0; i < count; ++i) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n    }\n  } else {\n    // RATIONAL or SRATIONAL\n    for (var _i = 0; _i < count; _i += 2) {\n      values[_i] = readMethod.call(dataSlice, offset + _i * fieldTypeLength);\n      values[_i + 1] = readMethod.call(dataSlice, offset + (_i * fieldTypeLength + 4));\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n\n  return values;\n}\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\n\n\nvar ImageFileDirectory = /*#__PURE__*/_createClass(function ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n  _classCallCheck(this, ImageFileDirectory);\n\n  this.fileDirectory = fileDirectory;\n  this.geoKeyDirectory = geoKeyDirectory;\n  this.nextIFDByteOffset = nextIFDByteOffset;\n});\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\n\n\nvar GeoTIFFImageIndexError = /*#__PURE__*/function (_Error) {\n  _inherits(GeoTIFFImageIndexError, _Error);\n\n  var _super = _createSuper(GeoTIFFImageIndexError);\n\n  function GeoTIFFImageIndexError(index) {\n    var _this;\n\n    _classCallCheck(this, GeoTIFFImageIndexError);\n\n    _this = _super.call(this, \"No image at index \".concat(index));\n    _this.index = index;\n    return _this;\n  }\n\n  return _createClass(GeoTIFFImageIndexError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar GeoTIFFBase = /*#__PURE__*/function () {\n  function GeoTIFFBase() {\n    _classCallCheck(this, GeoTIFFBase);\n  }\n\n  _createClass(GeoTIFFBase, [{\n    key: \"readRasters\",\n    value:\n    /**\n     * (experimental) Reads raster data from the best fitting image. This function uses\n     * the image with the lowest resolution that is still a higher resolution than the\n     * requested resolution.\n     * When specified, the `bbox` option is translated to the `window` option and the\n     * `resX` and `resY` to `width` and `height` respectively.\n     * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n     * image is called and the result returned.\n     * @see GeoTIFFImage.readRasters\n     * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n     * @returns {Promise<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n     */\n    function () {\n      var _readRasters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var options,\n            imageWindow,\n            width,\n            height,\n            resX,\n            resY,\n            bbox,\n            firstImage,\n            usedImage,\n            imageCount,\n            imgBBox,\n            _firstImage$getOrigin,\n            _firstImage$getOrigin2,\n            oX,\n            oY,\n            _firstImage$getResolu,\n            _firstImage$getResolu2,\n            rX,\n            rY,\n            usedBBox,\n            allImages,\n            i,\n            image,\n            _image$fileDirectory,\n            subfileType,\n            newSubfileType,\n            _i2,\n            _image,\n            imgResX,\n            imgResY,\n            wnd,\n            _firstImage$getOrigin3,\n            _firstImage$getOrigin4,\n            _oX,\n            _oY,\n            _usedImage$getResolut,\n            _usedImage$getResolut2,\n            imageResX,\n            imageResY,\n            _args = arguments;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                imageWindow = options.window, width = options.width, height = options.height;\n                resX = options.resX, resY = options.resY, bbox = options.bbox;\n                _context.next = 5;\n                return this.getImage();\n\n              case 5:\n                firstImage = _context.sent;\n                usedImage = firstImage;\n                _context.next = 9;\n                return this.getImageCount();\n\n              case 9:\n                imageCount = _context.sent;\n                imgBBox = firstImage.getBoundingBox();\n\n                if (!(imageWindow && bbox)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw new Error('Both \"bbox\" and \"window\" passed.');\n\n              case 13:\n                if (!(width || height)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                // if we have an image window (pixel coordinates), transform it to a BBox\n                // using the origin/resolution of the first image.\n                if (imageWindow) {\n                  _firstImage$getOrigin = firstImage.getOrigin(), _firstImage$getOrigin2 = _slicedToArray(_firstImage$getOrigin, 2), oX = _firstImage$getOrigin2[0], oY = _firstImage$getOrigin2[1];\n                  _firstImage$getResolu = firstImage.getResolution(), _firstImage$getResolu2 = _slicedToArray(_firstImage$getResolu, 2), rX = _firstImage$getResolu2[0], rY = _firstImage$getResolu2[1];\n                  bbox = [oX + imageWindow[0] * rX, oY + imageWindow[1] * rY, oX + imageWindow[2] * rX, oY + imageWindow[3] * rY];\n                } // if we have a bbox (or calculated one)\n\n\n                usedBBox = bbox || imgBBox;\n\n                if (!width) {\n                  _context.next = 20;\n                  break;\n                }\n\n                if (!resX) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw new Error('Both width and resX passed');\n\n              case 19:\n                resX = (usedBBox[2] - usedBBox[0]) / width;\n\n              case 20:\n                if (!height) {\n                  _context.next = 24;\n                  break;\n                }\n\n                if (!resY) {\n                  _context.next = 23;\n                  break;\n                }\n\n                throw new Error('Both width and resY passed');\n\n              case 23:\n                resY = (usedBBox[3] - usedBBox[1]) / height;\n\n              case 24:\n                if (!(resX || resY)) {\n                  _context.next = 48;\n                  break;\n                }\n\n                allImages = [];\n                i = 0;\n\n              case 27:\n                if (!(i < imageCount)) {\n                  _context.next = 36;\n                  break;\n                }\n\n                _context.next = 30;\n                return this.getImage(i);\n\n              case 30:\n                image = _context.sent;\n                _image$fileDirectory = image.fileDirectory, subfileType = _image$fileDirectory.SubfileType, newSubfileType = _image$fileDirectory.NewSubfileType;\n\n                if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n                  allImages.push(image);\n                }\n\n              case 33:\n                ++i;\n                _context.next = 27;\n                break;\n\n              case 36:\n                allImages.sort(function (a, b) {\n                  return a.getWidth() - b.getWidth();\n                });\n                _i2 = 0;\n\n              case 38:\n                if (!(_i2 < allImages.length)) {\n                  _context.next = 48;\n                  break;\n                }\n\n                _image = allImages[_i2];\n                imgResX = (imgBBox[2] - imgBBox[0]) / _image.getWidth();\n                imgResY = (imgBBox[3] - imgBBox[1]) / _image.getHeight();\n                usedImage = _image;\n\n                if (!(resX && resX > imgResX || resY && resY > imgResY)) {\n                  _context.next = 45;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 48);\n\n              case 45:\n                ++_i2;\n                _context.next = 38;\n                break;\n\n              case 48:\n                wnd = imageWindow;\n\n                if (bbox) {\n                  _firstImage$getOrigin3 = firstImage.getOrigin(), _firstImage$getOrigin4 = _slicedToArray(_firstImage$getOrigin3, 2), _oX = _firstImage$getOrigin4[0], _oY = _firstImage$getOrigin4[1];\n                  _usedImage$getResolut = usedImage.getResolution(firstImage), _usedImage$getResolut2 = _slicedToArray(_usedImage$getResolut, 2), imageResX = _usedImage$getResolut2[0], imageResY = _usedImage$getResolut2[1];\n                  wnd = [Math.round((bbox[0] - _oX) / imageResX), Math.round((bbox[1] - _oY) / imageResY), Math.round((bbox[2] - _oX) / imageResX), Math.round((bbox[3] - _oY) / imageResY)];\n                  wnd = [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];\n                }\n\n                return _context.abrupt(\"return\", usedImage.readRasters(_objectSpread(_objectSpread({}, options), {}, {\n                  window: wnd\n                })));\n\n              case 51:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function readRasters() {\n        return _readRasters.apply(this, arguments);\n      }\n\n      return readRasters;\n    }()\n  }]);\n\n  return GeoTIFFBase;\n}();\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\n\n\nvar GeoTIFF = /*#__PURE__*/function (_GeoTIFFBase) {\n  _inherits(GeoTIFF, _GeoTIFFBase);\n\n  var _super2 = _createSuper(GeoTIFF);\n\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  function GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset) {\n    var _this2;\n\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    _classCallCheck(this, GeoTIFF);\n\n    _this2 = _super2.call(this);\n    _this2.source = source;\n    _this2.littleEndian = littleEndian;\n    _this2.bigTiff = bigTiff;\n    _this2.firstIFDOffset = firstIFDOffset;\n    _this2.cache = options.cache || false;\n    _this2.ifdRequests = [];\n    _this2.ghostValues = null;\n    return _this2;\n  }\n\n  _createClass(GeoTIFF, [{\n    key: \"getSlice\",\n    value: function () {\n      var _getSlice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(offset, size) {\n        var fallbackSize;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                fallbackSize = this.bigTiff ? 4048 : 1024;\n                _context2.t0 = DataSlice;\n                _context2.next = 4;\n                return this.source.fetch([{\n                  offset: offset,\n                  length: typeof size !== 'undefined' ? size : fallbackSize\n                }]);\n\n              case 4:\n                _context2.t1 = _context2.sent[0];\n                _context2.t2 = offset;\n                _context2.t3 = this.littleEndian;\n                _context2.t4 = this.bigTiff;\n                return _context2.abrupt(\"return\", new _context2.t0(_context2.t1, _context2.t2, _context2.t3, _context2.t4));\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getSlice(_x, _x2) {\n        return _getSlice.apply(this, arguments);\n      }\n\n      return getSlice;\n    }()\n    /**\n     * Instructs to parse an image file directory at the given file offset.\n     * As there is no way to ensure that a location is indeed the start of an IFD,\n     * this function must be called with caution (e.g only using the IFD offsets from\n     * the headers or other IFDs).\n     * @param {number} offset the offset to parse the IFD at\n     * @returns {Promise<ImageFileDirectory>} the parsed IFD\n     */\n\n  }, {\n    key: \"parseFileDirectoryAt\",\n    value: function () {\n      var _parseFileDirectoryAt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(offset) {\n        var entrySize, offsetSize, dataSlice, numDirEntries, byteSize, fileDirectory, i, entryCount, fieldTag, fieldType, typeCount, fieldValues, value, fieldTypeLength, valueOffset, actualOffset, length, fieldDataSlice, geoKeyDirectory, nextIFDByteOffset;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                entrySize = this.bigTiff ? 20 : 12;\n                offsetSize = this.bigTiff ? 8 : 2;\n                _context3.next = 4;\n                return this.getSlice(offset);\n\n              case 4:\n                dataSlice = _context3.sent;\n                numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset); // if the slice does not cover the whole IFD, request a bigger slice, where the\n                // whole IFD fits: num of entries + n x tag length + offset to next IFD\n\n                byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);\n\n                if (dataSlice.covers(offset, byteSize)) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 10;\n                return this.getSlice(offset, byteSize);\n\n              case 10:\n                dataSlice = _context3.sent;\n\n              case 11:\n                fileDirectory = {}; // loop over the IFD and create a file directory object\n\n                i = offset + (this.bigTiff ? 8 : 2);\n                entryCount = 0;\n\n              case 14:\n                if (!(entryCount < numDirEntries)) {\n                  _context3.next = 41;\n                  break;\n                }\n\n                fieldTag = dataSlice.readUint16(i);\n                fieldType = dataSlice.readUint16(i + 2);\n                typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);\n                fieldValues = void 0;\n                value = void 0;\n                fieldTypeLength = getFieldTypeLength(fieldType);\n                valueOffset = i + (this.bigTiff ? 12 : 8); // check whether the value is directly encoded in the tag or refers to a\n                // different external byte range\n\n                if (!(fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4))) {\n                  _context3.next = 26;\n                  break;\n                }\n\n                fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n                _context3.next = 36;\n                break;\n\n              case 26:\n                // resolve the reference to the actual byte range\n                actualOffset = dataSlice.readOffset(valueOffset);\n                length = getFieldTypeLength(fieldType) * typeCount; // check, whether we actually cover the referenced byte range; if not,\n                // request a new slice of bytes to read from it\n\n                if (!dataSlice.covers(actualOffset, length)) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n                _context3.next = 36;\n                break;\n\n              case 32:\n                _context3.next = 34;\n                return this.getSlice(actualOffset, length);\n\n              case 34:\n                fieldDataSlice = _context3.sent;\n                fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n\n              case 36:\n                // unpack single values from the array\n                if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n                  value = fieldValues[0];\n                } else {\n                  value = fieldValues;\n                } // write the tags value to the file directly\n\n\n                fileDirectory[fieldTagNames[fieldTag]] = value;\n\n              case 38:\n                i += entrySize, ++entryCount;\n                _context3.next = 14;\n                break;\n\n              case 41:\n                geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n                nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);\n                return _context3.abrupt(\"return\", new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset));\n\n              case 44:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function parseFileDirectoryAt(_x3) {\n        return _parseFileDirectoryAt.apply(this, arguments);\n      }\n\n      return parseFileDirectoryAt;\n    }()\n  }, {\n    key: \"requestIFD\",\n    value: function () {\n      var _requestIFD = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(index) {\n        var _this3 = this;\n\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!this.ifdRequests[index]) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", this.ifdRequests[index]);\n\n              case 4:\n                if (!(index === 0)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                // special case for index 0\n                this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n                return _context5.abrupt(\"return\", this.ifdRequests[index]);\n\n              case 9:\n                if (this.ifdRequests[index - 1]) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                _context5.prev = 10;\n                this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n                _context5.next = 19;\n                break;\n\n              case 14:\n                _context5.prev = 14;\n                _context5.t0 = _context5[\"catch\"](10);\n\n                if (!(_context5.t0 instanceof GeoTIFFImageIndexError)) {\n                  _context5.next = 18;\n                  break;\n                }\n\n                throw new GeoTIFFImageIndexError(index);\n\n              case 18:\n                throw _context5.t0;\n\n              case 19:\n                // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n                // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n                this.ifdRequests[index] = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n                  var previousIfd;\n                  return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return _this3.ifdRequests[index - 1];\n\n                        case 2:\n                          previousIfd = _context4.sent;\n\n                          if (!(previousIfd.nextIFDByteOffset === 0)) {\n                            _context4.next = 5;\n                            break;\n                          }\n\n                          throw new GeoTIFFImageIndexError(index);\n\n                        case 5:\n                          return _context4.abrupt(\"return\", _this3.parseFileDirectoryAt(previousIfd.nextIFDByteOffset));\n\n                        case 6:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                }))();\n                return _context5.abrupt(\"return\", this.ifdRequests[index]);\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[10, 14]]);\n      }));\n\n      function requestIFD(_x4) {\n        return _requestIFD.apply(this, arguments);\n      }\n\n      return requestIFD;\n    }()\n    /**\n     * Get the n-th internal subfile of an image. By default, the first is returned.\n     *\n     * @param {number} [index=0] the index of the image to return.\n     * @returns {Promise<GeoTIFFImage>} the image at the given index\n     */\n\n  }, {\n    key: \"getImage\",\n    value: function () {\n      var _getImage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n        var index,\n            ifd,\n            _args6 = arguments;\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                index = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : 0;\n                _context6.next = 3;\n                return this.requestIFD(index);\n\n              case 3:\n                ifd = _context6.sent;\n                return _context6.abrupt(\"return\", new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source));\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getImage() {\n        return _getImage.apply(this, arguments);\n      }\n\n      return getImage;\n    }()\n    /**\n     * Returns the count of the internal subfiles.\n     *\n     * @returns {Promise<number>} the number of internal subfile images\n     */\n\n  }, {\n    key: \"getImageCount\",\n    value: function () {\n      var _getImageCount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {\n        var index, hasNext;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                index = 0; // loop until we run out of IFDs\n\n                hasNext = true;\n\n              case 2:\n                if (!hasNext) {\n                  _context7.next = 18;\n                  break;\n                }\n\n                _context7.prev = 3;\n                _context7.next = 6;\n                return this.requestIFD(index);\n\n              case 6:\n                ++index;\n                _context7.next = 16;\n                break;\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](3);\n\n                if (!(_context7.t0 instanceof GeoTIFFImageIndexError)) {\n                  _context7.next = 15;\n                  break;\n                }\n\n                hasNext = false;\n                _context7.next = 16;\n                break;\n\n              case 15:\n                throw _context7.t0;\n\n              case 16:\n                _context7.next = 2;\n                break;\n\n              case 18:\n                return _context7.abrupt(\"return\", index);\n\n              case 19:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[3, 9]]);\n      }));\n\n      function getImageCount() {\n        return _getImageCount.apply(this, arguments);\n      }\n\n      return getImageCount;\n    }()\n    /**\n     * Get the values of the COG ghost area as a parsed map.\n     * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n     * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n     */\n\n  }, {\n    key: \"getGhostValues\",\n    value: function () {\n      var _getGhostValues = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {\n        var _this4 = this;\n\n        var offset, detectionString, heuristicAreaSize, slice, valuesString, firstLine, metadataSize, fullString;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                offset = this.bigTiff ? 16 : 8;\n\n                if (!this.ghostValues) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.ghostValues);\n\n              case 3:\n                detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n                heuristicAreaSize = detectionString.length + 100;\n                _context8.next = 7;\n                return this.getSlice(offset, heuristicAreaSize);\n\n              case 7:\n                slice = _context8.sent;\n\n                if (!(detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset))) {\n                  _context8.next = 19;\n                  break;\n                }\n\n                valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n                firstLine = valuesString.split('\\n')[0];\n                metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n\n                if (!(metadataSize > heuristicAreaSize)) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                _context8.next = 15;\n                return this.getSlice(offset, metadataSize);\n\n              case 15:\n                slice = _context8.sent;\n\n              case 16:\n                fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n                this.ghostValues = {};\n                fullString.split('\\n').filter(function (line) {\n                  return line.length > 0;\n                }).map(function (line) {\n                  return line.split('=');\n                }).forEach(function (_ref2) {\n                  var _ref3 = _slicedToArray(_ref2, 2),\n                      key = _ref3[0],\n                      value = _ref3[1];\n\n                  _this4.ghostValues[key] = value;\n                });\n\n              case 19:\n                return _context8.abrupt(\"return\", this.ghostValues);\n\n              case 20:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getGhostValues() {\n        return _getGhostValues.apply(this, arguments);\n      }\n\n      return getGhostValues;\n    }()\n    /**\n     * Parse a (Geo)TIFF file from the given source.\n     *\n     * @param {*} source The source of data to parse from.\n     * @param {GeoTIFFOptions} [options] Additional options.\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     */\n\n  }, {\n    key: \"close\",\n    value:\n    /**\n     * Closes the underlying file buffer\n     * N.B. After the GeoTIFF has been completely processed it needs\n     * to be closed but only if it has been constructed from a file.\n     */\n    function close() {\n      if (typeof this.source.close === 'function') {\n        return this.source.close();\n      }\n\n      return false;\n    }\n  }], [{\n    key: \"fromSource\",\n    value: function () {\n      var _fromSource = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(source, options, signal) {\n        var headerData, dataView, BOM, littleEndian, magicNumber, bigTiff, offsetByteSize, firstIFDOffset;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return source.fetch([{\n                  offset: 0,\n                  length: 1024\n                }], signal);\n\n              case 2:\n                headerData = _context9.sent[0];\n                dataView = new DataView64(headerData);\n                BOM = dataView.getUint16(0, 0);\n\n                if (!(BOM === 0x4949)) {\n                  _context9.next = 9;\n                  break;\n                }\n\n                littleEndian = true;\n                _context9.next = 14;\n                break;\n\n              case 9:\n                if (!(BOM === 0x4D4D)) {\n                  _context9.next = 13;\n                  break;\n                }\n\n                littleEndian = false;\n                _context9.next = 14;\n                break;\n\n              case 13:\n                throw new TypeError('Invalid byte order value.');\n\n              case 14:\n                magicNumber = dataView.getUint16(2, littleEndian);\n\n                if (!(magicNumber === 42)) {\n                  _context9.next = 19;\n                  break;\n                }\n\n                bigTiff = false;\n                _context9.next = 27;\n                break;\n\n              case 19:\n                if (!(magicNumber === 43)) {\n                  _context9.next = 26;\n                  break;\n                }\n\n                bigTiff = true;\n                offsetByteSize = dataView.getUint16(4, littleEndian);\n\n                if (!(offsetByteSize !== 8)) {\n                  _context9.next = 24;\n                  break;\n                }\n\n                throw new Error('Unsupported offset byte-size.');\n\n              case 24:\n                _context9.next = 27;\n                break;\n\n              case 26:\n                throw new TypeError('Invalid magic number.');\n\n              case 27:\n                firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);\n                return _context9.abrupt(\"return\", new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options));\n\n              case 29:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function fromSource(_x5, _x6, _x7) {\n        return _fromSource.apply(this, arguments);\n      }\n\n      return fromSource;\n    }()\n  }]);\n\n  return GeoTIFF;\n}(GeoTIFFBase);\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\n\nvar MultiGeoTIFF = /*#__PURE__*/function (_GeoTIFFBase2) {\n  _inherits(MultiGeoTIFF, _GeoTIFFBase2);\n\n  var _super3 = _createSuper(MultiGeoTIFF);\n\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  function MultiGeoTIFF(mainFile, overviewFiles) {\n    var _this5;\n\n    _classCallCheck(this, MultiGeoTIFF);\n\n    _this5 = _super3.call(this);\n    _this5.mainFile = mainFile;\n    _this5.overviewFiles = overviewFiles;\n    _this5.imageFiles = [mainFile].concat(overviewFiles);\n    _this5.fileDirectoriesPerFile = null;\n    _this5.fileDirectoriesPerFileParsing = null;\n    _this5.imageCount = null;\n    return _this5;\n  }\n\n  _createClass(MultiGeoTIFF, [{\n    key: \"parseFileDirectoriesPerFile\",\n    value: function () {\n      var _parseFileDirectoriesPerFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {\n        var requests;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(function (file) {\n                  return file.parseFileDirectoryAt(file.firstIFDOffset);\n                }));\n                _context10.next = 3;\n                return Promise.all(requests);\n\n              case 3:\n                this.fileDirectoriesPerFile = _context10.sent;\n                return _context10.abrupt(\"return\", this.fileDirectoriesPerFile);\n\n              case 5:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function parseFileDirectoriesPerFile() {\n        return _parseFileDirectoriesPerFile.apply(this, arguments);\n      }\n\n      return parseFileDirectoriesPerFile;\n    }()\n    /**\n     * Get the n-th internal subfile of an image. By default, the first is returned.\n     *\n     * @param {number} [index=0] the index of the image to return.\n     * @returns {Promise<GeoTIFFImage>} the image at the given index\n     */\n\n  }, {\n    key: \"getImage\",\n    value: function () {\n      var _getImage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {\n        var index,\n            visited,\n            relativeIndex,\n            i,\n            imageFile,\n            ii,\n            ifd,\n            _args11 = arguments;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                index = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : 0;\n                _context11.next = 3;\n                return this.getImageCount();\n\n              case 3:\n                _context11.next = 5;\n                return this.parseFileDirectoriesPerFile();\n\n              case 5:\n                visited = 0;\n                relativeIndex = 0;\n                i = 0;\n\n              case 8:\n                if (!(i < this.imageFiles.length)) {\n                  _context11.next = 26;\n                  break;\n                }\n\n                imageFile = this.imageFiles[i];\n                ii = 0;\n\n              case 11:\n                if (!(ii < this.imageCounts[i])) {\n                  _context11.next = 22;\n                  break;\n                }\n\n                if (!(index === visited)) {\n                  _context11.next = 17;\n                  break;\n                }\n\n                _context11.next = 15;\n                return imageFile.requestIFD(relativeIndex);\n\n              case 15:\n                ifd = _context11.sent;\n                return _context11.abrupt(\"return\", new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source));\n\n              case 17:\n                visited++;\n                relativeIndex++;\n\n              case 19:\n                ii++;\n                _context11.next = 11;\n                break;\n\n              case 22:\n                relativeIndex = 0;\n\n              case 23:\n                i++;\n                _context11.next = 8;\n                break;\n\n              case 26:\n                throw new RangeError('Invalid image index');\n\n              case 27:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getImage() {\n        return _getImage2.apply(this, arguments);\n      }\n\n      return getImage;\n    }()\n    /**\n     * Returns the count of the internal subfiles.\n     *\n     * @returns {Promise<number>} the number of internal subfile images\n     */\n\n  }, {\n    key: \"getImageCount\",\n    value: function () {\n      var _getImageCount2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {\n        var requests;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!(this.imageCount !== null)) {\n                  _context12.next = 2;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", this.imageCount);\n\n              case 2:\n                requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map(function (file) {\n                  return file.getImageCount();\n                }));\n                _context12.next = 5;\n                return Promise.all(requests);\n\n              case 5:\n                this.imageCounts = _context12.sent;\n                this.imageCount = this.imageCounts.reduce(function (count, ifds) {\n                  return count + ifds;\n                }, 0);\n                return _context12.abrupt(\"return\", this.imageCount);\n\n              case 8:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getImageCount() {\n        return _getImageCount2.apply(this, arguments);\n      }\n\n      return getImageCount;\n    }()\n  }]);\n\n  return MultiGeoTIFF;\n}(GeoTIFFBase);\n\nexport { MultiGeoTIFF };\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nexport function fromUrl(_x8) {\n  return _fromUrl.apply(this, arguments);\n}\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromUrl() {\n  _fromUrl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(url) {\n    var options,\n        signal,\n        _args13 = arguments;\n    return regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};\n            signal = _args13.length > 2 ? _args13[2] : undefined;\n            return _context13.abrupt(\"return\", GeoTIFF.fromSource(makeRemoteSource(url, options), signal));\n\n          case 3:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return _fromUrl.apply(this, arguments);\n}\n\nexport function fromArrayBuffer(_x9, _x10) {\n  return _fromArrayBuffer.apply(this, arguments);\n}\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromArrayBuffer() {\n  _fromArrayBuffer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(arrayBuffer, signal) {\n    return regeneratorRuntime.wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            return _context14.abrupt(\"return\", GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal));\n\n          case 1:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n  return _fromArrayBuffer.apply(this, arguments);\n}\n\nexport function fromFile(_x11, _x12) {\n  return _fromFile.apply(this, arguments);\n}\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromFile() {\n  _fromFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(path, signal) {\n    return regeneratorRuntime.wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            return _context15.abrupt(\"return\", GeoTIFF.fromSource(makeFileSource(path), signal));\n\n          case 1:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  return _fromFile.apply(this, arguments);\n}\n\nexport function fromBlob(_x13, _x14) {\n  return _fromBlob.apply(this, arguments);\n}\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\n\nfunction _fromBlob() {\n  _fromBlob = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(blob, signal) {\n    return regeneratorRuntime.wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            return _context16.abrupt(\"return\", GeoTIFF.fromSource(makeFileReaderSource(blob), signal));\n\n          case 1:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return _fromBlob.apply(this, arguments);\n}\n\nexport function fromUrls(_x15) {\n  return _fromUrls.apply(this, arguments);\n}\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\n\nfunction _fromUrls() {\n  _fromUrls = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(mainUrl) {\n    var overviewUrls,\n        options,\n        signal,\n        mainFile,\n        overviewFiles,\n        _args17 = arguments;\n    return regeneratorRuntime.wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            overviewUrls = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : [];\n            options = _args17.length > 2 && _args17[2] !== undefined ? _args17[2] : {};\n            signal = _args17.length > 3 ? _args17[3] : undefined;\n            _context17.next = 5;\n            return GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n\n          case 5:\n            mainFile = _context17.sent;\n            _context17.next = 8;\n            return Promise.all(overviewUrls.map(function (url) {\n              return GeoTIFF.fromSource(makeRemoteSource(url, options));\n            }));\n\n          case 8:\n            overviewFiles = _context17.sent;\n            return _context17.abrupt(\"return\", new MultiGeoTIFF(mainFile, overviewFiles));\n\n          case 10:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17);\n  }));\n  return _fromUrls.apply(this, arguments);\n}\n\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\nexport { Pool };\nexport { GeoTIFFImage };","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/geotiff.js"],"names":["GeoTIFFImage","DataView64","DataSlice","Pool","makeRemoteSource","makeBufferSource","makeFileReaderSource","makeFileSource","fieldTypes","fieldTagNames","arrayFields","geoKeyNames","writeGeotiff","globals","rgb","getDecoder","addDecoder","setLogger","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","RangeError","parseGeoKeyDirectory","fileDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","i","key","location","count","offset","value","Error","substring","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","Uint8Array","readUint8","Int8Array","readInt8","Uint16Array","readUint16","Int16Array","readInt16","Uint32Array","readUint32","Int32Array","readInt32","Array","readUint64","readInt64","Float32Array","readFloat32","Float64Array","readFloat64","call","TextDecoder","decode","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","index","GeoTIFFBase","options","imageWindow","window","width","height","resX","resY","bbox","getImage","firstImage","usedImage","getImageCount","imageCount","imgBBox","getBoundingBox","getOrigin","oX","oY","getResolution","rX","rY","usedBBox","allImages","image","subfileType","SubfileType","newSubfileType","NewSubfileType","push","sort","a","b","getWidth","length","imgResX","imgResY","getHeight","wnd","imageResX","imageResY","Math","round","min","max","readRasters","GeoTIFF","source","littleEndian","bigTiff","firstIFDOffset","cache","ifdRequests","ghostValues","size","fallbackSize","fetch","entrySize","offsetSize","getSlice","numDirEntries","byteSize","covers","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","readOffset","fieldDataSlice","indexOf","parseFileDirectoryAt","requestIFD","previousIfd","ifd","dataView","hasNext","detectionString","heuristicAreaSize","slice","valuesString","firstLine","split","metadataSize","Number","fullString","filter","line","map","forEach","close","signal","headerData","BOM","getUint16","TypeError","magicNumber","offsetByteSize","getUint64","getUint32","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","concat","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","requests","file","Promise","all","parseFileDirectoriesPerFile","visited","relativeIndex","imageFile","ii","imageCounts","reduce","ifds","fromUrl","url","fromSource","fromArrayBuffer","arrayBuffer","fromFile","path","fromBlob","blob","fromUrls","mainUrl","overviewUrls","writeArrayBuffer","metadata"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,OAAOA,YAAP,MAAyB,mBAAzB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,IAAP,MAAiB,WAAjB;AAEA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,gBAAT,QAAiC,yBAAjC;AACA,SAASC,oBAAT,QAAqC,wBAArC;AACA,SAASC,cAAT,QAA+B,kBAA/B;AAEA,SAASC,UAAT,EAAqBC,aAArB,EAAoCC,WAApC,EAAiDC,WAAjD,QAAoE,cAApE;AACA,SAASC,YAAT,QAA6B,oBAA7B;AACA,OAAO,KAAKC,OAAZ,MAAyB,cAAzB;AACA,OAAO,KAAKC,GAAZ,MAAqB,UAArB;AACA,SAASC,UAAT,EAAqBC,UAArB,QAAuC,wBAAvC;AACA,SAASC,SAAT,QAA0B,cAA1B;AAEA,SAASJ,OAAT;AACA,SAASC,GAAT;AACA,SAASC,UAAT,EAAqBC,UAArB;AACA,SAASC,SAAT;AAEA;AACA;AACA;AACA;;AAEA,SAASC,kBAAT,CAA4BC,SAA5B,EAAuC;AACrC,UAAQA,SAAR;AACE,SAAKX,UAAU,CAACY,IAAhB;AAAsB,SAAKZ,UAAU,CAACa,KAAhB;AAAuB,SAAKb,UAAU,CAACc,KAAhB;AAAuB,SAAKd,UAAU,CAACe,SAAhB;AAClE,aAAO,CAAP;;AACF,SAAKf,UAAU,CAACgB,KAAhB;AAAuB,SAAKhB,UAAU,CAACiB,MAAhB;AACrB,aAAO,CAAP;;AACF,SAAKjB,UAAU,CAACkB,IAAhB;AAAsB,SAAKlB,UAAU,CAACmB,KAAhB;AAAuB,SAAKnB,UAAU,CAACoB,KAAhB;AAAuB,SAAKpB,UAAU,CAACqB,GAAhB;AAClE,aAAO,CAAP;;AACF,SAAKrB,UAAU,CAACsB,QAAhB;AAA0B,SAAKtB,UAAU,CAACuB,SAAhB;AAA2B,SAAKvB,UAAU,CAACwB,MAAhB;AACrD,SAAKxB,UAAU,CAACyB,KAAhB;AAAuB,SAAKzB,UAAU,CAAC0B,MAAhB;AAAwB,SAAK1B,UAAU,CAAC2B,IAAhB;AAC7C,aAAO,CAAP;;AACF;AACE,YAAM,IAAIC,UAAJ,+BAAsCjB,SAAtC,EAAN;AAXJ;AAaD;;AAED,SAASkB,oBAAT,CAA8BC,aAA9B,EAA6C;AAC3C,MAAMC,kBAAkB,GAAGD,aAAa,CAACE,eAAzC;;AACA,MAAI,CAACD,kBAAL,EAAyB;AACvB,WAAO,IAAP;AACD;;AAED,MAAME,eAAe,GAAG,EAAxB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,kBAAkB,CAAC,CAAD,CAAlB,GAAwB,CAA7C,EAAgDG,CAAC,IAAI,CAArD,EAAwD;AACtD,QAAMC,GAAG,GAAGhC,WAAW,CAAC4B,kBAAkB,CAACG,CAAD,CAAnB,CAAvB;AACA,QAAME,QAAQ,GAAIL,kBAAkB,CAACG,CAAC,GAAG,CAAL,CAAnB,GACZjC,aAAa,CAAC8B,kBAAkB,CAACG,CAAC,GAAG,CAAL,CAAnB,CADD,GACgC,IADjD;AAEA,QAAMG,KAAK,GAAGN,kBAAkB,CAACG,CAAC,GAAG,CAAL,CAAhC;AACA,QAAMI,MAAM,GAAGP,kBAAkB,CAACG,CAAC,GAAG,CAAL,CAAjC;AAEA,QAAIK,KAAK,GAAG,IAAZ;;AACA,QAAI,CAACH,QAAL,EAAe;AACbG,MAAAA,KAAK,GAAGD,MAAR;AACD,KAFD,MAEO;AACLC,MAAAA,KAAK,GAAGT,aAAa,CAACM,QAAD,CAArB;;AACA,UAAI,OAAOG,KAAP,KAAiB,WAAjB,IAAgCA,KAAK,KAAK,IAA9C,EAAoD;AAClD,cAAM,IAAIC,KAAJ,0CAA4CL,GAA5C,QAAN;AACD,OAFD,MAEO,IAAI,OAAOI,KAAP,KAAiB,QAArB,EAA+B;AACpCA,QAAAA,KAAK,GAAGA,KAAK,CAACE,SAAN,CAAgBH,MAAhB,EAAwBA,MAAM,GAAGD,KAAT,GAAiB,CAAzC,CAAR;AACD,OAFM,MAEA,IAAIE,KAAK,CAACG,QAAV,EAAoB;AACzBH,QAAAA,KAAK,GAAGA,KAAK,CAACG,QAAN,CAAeJ,MAAf,EAAuBA,MAAM,GAAGD,KAAhC,CAAR;;AACA,YAAIA,KAAK,KAAK,CAAd,EAAiB;AACfE,UAAAA,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAb;AACD;AACF;AACF;;AACDN,IAAAA,eAAe,CAACE,GAAD,CAAf,GAAuBI,KAAvB;AACD;;AACD,SAAON,eAAP;AACD;;AAED,SAASU,SAAT,CAAmBC,SAAnB,EAA8BjC,SAA9B,EAAyC0B,KAAzC,EAAgDC,MAAhD,EAAwD;AACtD,MAAIO,MAAM,GAAG,IAAb;AACA,MAAIC,UAAU,GAAG,IAAjB;AACA,MAAMC,eAAe,GAAGrC,kBAAkB,CAACC,SAAD,CAA1C;;AAEA,UAAQA,SAAR;AACE,SAAKX,UAAU,CAACY,IAAhB;AAAsB,SAAKZ,UAAU,CAACa,KAAhB;AAAuB,SAAKb,UAAU,CAACe,SAAhB;AAC3C8B,MAAAA,MAAM,GAAG,IAAIG,UAAJ,CAAeX,KAAf,CAAT;AAAgCS,MAAAA,UAAU,GAAGF,SAAS,CAACK,SAAvB;AAChC;;AACF,SAAKjD,UAAU,CAACc,KAAhB;AACE+B,MAAAA,MAAM,GAAG,IAAIK,SAAJ,CAAcb,KAAd,CAAT;AAA+BS,MAAAA,UAAU,GAAGF,SAAS,CAACO,QAAvB;AAC/B;;AACF,SAAKnD,UAAU,CAACgB,KAAhB;AACE6B,MAAAA,MAAM,GAAG,IAAIO,WAAJ,CAAgBf,KAAhB,CAAT;AAAiCS,MAAAA,UAAU,GAAGF,SAAS,CAACS,UAAvB;AACjC;;AACF,SAAKrD,UAAU,CAACiB,MAAhB;AACE4B,MAAAA,MAAM,GAAG,IAAIS,UAAJ,CAAejB,KAAf,CAAT;AAAgCS,MAAAA,UAAU,GAAGF,SAAS,CAACW,SAAvB;AAChC;;AACF,SAAKvD,UAAU,CAACkB,IAAhB;AAAsB,SAAKlB,UAAU,CAACqB,GAAhB;AACpBwB,MAAAA,MAAM,GAAG,IAAIW,WAAJ,CAAgBnB,KAAhB,CAAT;AAAiCS,MAAAA,UAAU,GAAGF,SAAS,CAACa,UAAvB;AACjC;;AACF,SAAKzD,UAAU,CAACmB,KAAhB;AACE0B,MAAAA,MAAM,GAAG,IAAIa,UAAJ,CAAerB,KAAf,CAAT;AAAgCS,MAAAA,UAAU,GAAGF,SAAS,CAACe,SAAvB;AAChC;;AACF,SAAK3D,UAAU,CAACyB,KAAhB;AAAuB,SAAKzB,UAAU,CAAC2B,IAAhB;AACrBkB,MAAAA,MAAM,GAAG,IAAIe,KAAJ,CAAUvB,KAAV,CAAT;AAA2BS,MAAAA,UAAU,GAAGF,SAAS,CAACiB,UAAvB;AAC3B;;AACF,SAAK7D,UAAU,CAAC0B,MAAhB;AACEmB,MAAAA,MAAM,GAAG,IAAIe,KAAJ,CAAUvB,KAAV,CAAT;AAA2BS,MAAAA,UAAU,GAAGF,SAAS,CAACkB,SAAvB;AAC3B;;AACF,SAAK9D,UAAU,CAACsB,QAAhB;AACEuB,MAAAA,MAAM,GAAG,IAAIW,WAAJ,CAAgBnB,KAAK,GAAG,CAAxB,CAAT;AAAqCS,MAAAA,UAAU,GAAGF,SAAS,CAACa,UAAvB;AACrC;;AACF,SAAKzD,UAAU,CAACuB,SAAhB;AACEsB,MAAAA,MAAM,GAAG,IAAIa,UAAJ,CAAerB,KAAK,GAAG,CAAvB,CAAT;AAAoCS,MAAAA,UAAU,GAAGF,SAAS,CAACe,SAAvB;AACpC;;AACF,SAAK3D,UAAU,CAACoB,KAAhB;AACEyB,MAAAA,MAAM,GAAG,IAAIkB,YAAJ,CAAiB1B,KAAjB,CAAT;AAAkCS,MAAAA,UAAU,GAAGF,SAAS,CAACoB,WAAvB;AAClC;;AACF,SAAKhE,UAAU,CAACwB,MAAhB;AACEqB,MAAAA,MAAM,GAAG,IAAIoB,YAAJ,CAAiB5B,KAAjB,CAAT;AAAkCS,MAAAA,UAAU,GAAGF,SAAS,CAACsB,WAAvB;AAClC;;AACF;AACE,YAAM,IAAItC,UAAJ,+BAAsCjB,SAAtC,EAAN;AAtCJ,GALsD,CA8CtD;;;AACA,MAAI,EAAEA,SAAS,KAAKX,UAAU,CAACsB,QAAzB,IAAqCX,SAAS,KAAKX,UAAU,CAACuB,SAAhE,CAAJ,EAAgF;AAC9E,SAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,KAApB,EAA2B,EAAEH,CAA7B,EAAgC;AAC9BW,MAAAA,MAAM,CAACX,CAAD,CAAN,GAAYY,UAAU,CAACqB,IAAX,CACVvB,SADU,EACCN,MAAM,GAAIJ,CAAC,GAAGa,eADf,CAAZ;AAGD;AACF,GAND,MAMO;AAAE;AACP,SAAK,IAAIb,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGG,KAApB,EAA2BH,EAAC,IAAI,CAAhC,EAAmC;AACjCW,MAAAA,MAAM,CAACX,EAAD,CAAN,GAAYY,UAAU,CAACqB,IAAX,CACVvB,SADU,EACCN,MAAM,GAAIJ,EAAC,GAAGa,eADf,CAAZ;AAGAF,MAAAA,MAAM,CAACX,EAAC,GAAG,CAAL,CAAN,GAAgBY,UAAU,CAACqB,IAAX,CACdvB,SADc,EACHN,MAAM,IAAKJ,EAAC,GAAGa,eAAL,GAAwB,CAA5B,CADH,CAAhB;AAGD;AACF;;AAED,MAAIpC,SAAS,KAAKX,UAAU,CAACa,KAA7B,EAAoC;AAClC,WAAO,IAAIuD,WAAJ,CAAgB,OAAhB,EAAyBC,MAAzB,CAAgCxB,MAAhC,CAAP;AACD;;AACD,SAAOA,MAAP;AACD;AAED;AACA;AACA;AACA;;;IACMyB,kB,6BACJ,4BAAYxC,aAAZ,EAA2BG,eAA3B,EAA4CsC,iBAA5C,EAA+D;AAAA;;AAC7D,OAAKzC,aAAL,GAAqBA,aAArB;AACA,OAAKG,eAAL,GAAuBA,eAAvB;AACA,OAAKsC,iBAAL,GAAyBA,iBAAzB;AACD,C;AAGH;AACA;AACA;AACA;;;IACMC,sB;;;;;AACJ,kCAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACjB,0DAA2BA,KAA3B;AACA,UAAKA,KAAL,GAAaA,KAAb;AAFiB;AAGlB;;;iCAJkCjC,K;;IAO/BkC,W;;;;;;;;AACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;iFACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAkBC,gBAAAA,OAAlB,2DAA4B,EAA5B;AACkBC,gBAAAA,WADlB,GACiDD,OADjD,CACUE,MADV,EAC+BC,KAD/B,GACiDH,OADjD,CAC+BG,KAD/B,EACsCC,MADtC,GACiDJ,OADjD,CACsCI,MADtC;AAEQC,gBAAAA,IAFR,GAE6BL,OAF7B,CAEQK,IAFR,EAEcC,IAFd,GAE6BN,OAF7B,CAEcM,IAFd,EAEoBC,IAFpB,GAE6BP,OAF7B,CAEoBO,IAFpB;AAAA;AAAA,uBAI2B,KAAKC,QAAL,EAJ3B;;AAAA;AAIQC,gBAAAA,UAJR;AAKMC,gBAAAA,SALN,GAKkBD,UALlB;AAAA;AAAA,uBAM2B,KAAKE,aAAL,EAN3B;;AAAA;AAMQC,gBAAAA,UANR;AAOQC,gBAAAA,OAPR,GAOkBJ,UAAU,CAACK,cAAX,EAPlB;;AAAA,sBASMb,WAAW,IAAIM,IATrB;AAAA;AAAA;AAAA;;AAAA,sBAUU,IAAI1C,KAAJ,CAAU,kCAAV,CAVV;;AAAA;AAAA,sBAcMsC,KAAK,IAAIC,MAdf;AAAA;AAAA;AAAA;;AAeI;AACA;AACA,oBAAIH,WAAJ,EAAiB;AAAA,0CACEQ,UAAU,CAACM,SAAX,EADF,qEACRC,EADQ,8BACJC,EADI;AAAA,0CAEER,UAAU,CAACS,aAAX,EAFF,qEAERC,EAFQ,8BAEJC,EAFI;AAIfb,kBAAAA,IAAI,GAAG,CACLS,EAAE,GAAIf,WAAW,CAAC,CAAD,CAAX,GAAiBkB,EADlB,EAELF,EAAE,GAAIhB,WAAW,CAAC,CAAD,CAAX,GAAiBmB,EAFlB,EAGLJ,EAAE,GAAIf,WAAW,CAAC,CAAD,CAAX,GAAiBkB,EAHlB,EAILF,EAAE,GAAIhB,WAAW,CAAC,CAAD,CAAX,GAAiBmB,EAJlB,CAAP;AAMD,iBA3BL,CA6BI;;;AAEMC,gBAAAA,QA/BV,GA+BqBd,IAAI,IAAIM,OA/B7B;;AAAA,qBAiCQV,KAjCR;AAAA;AAAA;AAAA;;AAAA,qBAkCUE,IAlCV;AAAA;AAAA;AAAA;;AAAA,sBAmCc,IAAIxC,KAAJ,CAAU,4BAAV,CAnCd;;AAAA;AAqCMwC,gBAAAA,IAAI,GAAG,CAACgB,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAvB,IAA8BlB,KAArC;;AArCN;AAAA,qBAuCQC,MAvCR;AAAA;AAAA;AAAA;;AAAA,qBAwCUE,IAxCV;AAAA;AAAA;AAAA;;AAAA,sBAyCc,IAAIzC,KAAJ,CAAU,4BAAV,CAzCd;;AAAA;AA2CMyC,gBAAAA,IAAI,GAAG,CAACe,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAvB,IAA8BjB,MAArC;;AA3CN;AAAA,sBAgDMC,IAAI,IAAIC,IAhDd;AAAA;AAAA;AAAA;;AAiDUgB,gBAAAA,SAjDV,GAiDsB,EAjDtB;AAkDa/D,gBAAAA,CAlDb,GAkDiB,CAlDjB;;AAAA;AAAA,sBAkDoBA,CAAC,GAAGqD,UAlDxB;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAmD0B,KAAKJ,QAAL,CAAcjD,CAAd,CAnD1B;;AAAA;AAmDYgE,gBAAAA,KAnDZ;AAAA,uCAoD2EA,KAAK,CAACpE,aApDjF,EAoD2BqE,WApD3B,wBAoDcC,WApDd,EAoDwDC,cApDxD,wBAoDwCC,cApDxC;;AAqDM,oBAAIpE,CAAC,KAAK,CAAN,IAAWiE,WAAW,KAAK,CAA3B,IAAgCE,cAAc,GAAG,CAArD,EAAwD;AACtDJ,kBAAAA,SAAS,CAACM,IAAV,CAAeL,KAAf;AACD;;AAvDP;AAkDoC,kBAAEhE,CAlDtC;AAAA;AAAA;;AAAA;AA0DI+D,gBAAAA,SAAS,CAACO,IAAV,CAAe,UAACC,CAAD,EAAIC,CAAJ;AAAA,yBAAUD,CAAC,CAACE,QAAF,KAAeD,CAAC,CAACC,QAAF,EAAzB;AAAA,iBAAf;AACSzE,gBAAAA,GA3Db,GA2DiB,CA3DjB;;AAAA;AAAA,sBA2DoBA,GAAC,GAAG+D,SAAS,CAACW,MA3DlC;AAAA;AAAA;AAAA;;AA4DYV,gBAAAA,MA5DZ,GA4DoBD,SAAS,CAAC/D,GAAD,CA5D7B;AA6DY2E,gBAAAA,OA7DZ,GA6DsB,CAACrB,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAArB,IAA4BU,MAAK,CAACS,QAAN,EA7DlD;AA8DYG,gBAAAA,OA9DZ,GA8DsB,CAACtB,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAArB,IAA4BU,MAAK,CAACa,SAAN,EA9DlD;AAgEM1B,gBAAAA,SAAS,GAAGa,MAAZ;;AAhEN,sBAiEWlB,IAAI,IAAIA,IAAI,GAAG6B,OAAhB,IAA6B5B,IAAI,IAAIA,IAAI,GAAG6B,OAjEtD;AAAA;AAAA;AAAA;;AAAA;;AAAA;AA2D0C,kBAAE5E,GA3D5C;AAAA;AAAA;;AAAA;AAuEM8E,gBAAAA,GAvEN,GAuEYpC,WAvEZ;;AAwEE,oBAAIM,IAAJ,EAAU;AAAA,2CACSE,UAAU,CAACM,SAAX,EADT,sEACDC,GADC,8BACGC,GADH;AAAA,0CAEuBP,SAAS,CAACQ,aAAV,CAAwBT,UAAxB,CAFvB,qEAED6B,SAFC,8BAEUC,SAFV;AAIRF,kBAAAA,GAAG,GAAG,CACJG,IAAI,CAACC,KAAL,CAAW,CAAClC,IAAI,CAAC,CAAD,CAAJ,GAAUS,GAAX,IAAiBsB,SAA5B,CADI,EAEJE,IAAI,CAACC,KAAL,CAAW,CAAClC,IAAI,CAAC,CAAD,CAAJ,GAAUU,GAAX,IAAiBsB,SAA5B,CAFI,EAGJC,IAAI,CAACC,KAAL,CAAW,CAAClC,IAAI,CAAC,CAAD,CAAJ,GAAUS,GAAX,IAAiBsB,SAA5B,CAHI,EAIJE,IAAI,CAACC,KAAL,CAAW,CAAClC,IAAI,CAAC,CAAD,CAAJ,GAAUU,GAAX,IAAiBsB,SAA5B,CAJI,CAAN;AAMAF,kBAAAA,GAAG,GAAG,CACJG,IAAI,CAACE,GAAL,CAASL,GAAG,CAAC,CAAD,CAAZ,EAAiBA,GAAG,CAAC,CAAD,CAApB,CADI,EAEJG,IAAI,CAACE,GAAL,CAASL,GAAG,CAAC,CAAD,CAAZ,EAAiBA,GAAG,CAAC,CAAD,CAApB,CAFI,EAGJG,IAAI,CAACG,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,EAAiBA,GAAG,CAAC,CAAD,CAApB,CAHI,EAIJG,IAAI,CAACG,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,EAAiBA,GAAG,CAAC,CAAD,CAApB,CAJI,CAAN;AAMD;;AAxFH,iDA0FS3B,SAAS,CAACkC,WAAV,iCAA2B5C,OAA3B;AAAoCE,kBAAAA,MAAM,EAAEmC;AAA5C,mBA1FT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;AA8FF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;IACMQ,O;;;;;AACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,mBAAYC,MAAZ,EAAoBC,YAApB,EAAkCC,OAAlC,EAA2CC,cAA3C,EAAyE;AAAA;;AAAA,QAAdjD,OAAc,uEAAJ,EAAI;;AAAA;;AACvE;AACA,WAAK8C,MAAL,GAAcA,MAAd;AACA,WAAKC,YAAL,GAAoBA,YAApB;AACA,WAAKC,OAAL,GAAeA,OAAf;AACA,WAAKC,cAAL,GAAsBA,cAAtB;AACA,WAAKC,KAAL,GAAalD,OAAO,CAACkD,KAAR,IAAiB,KAA9B;AACA,WAAKC,WAAL,GAAmB,EAAnB;AACA,WAAKC,WAAL,GAAmB,IAAnB;AARuE;AASxE;;;;;8EAED,kBAAezF,MAAf,EAAuB0F,IAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,gBAAAA,YADR,GACuB,KAAKN,OAAL,GAAe,IAAf,GAAsB,IAD7C;AAAA,+BAEajI,SAFb;AAAA;AAAA,uBAGW,KAAK+H,MAAL,CAAYS,KAAZ,CAAkB,CAAC;AACxB5F,kBAAAA,MAAM,EAANA,MADwB;AAExBsE,kBAAAA,MAAM,EAAE,OAAOoB,IAAP,KAAgB,WAAhB,GAA8BA,IAA9B,GAAqCC;AAFrB,iBAAD,CAAlB,CAHX;;AAAA;AAAA,8CAMS,CANT;AAAA,+BAOI3F,MAPJ;AAAA,+BAQI,KAAKoF,YART;AAAA,+BASI,KAAKC,OATT;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAaA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;0FACE,kBAA2BrF,MAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AACQ6F,gBAAAA,SADR,GACoB,KAAKR,OAAL,GAAe,EAAf,GAAoB,EADxC;AAEQS,gBAAAA,UAFR,GAEqB,KAAKT,OAAL,GAAe,CAAf,GAAmB,CAFxC;AAAA;AAAA,uBAIwB,KAAKU,QAAL,CAAc/F,MAAd,CAJxB;;AAAA;AAIMM,gBAAAA,SAJN;AAKQ0F,gBAAAA,aALR,GAKwB,KAAKX,OAAL,GAClB/E,SAAS,CAACiB,UAAV,CAAqBvB,MAArB,CADkB,GAElBM,SAAS,CAACS,UAAV,CAAqBf,MAArB,CAPN,EASE;AACA;;AACMiG,gBAAAA,QAXR,GAWoBD,aAAa,GAAGH,SAAjB,IAA+B,KAAKR,OAAL,GAAe,EAAf,GAAoB,CAAnD,CAXnB;;AAAA,oBAYO/E,SAAS,CAAC4F,MAAV,CAAiBlG,MAAjB,EAAyBiG,QAAzB,CAZP;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAasB,KAAKF,QAAL,CAAc/F,MAAd,EAAsBiG,QAAtB,CAbtB;;AAAA;AAaI3F,gBAAAA,SAbJ;;AAAA;AAgBQd,gBAAAA,aAhBR,GAgBwB,EAhBxB,EAkBE;;AACII,gBAAAA,CAnBN,GAmBUI,MAAM,IAAI,KAAKqF,OAAL,GAAe,CAAf,GAAmB,CAAvB,CAnBhB;AAoBWc,gBAAAA,UApBX,GAoBwB,CApBxB;;AAAA;AAAA,sBAoB2BA,UAAU,GAAGH,aApBxC;AAAA;AAAA;AAAA;;AAqBUI,gBAAAA,QArBV,GAqBqB9F,SAAS,CAACS,UAAV,CAAqBnB,CAArB,CArBrB;AAsBUvB,gBAAAA,SAtBV,GAsBsBiC,SAAS,CAACS,UAAV,CAAqBnB,CAAC,GAAG,CAAzB,CAtBtB;AAuBUyG,gBAAAA,SAvBV,GAuBsB,KAAKhB,OAAL,GACd/E,SAAS,CAACiB,UAAV,CAAqB3B,CAAC,GAAG,CAAzB,CADc,GAEdU,SAAS,CAACa,UAAV,CAAqBvB,CAAC,GAAG,CAAzB,CAzBR;AA2BQ0G,gBAAAA,WA3BR;AA4BQrG,gBAAAA,KA5BR;AA6BUQ,gBAAAA,eA7BV,GA6B4BrC,kBAAkB,CAACC,SAAD,CA7B9C;AA8BUkI,gBAAAA,WA9BV,GA8BwB3G,CAAC,IAAI,KAAKyF,OAAL,GAAe,EAAf,GAAoB,CAAxB,CA9BzB,EAgCI;AACA;;AAjCJ,sBAkCQ5E,eAAe,GAAG4F,SAAlB,KAAgC,KAAKhB,OAAL,GAAe,CAAf,GAAmB,CAAnD,CAlCR;AAAA;AAAA;AAAA;;AAmCMiB,gBAAAA,WAAW,GAAGjG,SAAS,CAACC,SAAD,EAAYjC,SAAZ,EAAuBgI,SAAvB,EAAkCE,WAAlC,CAAvB;AAnCN;AAAA;;AAAA;AAqCM;AACMC,gBAAAA,YAtCZ,GAsC2BlG,SAAS,CAACmG,UAAV,CAAqBF,WAArB,CAtC3B;AAuCYjC,gBAAAA,MAvCZ,GAuCqBlG,kBAAkB,CAACC,SAAD,CAAlB,GAAgCgI,SAvCrD,EAyCM;AACA;;AA1CN,qBA2CU/F,SAAS,CAAC4F,MAAV,CAAiBM,YAAjB,EAA+BlC,MAA/B,CA3CV;AAAA;AAAA;AAAA;;AA4CQgC,gBAAAA,WAAW,GAAGjG,SAAS,CAACC,SAAD,EAAYjC,SAAZ,EAAuBgI,SAAvB,EAAkCG,YAAlC,CAAvB;AA5CR;AAAA;;AAAA;AAAA;AAAA,uBA8CqC,KAAKT,QAAL,CAAcS,YAAd,EAA4BlC,MAA5B,CA9CrC;;AAAA;AA8CcoC,gBAAAA,cA9Cd;AA+CQJ,gBAAAA,WAAW,GAAGjG,SAAS,CAACqG,cAAD,EAAiBrI,SAAjB,EAA4BgI,SAA5B,EAAuCG,YAAvC,CAAvB;;AA/CR;AAmDI;AACA,oBAAIH,SAAS,KAAK,CAAd,IAAmBzI,WAAW,CAAC+I,OAAZ,CAAoBP,QAApB,MAAkC,CAAC,CAAtD,IACC,EAAE/H,SAAS,KAAKX,UAAU,CAACsB,QAAzB,IAAqCX,SAAS,KAAKX,UAAU,CAACuB,SAAhE,CADL,EACiF;AAC/EgB,kBAAAA,KAAK,GAAGqG,WAAW,CAAC,CAAD,CAAnB;AACD,iBAHD,MAGO;AACLrG,kBAAAA,KAAK,GAAGqG,WAAR;AACD,iBAzDL,CA2DI;;;AACA9G,gBAAAA,aAAa,CAAC7B,aAAa,CAACyI,QAAD,CAAd,CAAb,GAAyCnG,KAAzC;;AA5DJ;AAoBuDL,gBAAAA,CAAC,IAAIiG,SAAL,EAAgB,EAAEM,UApBzE;AAAA;AAAA;;AAAA;AA8DQxG,gBAAAA,eA9DR,GA8D0BJ,oBAAoB,CAACC,aAAD,CA9D9C;AA+DQyC,gBAAAA,iBA/DR,GA+D4B3B,SAAS,CAACmG,UAAV,CACxBzG,MAAM,GAAG8F,UAAT,GAAuBD,SAAS,GAAGG,aADX,CA/D5B;AAAA,kDAmES,IAAIhE,kBAAJ,CACLxC,aADK,EAELG,eAFK,EAGLsC,iBAHK,CAnET;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;gFA0EA,kBAAiBE,KAAjB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBAEM,KAAKqD,WAAL,CAAiBrD,KAAjB,CAFN;AAAA;AAAA;AAAA;;AAAA,kDAIW,KAAKqD,WAAL,CAAiBrD,KAAjB,CAJX;;AAAA;AAAA,sBAKaA,KAAK,KAAK,CALvB;AAAA;AAAA;AAAA;;AAMI;AACA,qBAAKqD,WAAL,CAAiBrD,KAAjB,IAA0B,KAAKyE,oBAAL,CAA0B,KAAKtB,cAA/B,CAA1B;AAPJ,kDAQW,KAAKE,WAAL,CAAiBrD,KAAjB,CARX;;AAAA;AAAA,oBASc,KAAKqD,WAAL,CAAiBrD,KAAK,GAAG,CAAzB,CATd;AAAA;AAAA;AAAA;;AAAA;AAaM,qBAAKqD,WAAL,CAAiBrD,KAAK,GAAG,CAAzB,IAA8B,KAAK0E,UAAL,CAAgB1E,KAAK,GAAG,CAAxB,CAA9B;AAbN;AAAA;;AAAA;AAAA;AAAA;;AAAA,sBAiBU,wBAAaD,sBAjBvB;AAAA;AAAA;AAAA;;AAAA,sBAkBc,IAAIA,sBAAJ,CAA2BC,KAA3B,CAlBd;;AAAA;AAAA;;AAAA;AAwBE;AACA;AACA,qBAAKqD,WAAL,CAAiBrD,KAAjB,IAA0B,wDAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCACC,MAAI,CAACqD,WAAL,CAAiBrD,KAAK,GAAG,CAAzB,CADD;;AAAA;AACnB2E,0BAAAA,WADmB;;AAAA,gCAErBA,WAAW,CAAC7E,iBAAZ,KAAkC,CAFb;AAAA;AAAA;AAAA;;AAAA,gCAGjB,IAAIC,sBAAJ,CAA2BC,KAA3B,CAHiB;;AAAA;AAAA,4DAKlB,MAAI,CAACyE,oBAAL,CAA0BE,WAAW,CAAC7E,iBAAtC,CALkB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAD,IAA1B;AA1BF,kDAiCS,KAAKuD,WAAL,CAAiBrD,KAAjB,CAjCT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAoCA;AACF;AACA;AACA;AACA;AACA;;;;;8EACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAeA,gBAAAA,KAAf,8DAAuB,CAAvB;AAAA;AAAA,uBACoB,KAAK0E,UAAL,CAAgB1E,KAAhB,CADpB;;AAAA;AACQ4E,gBAAAA,GADR;AAAA,kDAES,IAAI7J,YAAJ,CACL6J,GAAG,CAACvH,aADC,EACcuH,GAAG,CAACpH,eADlB,EAEL,KAAKqH,QAFA,EAEU,KAAK5B,YAFf,EAE6B,KAAKG,KAFlC,EAEyC,KAAKJ,MAF9C,CAFT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAQA;AACF;AACA;AACA;AACA;;;;;mFACE;AAAA;AAAA;AAAA;AAAA;AAAA;AACMhD,gBAAAA,KADN,GACc,CADd,EAEE;;AACI8E,gBAAAA,OAHN,GAGgB,IAHhB;;AAAA;AAAA,qBAISA,OAJT;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,uBAMY,KAAKJ,UAAL,CAAgB1E,KAAhB,CANZ;;AAAA;AAOM,kBAAEA,KAAF;AAPN;AAAA;;AAAA;AAAA;AAAA;;AAAA,sBASU,wBAAaD,sBATvB;AAAA;AAAA;AAAA;;AAUQ+E,gBAAAA,OAAO,GAAG,KAAV;AAVR;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,kDAgBS9E,KAhBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAmBA;AACF;AACA;AACA;AACA;;;;;oFACE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACQnC,gBAAAA,MADR,GACiB,KAAKqF,OAAL,GAAe,EAAf,GAAoB,CADrC;;AAAA,qBAEM,KAAKI,WAFX;AAAA;AAAA;AAAA;;AAAA,kDAGW,KAAKA,WAHhB;;AAAA;AAKQyB,gBAAAA,eALR,GAK0B,gCAL1B;AAMQC,gBAAAA,iBANR,GAM4BD,eAAe,CAAC5C,MAAhB,GAAyB,GANrD;AAAA;AAAA,uBAOoB,KAAKyB,QAAL,CAAc/F,MAAd,EAAsBmH,iBAAtB,CAPpB;;AAAA;AAOMC,gBAAAA,KAPN;;AAAA,sBAQMF,eAAe,KAAK7G,SAAS,CAAC+G,KAAD,EAAQ1J,UAAU,CAACa,KAAnB,EAA0B2I,eAAe,CAAC5C,MAA1C,EAAkDtE,MAAlD,CARnC;AAAA;AAAA;AAAA;;AASUqH,gBAAAA,YATV,GASyBhH,SAAS,CAAC+G,KAAD,EAAQ1J,UAAU,CAACa,KAAnB,EAA0B4I,iBAA1B,EAA6CnH,MAA7C,CATlC;AAUUsH,gBAAAA,SAVV,GAUsBD,YAAY,CAACE,KAAb,CAAmB,IAAnB,EAAyB,CAAzB,CAVtB;AAWUC,gBAAAA,YAXV,GAWyBC,MAAM,CAACH,SAAS,CAACC,KAAV,CAAgB,GAAhB,EAAqB,CAArB,EAAwBA,KAAxB,CAA8B,GAA9B,EAAmC,CAAnC,CAAD,CAAN,GAAgDD,SAAS,CAAChD,MAXnF;;AAAA,sBAYQkD,YAAY,GAAGL,iBAZvB;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAaoB,KAAKpB,QAAL,CAAc/F,MAAd,EAAsBwH,YAAtB,CAbpB;;AAAA;AAaMJ,gBAAAA,KAbN;;AAAA;AAeUM,gBAAAA,UAfV,GAeuBrH,SAAS,CAAC+G,KAAD,EAAQ1J,UAAU,CAACa,KAAnB,EAA0BiJ,YAA1B,EAAwCxH,MAAxC,CAfhC;AAgBI,qBAAKyF,WAAL,GAAmB,EAAnB;AACAiC,gBAAAA,UAAU,CACPH,KADH,CACS,IADT,EAEGI,MAFH,CAEU,UAACC,IAAD;AAAA,yBAAUA,IAAI,CAACtD,MAAL,GAAc,CAAxB;AAAA,iBAFV,EAGGuD,GAHH,CAGO,UAACD,IAAD;AAAA,yBAAUA,IAAI,CAACL,KAAL,CAAW,GAAX,CAAV;AAAA,iBAHP,EAIGO,OAJH,CAIW,iBAAkB;AAAA;AAAA,sBAAhBjI,GAAgB;AAAA,sBAAXI,KAAW;;AACzB,kBAAA,MAAI,CAACwF,WAAL,CAAiB5F,GAAjB,IAAwBI,KAAxB;AACD,iBANH;;AAjBJ;AAAA,kDAyBS,KAAKwF,WAzBd;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AA4BA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAmCE;AACF;AACA;AACA;AACA;AACE,qBAAQ;AACN,UAAI,OAAO,KAAKN,MAAL,CAAY4C,KAAnB,KAA6B,UAAjC,EAA6C;AAC3C,eAAO,KAAK5C,MAAL,CAAY4C,KAAZ,EAAP;AACD;;AACD,aAAO,KAAP;AACD;;;;gFA5CD,kBAAwB5C,MAAxB,EAAgC9C,OAAhC,EAAyC2F,MAAzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAC4B7C,MAAM,CAACS,KAAP,CAAa,CAAC;AAAE5F,kBAAAA,MAAM,EAAE,CAAV;AAAasE,kBAAAA,MAAM,EAAE;AAArB,iBAAD,CAAb,EAA4C0D,MAA5C,CAD5B;;AAAA;AACQC,gBAAAA,UADR,kBACiF,CADjF;AAEQjB,gBAAAA,QAFR,GAEmB,IAAI7J,UAAJ,CAAe8K,UAAf,CAFnB;AAIQC,gBAAAA,GAJR,GAIclB,QAAQ,CAACmB,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,CAJd;;AAAA,sBAMMD,GAAG,KAAK,MANd;AAAA;AAAA;AAAA;;AAOI9C,gBAAAA,YAAY,GAAG,IAAf;AAPJ;AAAA;;AAAA;AAAA,sBAQa8C,GAAG,KAAK,MARrB;AAAA;AAAA;AAAA;;AASI9C,gBAAAA,YAAY,GAAG,KAAf;AATJ;AAAA;;AAAA;AAAA,sBAWU,IAAIgD,SAAJ,CAAc,2BAAd,CAXV;;AAAA;AAcQC,gBAAAA,WAdR,GAcsBrB,QAAQ,CAACmB,SAAT,CAAmB,CAAnB,EAAsB/C,YAAtB,CAdtB;;AAAA,sBAgBMiD,WAAW,KAAK,EAhBtB;AAAA;AAAA;AAAA;;AAiBIhD,gBAAAA,OAAO,GAAG,KAAV;AAjBJ;AAAA;;AAAA;AAAA,sBAkBagD,WAAW,KAAK,EAlB7B;AAAA;AAAA;AAAA;;AAmBIhD,gBAAAA,OAAO,GAAG,IAAV;AACMiD,gBAAAA,cApBV,GAoB2BtB,QAAQ,CAACmB,SAAT,CAAmB,CAAnB,EAAsB/C,YAAtB,CApB3B;;AAAA,sBAqBQkD,cAAc,KAAK,CArB3B;AAAA;AAAA;AAAA;;AAAA,sBAsBY,IAAIpI,KAAJ,CAAU,+BAAV,CAtBZ;;AAAA;AAAA;AAAA;;AAAA;AAAA,sBAyBU,IAAIkI,SAAJ,CAAc,uBAAd,CAzBV;;AAAA;AA4BQ9C,gBAAAA,cA5BR,GA4ByBD,OAAO,GAC1B2B,QAAQ,CAACuB,SAAT,CAAmB,CAAnB,EAAsBnD,YAAtB,CAD0B,GAE1B4B,QAAQ,CAACwB,SAAT,CAAmB,CAAnB,EAAsBpD,YAAtB,CA9BN;AAAA,kDA+BS,IAAIF,OAAJ,CAAYC,MAAZ,EAAoBC,YAApB,EAAkCC,OAAlC,EAA2CC,cAA3C,EAA2DjD,OAA3D,CA/BT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;EAvOoBD,W;;AAsRtB,SAAS8C,OAAT;AACA,eAAeA,OAAf;AAEA;AACA;AACA;AACA;;IACMuD,Y;;;;;AACJ;AACF;AACA;AACA;AACA;AACE,wBAAYC,QAAZ,EAAsBC,aAAtB,EAAqC;AAAA;;AAAA;;AACnC;AACA,WAAKD,QAAL,GAAgBA,QAAhB;AACA,WAAKC,aAAL,GAAqBA,aAArB;AACA,WAAKC,UAAL,GAAkB,CAACF,QAAD,EAAWG,MAAX,CAAkBF,aAAlB,CAAlB;AAEA,WAAKG,sBAAL,GAA8B,IAA9B;AACA,WAAKC,6BAAL,GAAqC,IAArC;AACA,WAAK9F,UAAL,GAAkB,IAAlB;AARmC;AASpC;;;;;iGAED;AAAA;AAAA;AAAA;AAAA;AAAA;AACQ+F,gBAAAA,QADR,GACmB,CAAC,KAAKN,QAAL,CAAc9B,oBAAd,CAAmC,KAAK8B,QAAL,CAAcpD,cAAjD,CAAD,EACduD,MADc,CACP,KAAKF,aAAL,CAAmBd,GAAnB,CAAuB,UAACoB,IAAD;AAAA,yBAAUA,IAAI,CAACrC,oBAAL,CAA0BqC,IAAI,CAAC3D,cAA/B,CAAV;AAAA,iBAAvB,CADO,CADnB;AAAA;AAAA,uBAIsC4D,OAAO,CAACC,GAAR,CAAYH,QAAZ,CAJtC;;AAAA;AAIE,qBAAKF,sBAJP;AAAA,mDAKS,KAAKA,sBALd;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAQA;AACF;AACA;AACA;AACA;AACA;;;;;+EACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAe3G,gBAAAA,KAAf,iEAAuB,CAAvB;AAAA;AAAA,uBACQ,KAAKa,aAAL,EADR;;AAAA;AAAA;AAAA,uBAEQ,KAAKoG,2BAAL,EAFR;;AAAA;AAGMC,gBAAAA,OAHN,GAGgB,CAHhB;AAIMC,gBAAAA,aAJN,GAIsB,CAJtB;AAKW1J,gBAAAA,CALX,GAKe,CALf;;AAAA;AAAA,sBAKkBA,CAAC,GAAG,KAAKgJ,UAAL,CAAgBtE,MALtC;AAAA;AAAA;AAAA;;AAMUiF,gBAAAA,SANV,GAMsB,KAAKX,UAAL,CAAgBhJ,CAAhB,CANtB;AAOa4J,gBAAAA,EAPb,GAOkB,CAPlB;;AAAA;AAAA,sBAOqBA,EAAE,GAAG,KAAKC,WAAL,CAAiB7J,CAAjB,CAP1B;AAAA;AAAA;AAAA;;AAAA,sBAQUuC,KAAK,KAAKkH,OARpB;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAS0BE,SAAS,CAAC1C,UAAV,CAAqByC,aAArB,CAT1B;;AAAA;AAScvC,gBAAAA,GATd;AAAA,mDAUe,IAAI7J,YAAJ,CACL6J,GAAG,CAACvH,aADC,EACcuH,GAAG,CAACpH,eADlB,EAEL4J,SAAS,CAACvC,QAFL,EAEeuC,SAAS,CAACnE,YAFzB,EAEuCmE,SAAS,CAAChE,KAFjD,EAEwDgE,SAAS,CAACpE,MAFlE,CAVf;;AAAA;AAeMkE,gBAAAA,OAAO;AACPC,gBAAAA,aAAa;;AAhBnB;AAO+CE,gBAAAA,EAAE,EAPjD;AAAA;AAAA;;AAAA;AAkBIF,gBAAAA,aAAa,GAAG,CAAhB;;AAlBJ;AAK8C1J,gBAAAA,CAAC,EAL/C;AAAA;AAAA;;AAAA;AAAA,sBAqBQ,IAAIN,UAAJ,CAAe,qBAAf,CArBR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAwBA;AACF;AACA;AACA;AACA;;;;;oFACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,KAAK2D,UAAL,KAAoB,IAD1B;AAAA;AAAA;AAAA;;AAAA,mDAEW,KAAKA,UAFhB;;AAAA;AAIQ+F,gBAAAA,QAJR,GAImB,CAAC,KAAKN,QAAL,CAAc1F,aAAd,EAAD,EACd6F,MADc,CACP,KAAKF,aAAL,CAAmBd,GAAnB,CAAuB,UAACoB,IAAD;AAAA,yBAAUA,IAAI,CAACjG,aAAL,EAAV;AAAA,iBAAvB,CADO,CAJnB;AAAA;AAAA,uBAM2BkG,OAAO,CAACC,GAAR,CAAYH,QAAZ,CAN3B;;AAAA;AAME,qBAAKS,WANP;AAOE,qBAAKxG,UAAL,GAAkB,KAAKwG,WAAL,CAAiBC,MAAjB,CAAwB,UAAC3J,KAAD,EAAQ4J,IAAR;AAAA,yBAAiB5J,KAAK,GAAG4J,IAAzB;AAAA,iBAAxB,EAAuD,CAAvD,CAAlB;AAPF,mDAQS,KAAK1G,UARd;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;EA5DyBb,W;;AAwE3B,SAASqG,YAAT;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAsBmB,OAAtB;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;qEAXO,mBAAuBC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4BxH,YAAAA,OAA5B,iEAAsC,EAAtC;AAA0C2F,YAAAA,MAA1C;AAAA,+CACE9C,OAAO,CAAC4E,UAAR,CAAmBxM,gBAAgB,CAACuM,GAAD,EAAMxH,OAAN,CAAnC,EAAmD2F,MAAnD,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAYP,gBAAsB+B,eAAtB;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;6EAfO,mBAA+BC,WAA/B,EAA4ChC,MAA5C;AAAA;AAAA;AAAA;AAAA;AAAA,+CACE9C,OAAO,CAAC4E,UAAR,CAAmBvM,gBAAgB,CAACyM,WAAD,CAAnC,EAAkDhC,MAAlD,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAgBP,gBAAsBiC,QAAtB;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;sEAbO,mBAAwBC,IAAxB,EAA8BlC,MAA9B;AAAA;AAAA;AAAA;AAAA;AAAA,+CACE9C,OAAO,CAAC4E,UAAR,CAAmBrM,cAAc,CAACyM,IAAD,CAAjC,EAAyClC,MAAzC,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAcP,gBAAsBmC,QAAtB;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;sEAdO,mBAAwBC,IAAxB,EAA8BpC,MAA9B;AAAA;AAAA;AAAA;AAAA;AAAA,+CACE9C,OAAO,CAAC4E,UAAR,CAAmBtM,oBAAoB,CAAC4M,IAAD,CAAvC,EAA+CpC,MAA/C,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAeP,gBAAsBqC,QAAtB;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;;;sEAbO,mBAAwBC,OAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiCC,YAAAA,YAAjC,iEAAgD,EAAhD;AAAoDlI,YAAAA,OAApD,iEAA8D,EAA9D;AAAkE2F,YAAAA,MAAlE;AAAA;AAAA,mBACkB9C,OAAO,CAAC4E,UAAR,CAAmBxM,gBAAgB,CAACgN,OAAD,EAAUjI,OAAV,CAAnC,EAAuD2F,MAAvD,CADlB;;AAAA;AACCU,YAAAA,QADD;AAAA;AAAA,mBAEuBQ,OAAO,CAACC,GAAR,CAC1BoB,YAAY,CAAC1C,GAAb,CAAiB,UAACgC,GAAD;AAAA,qBAAS3E,OAAO,CAAC4E,UAAR,CAAmBxM,gBAAgB,CAACuM,GAAD,EAAMxH,OAAN,CAAnC,CAAT;AAAA,aAAjB,CAD0B,CAFvB;;AAAA;AAECsG,YAAAA,aAFD;AAAA,+CAME,IAAIF,YAAJ,CAAiBC,QAAjB,EAA2BC,aAA3B,CANF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAcP,OAAO,SAAS6B,gBAAT,CAA0BjK,MAA1B,EAAkCkK,QAAlC,EAA4C;AACjD,SAAO3M,YAAY,CAACyC,MAAD,EAASkK,QAAT,CAAnB;AACD;AAED,SAASpN,IAAT;AACA,SAASH,YAAT","sourcesContent":["/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\n"]},"metadata":{},"sourceType":"module"}