{"ast":null,"code":"import _slicedToArray from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.int8-array.js\";\nimport \"core-js/modules/es.typed-array.int16-array.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.float64-array.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.string.repeat.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.number.constructor.js\";\n\n/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  var s = 0;\n\n  for (var i = start; i < end; ++i) {\n    s += array[i];\n  }\n\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1:\n      // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n\n      break;\n\n    case 2:\n      // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n\n      break;\n\n    case 3:\n      // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n\n        case 64:\n          return new Float64Array(size);\n\n        default:\n          break;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  var view = new DataView(inBuffer);\n  var outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;\n  var samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;\n  var outArray = arrayForType(format, bitsPerSample, outSize); // let pixel = 0;\n\n  var bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) {\n    // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    var pixelBitSkip; // let sampleBitOffset = 0;\n\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample; // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    } // Bits per line rounds up to next byte boundary.\n\n\n    var bitsPerLine = tileWidth * pixelBitSkip;\n\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = bitsPerLine + 7 & ~7;\n    }\n\n    for (var y = 0; y < tileHeight; ++y) {\n      var lineBitOffset = y * bitsPerLine;\n\n      for (var x = 0; x < tileWidth; ++x) {\n        var pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;\n\n        for (var i = 0; i < samplesToTransfer; ++i) {\n          var bitOffset = pixelBitOffset + i * bitsPerSample;\n          var outIndex = (y * tileWidth + x) * samplesToTransfer + i;\n          var byteOffset = Math.floor(bitOffset / 8);\n          var innerBitOffset = bitOffset % 8;\n\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            var raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);\n            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;\n          } else {\n            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;\n          } // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n\n        } // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n\n      }\n    }\n  } else if (format === 3) {// floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n/**\n * GeoTIFF sub-file image.\n */\n\n\nvar GeoTIFFImage = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  function GeoTIFFImage(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    _classCallCheck(this, GeoTIFFImage);\n\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    var planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;\n\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n\n\n  _createClass(GeoTIFFImage, [{\n    key: \"getFileDirectory\",\n    value: function getFileDirectory() {\n      return this.fileDirectory;\n    }\n    /**\n     * Returns the associated parsed geo keys.\n     * @returns {Object} the parsed geo keys\n     */\n\n  }, {\n    key: \"getGeoKeys\",\n    value: function getGeoKeys() {\n      return this.geoKeys;\n    }\n    /**\n     * Returns the width of the image.\n     * @returns {Number} the width of the image\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.fileDirectory.ImageWidth;\n    }\n    /**\n     * Returns the height of the image.\n     * @returns {Number} the height of the image\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.fileDirectory.ImageLength;\n    }\n    /**\n     * Returns the number of samples per pixel.\n     * @returns {Number} the number of samples per pixel\n     */\n\n  }, {\n    key: \"getSamplesPerPixel\",\n    value: function getSamplesPerPixel() {\n      return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;\n    }\n    /**\n     * Returns the width of each tile.\n     * @returns {Number} the width of each tile\n     */\n\n  }, {\n    key: \"getTileWidth\",\n    value: function getTileWidth() {\n      return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n    }\n    /**\n     * Returns the height of each tile.\n     * @returns {Number} the height of each tile\n     */\n\n  }, {\n    key: \"getTileHeight\",\n    value: function getTileHeight() {\n      if (this.isTiled) {\n        return this.fileDirectory.TileLength;\n      }\n\n      if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n        return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n      }\n\n      return this.getHeight();\n    }\n  }, {\n    key: \"getBlockWidth\",\n    value: function getBlockWidth() {\n      return this.getTileWidth();\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight(y) {\n      if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n        return this.getTileHeight();\n      } else {\n        return this.getHeight() - y * this.getTileHeight();\n      }\n    }\n    /**\n     * Calculates the number of bytes for each pixel across all samples. Only full\n     * bytes are supported, an exception is thrown when this is not the case.\n     * @returns {Number} the bytes per pixel\n     */\n\n  }, {\n    key: \"getBytesPerPixel\",\n    value: function getBytesPerPixel() {\n      var bytes = 0;\n\n      for (var i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n        bytes += this.getSampleByteSize(i);\n      }\n\n      return bytes;\n    }\n  }, {\n    key: \"getSampleByteSize\",\n    value: function getSampleByteSize(i) {\n      if (i >= this.fileDirectory.BitsPerSample.length) {\n        throw new RangeError(\"Sample index \".concat(i, \" is out of range.\"));\n      }\n\n      return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n    }\n  }, {\n    key: \"getReaderForSample\",\n    value: function getReaderForSample(sampleIndex) {\n      var format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n      var bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n\n      switch (format) {\n        case 1:\n          // unsigned integer data\n          if (bitsPerSample <= 8) {\n            return DataView.prototype.getUint8;\n          } else if (bitsPerSample <= 16) {\n            return DataView.prototype.getUint16;\n          } else if (bitsPerSample <= 32) {\n            return DataView.prototype.getUint32;\n          }\n\n          break;\n\n        case 2:\n          // twos complement signed integer data\n          if (bitsPerSample <= 8) {\n            return DataView.prototype.getInt8;\n          } else if (bitsPerSample <= 16) {\n            return DataView.prototype.getInt16;\n          } else if (bitsPerSample <= 32) {\n            return DataView.prototype.getInt32;\n          }\n\n          break;\n\n        case 3:\n          switch (bitsPerSample) {\n            case 16:\n              return function (offset, littleEndian) {\n                return getFloat16(this, offset, littleEndian);\n              };\n\n            case 32:\n              return DataView.prototype.getFloat32;\n\n            case 64:\n              return DataView.prototype.getFloat64;\n\n            default:\n              break;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      throw Error('Unsupported data format/bitsPerSample');\n    }\n  }, {\n    key: \"getSampleFormat\",\n    value: function getSampleFormat() {\n      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    }\n  }, {\n    key: \"getBitsPerSample\",\n    value: function getBitsPerSample() {\n      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.fileDirectory.BitsPerSample[sampleIndex];\n    }\n  }, {\n    key: \"getArrayForSample\",\n    value: function getArrayForSample(sampleIndex, size) {\n      var format = this.getSampleFormat(sampleIndex);\n      var bitsPerSample = this.getBitsPerSample(sampleIndex);\n      return arrayForType(format, bitsPerSample, size);\n    }\n    /**\n     * Returns the decoded strip or tile.\n     * @param {Number} x the strip or tile x-offset\n     * @param {Number} y the tile y-offset (0 for stripped images)\n     * @param {Number} sample the sample to get for separated samples\n     * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     * @returns {Promise.<ArrayBuffer>}\n     */\n\n  }, {\n    key: \"getTileOrStrip\",\n    value: function () {\n      var _getTileOrStrip = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(x, y, sample, poolOrDecoder, signal) {\n        var _this = this;\n\n        var numTilesPerRow, numTilesPerCol, index, tiles, offset, byteCount, slice, request;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n                numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n                tiles = this.tiles;\n\n                if (this.planarConfiguration === 1) {\n                  index = y * numTilesPerRow + x;\n                } else if (this.planarConfiguration === 2) {\n                  index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;\n                }\n\n                if (this.isTiled) {\n                  offset = this.fileDirectory.TileOffsets[index];\n                  byteCount = this.fileDirectory.TileByteCounts[index];\n                } else {\n                  offset = this.fileDirectory.StripOffsets[index];\n                  byteCount = this.fileDirectory.StripByteCounts[index];\n                }\n\n                _context2.next = 7;\n                return this.source.fetch([{\n                  offset: offset,\n                  length: byteCount\n                }], signal);\n\n              case 7:\n                slice = _context2.sent[0];\n\n                if (tiles === null || !tiles[index]) {\n                  // resolve each request by potentially applying array normalization\n                  request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                    var data, sampleFormat, bitsPerSample;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return poolOrDecoder.decode(_this.fileDirectory, slice);\n\n                          case 2:\n                            data = _context.sent;\n                            sampleFormat = _this.getSampleFormat();\n                            bitsPerSample = _this.getBitsPerSample();\n\n                            if (needsNormalization(sampleFormat, bitsPerSample)) {\n                              data = normalizeArray(data, sampleFormat, _this.planarConfiguration, _this.getSamplesPerPixel(), bitsPerSample, _this.getTileWidth(), _this.getBlockHeight(y));\n                            }\n\n                            return _context.abrupt(\"return\", data);\n\n                          case 7:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }))(); // set the cache\n\n                  if (tiles !== null) {\n                    tiles[index] = request;\n                  }\n                } else {\n                  // get from the cache\n                  request = tiles[index];\n                } // cache the tile request\n\n\n                _context2.t0 = x;\n                _context2.t1 = y;\n                _context2.t2 = sample;\n                _context2.next = 14;\n                return request;\n\n              case 14:\n                _context2.t3 = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  x: _context2.t0,\n                  y: _context2.t1,\n                  sample: _context2.t2,\n                  data: _context2.t3\n                });\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getTileOrStrip(_x, _x2, _x3, _x4, _x5) {\n        return _getTileOrStrip.apply(this, arguments);\n      }\n\n      return getTileOrStrip;\n    }()\n    /**\n     * Internal read function.\n     * @private\n     * @param {Array} imageWindow The image window in pixel coordinates\n     * @param {Array} samples The selected samples (0-based indices)\n     * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n     * @param {Boolean} interleave Whether or not to write in an interleaved manner\n     * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n     * @param {number} width the width of window to be read into\n     * @param {number} height the height of window to be read into\n     * @param {number} resampleMethod the resampling method to be used when interpolating\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n     */\n\n  }, {\n    key: \"_readRaster\",\n    value: function () {\n      var _readRaster2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n        var _this2 = this;\n\n        var tileWidth, tileHeight, imageWidth, imageHeight, minXTile, maxXTile, minYTile, maxYTile, windowWidth, bytesPerPixel, srcSampleOffsets, sampleReaders, i, promises, littleEndian, yTile, xTile, _loop, sampleIndex, resampled;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                tileWidth = this.getTileWidth();\n                tileHeight = this.getTileHeight();\n                imageWidth = this.getWidth();\n                imageHeight = this.getHeight();\n                minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n                maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));\n                minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n                maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));\n                windowWidth = imageWindow[2] - imageWindow[0];\n                bytesPerPixel = this.getBytesPerPixel();\n                srcSampleOffsets = [];\n                sampleReaders = [];\n\n                for (i = 0; i < samples.length; ++i) {\n                  if (this.planarConfiguration === 1) {\n                    srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n                  } else {\n                    srcSampleOffsets.push(0);\n                  }\n\n                  sampleReaders.push(this.getReaderForSample(samples[i]));\n                }\n\n                promises = [];\n                littleEndian = this.littleEndian;\n\n                for (yTile = minYTile; yTile < maxYTile; ++yTile) {\n                  for (xTile = minXTile; xTile < maxXTile; ++xTile) {\n                    _loop = function _loop(sampleIndex) {\n                      var si = sampleIndex;\n                      var sample = samples[sampleIndex];\n\n                      if (_this2.planarConfiguration === 2) {\n                        bytesPerPixel = _this2.getSampleByteSize(sampleIndex);\n                      }\n\n                      var promise = _this2.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n\n                      promises.push(promise);\n                      promise.then(function (tile) {\n                        var buffer = tile.data;\n                        var dataView = new DataView(buffer);\n\n                        var blockHeight = _this2.getBlockHeight(tile.y);\n\n                        var firstLine = tile.y * tileHeight;\n                        var firstCol = tile.x * tileWidth;\n                        var lastLine = firstLine + blockHeight;\n                        var lastCol = (tile.x + 1) * tileWidth;\n                        var reader = sampleReaders[si];\n                        var ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n                        var xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n                        for (var y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n                          for (var x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                            var pixelOffset = (y * tileWidth + x) * bytesPerPixel;\n                            var value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);\n                            var windowCoordinate = void 0;\n\n                            if (interleave) {\n                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;\n                              valueArrays[windowCoordinate] = value;\n                            } else {\n                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];\n                              valueArrays[si][windowCoordinate] = value;\n                            }\n                          }\n                        }\n                      });\n                    };\n\n                    for (sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n                      _loop(sampleIndex);\n                    }\n                  }\n                }\n\n                _context3.next = 18;\n                return Promise.all(promises);\n\n              case 18:\n                if (!(width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height)) {\n                  _context3.next = 23;\n                  break;\n                }\n\n                if (interleave) {\n                  resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);\n                } else {\n                  resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);\n                }\n\n                resampled.width = width;\n                resampled.height = height;\n                return _context3.abrupt(\"return\", resampled);\n\n              case 23:\n                valueArrays.width = width || imageWindow[2] - imageWindow[0];\n                valueArrays.height = height || imageWindow[3] - imageWindow[1];\n                return _context3.abrupt(\"return\", valueArrays);\n\n              case 26:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _readRaster(_x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14) {\n        return _readRaster2.apply(this, arguments);\n      }\n\n      return _readRaster;\n    }()\n    /**\n     * Reads raster data from the image. This function reads all selected samples\n     * into separate arrays of the correct type for that sample or into a single\n     * combined array when `interleave` is set. When provided, only a subset\n     * of the raster is read for each sample.\n     *\n     * @param {ReadRasterOptions} [options={}] optional parameters\n     * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n     */\n\n  }, {\n    key: \"readRasters\",\n    value: function () {\n      var _readRasters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n        var _ref2,\n            wnd,\n            _ref2$samples,\n            samples,\n            interleave,\n            _ref2$pool,\n            pool,\n            width,\n            height,\n            resampleMethod,\n            fillValue,\n            signal,\n            imageWindow,\n            imageWindowWidth,\n            imageWindowHeight,\n            numPixels,\n            samplesPerPixel,\n            i,\n            _i,\n            valueArrays,\n            format,\n            bitsPerSample,\n            _i2,\n            valueArray,\n            poolOrDecoder,\n            result,\n            _args4 = arguments;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _ref2 = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {}, wnd = _ref2.window, _ref2$samples = _ref2.samples, samples = _ref2$samples === void 0 ? [] : _ref2$samples, interleave = _ref2.interleave, _ref2$pool = _ref2.pool, pool = _ref2$pool === void 0 ? null : _ref2$pool, width = _ref2.width, height = _ref2.height, resampleMethod = _ref2.resampleMethod, fillValue = _ref2.fillValue, signal = _ref2.signal;\n                imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n\n                if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new Error('Invalid subsets');\n\n              case 4:\n                imageWindowWidth = imageWindow[2] - imageWindow[0];\n                imageWindowHeight = imageWindow[3] - imageWindow[1];\n                numPixels = imageWindowWidth * imageWindowHeight;\n                samplesPerPixel = this.getSamplesPerPixel();\n\n                if (!(!samples || !samples.length)) {\n                  _context4.next = 12;\n                  break;\n                }\n\n                for (i = 0; i < samplesPerPixel; ++i) {\n                  samples.push(i);\n                }\n\n                _context4.next = 19;\n                break;\n\n              case 12:\n                _i = 0;\n\n              case 13:\n                if (!(_i < samples.length)) {\n                  _context4.next = 19;\n                  break;\n                }\n\n                if (!(samples[_i] >= samplesPerPixel)) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.reject(new RangeError(\"Invalid sample index '\".concat(samples[_i], \"'.\"))));\n\n              case 16:\n                ++_i;\n                _context4.next = 13;\n                break;\n\n              case 19:\n                if (interleave) {\n                  format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n                  bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n                  valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n\n                  if (fillValue) {\n                    valueArrays.fill(fillValue);\n                  }\n                } else {\n                  valueArrays = [];\n\n                  for (_i2 = 0; _i2 < samples.length; ++_i2) {\n                    valueArray = this.getArrayForSample(samples[_i2], numPixels);\n\n                    if (Array.isArray(fillValue) && _i2 < fillValue.length) {\n                      valueArray.fill(fillValue[_i2]);\n                    } else if (fillValue && !Array.isArray(fillValue)) {\n                      valueArray.fill(fillValue);\n                    }\n\n                    valueArrays.push(valueArray);\n                  }\n                }\n\n                _context4.t0 = pool;\n\n                if (_context4.t0) {\n                  _context4.next = 25;\n                  break;\n                }\n\n                _context4.next = 24;\n                return getDecoder(this.fileDirectory);\n\n              case 24:\n                _context4.t0 = _context4.sent;\n\n              case 25:\n                poolOrDecoder = _context4.t0;\n                _context4.next = 28;\n                return this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);\n\n              case 28:\n                result = _context4.sent;\n                return _context4.abrupt(\"return\", result);\n\n              case 30:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function readRasters() {\n        return _readRasters.apply(this, arguments);\n      }\n\n      return readRasters;\n    }()\n    /**\n     * Reads raster data from the image as RGB. The result is always an\n     * interleaved typed array.\n     * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n     * When no other method is applicable, the first sample is used to produce a\n     * greayscale image.\n     * When provided, only a subset of the raster is read for each sample.\n     *\n     * @param {Object} [options] optional parameters\n     * @param {Array<number>} [options.window] the subset to read data from in pixels.\n     * @param {boolean} [options.interleave=true] whether the data shall be read\n     *                                             in one single array or separate\n     *                                             arrays.\n     * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n     * @param {number} [options.width] The desired width of the output. When the width is no the\n     *                                 same as the images, resampling will be performed.\n     * @param {number} [options.height] The desired height of the output. When the width is no the\n     *                                  same as the images, resampling will be performed.\n     * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n     * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n     * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n     *                                       to be aborted\n     * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n     */\n\n  }, {\n    key: \"readRGB\",\n    value: function () {\n      var _readRGB = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        var _ref3,\n            window,\n            _ref3$interleave,\n            interleave,\n            _ref3$pool,\n            pool,\n            width,\n            height,\n            resampleMethod,\n            _ref3$enableAlpha,\n            enableAlpha,\n            signal,\n            imageWindow,\n            pi,\n            s,\n            i,\n            samples,\n            subOptions,\n            fileDirectory,\n            raster,\n            max,\n            data,\n            red,\n            green,\n            blue,\n            _i3,\n            j,\n            _args5 = arguments;\n\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _ref3 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, window = _ref3.window, _ref3$interleave = _ref3.interleave, interleave = _ref3$interleave === void 0 ? true : _ref3$interleave, _ref3$pool = _ref3.pool, pool = _ref3$pool === void 0 ? null : _ref3$pool, width = _ref3.width, height = _ref3.height, resampleMethod = _ref3.resampleMethod, _ref3$enableAlpha = _ref3.enableAlpha, enableAlpha = _ref3$enableAlpha === void 0 ? false : _ref3$enableAlpha, signal = _ref3.signal;\n                imageWindow = window || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n\n                if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                throw new Error('Invalid subsets');\n\n              case 4:\n                pi = this.fileDirectory.PhotometricInterpretation;\n\n                if (!(pi === photometricInterpretations.RGB)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                s = [0, 1, 2];\n\n                if (!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {\n                  s = [];\n\n                  for (i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n                    s.push(i);\n                  }\n                }\n\n                return _context5.abrupt(\"return\", this.readRasters({\n                  window: window,\n                  interleave: interleave,\n                  samples: s,\n                  pool: pool,\n                  width: width,\n                  height: height,\n                  resampleMethod: resampleMethod,\n                  signal: signal\n                }));\n\n              case 9:\n                _context5.t0 = pi;\n                _context5.next = _context5.t0 === photometricInterpretations.WhiteIsZero ? 12 : _context5.t0 === photometricInterpretations.BlackIsZero ? 12 : _context5.t0 === photometricInterpretations.Palette ? 12 : _context5.t0 === photometricInterpretations.CMYK ? 14 : _context5.t0 === photometricInterpretations.YCbCr ? 16 : _context5.t0 === photometricInterpretations.CIELab ? 16 : 18;\n                break;\n\n              case 12:\n                samples = [0];\n                return _context5.abrupt(\"break\", 19);\n\n              case 14:\n                samples = [0, 1, 2, 3];\n                return _context5.abrupt(\"break\", 19);\n\n              case 16:\n                samples = [0, 1, 2];\n                return _context5.abrupt(\"break\", 19);\n\n              case 18:\n                throw new Error('Invalid or unsupported photometric interpretation.');\n\n              case 19:\n                subOptions = {\n                  window: imageWindow,\n                  interleave: true,\n                  samples: samples,\n                  pool: pool,\n                  width: width,\n                  height: height,\n                  resampleMethod: resampleMethod,\n                  signal: signal\n                };\n                fileDirectory = this.fileDirectory;\n                _context5.next = 23;\n                return this.readRasters(subOptions);\n\n              case 23:\n                raster = _context5.sent;\n                max = Math.pow(2, this.fileDirectory.BitsPerSample[0]);\n                _context5.t1 = pi;\n                _context5.next = _context5.t1 === photometricInterpretations.WhiteIsZero ? 28 : _context5.t1 === photometricInterpretations.BlackIsZero ? 30 : _context5.t1 === photometricInterpretations.Palette ? 32 : _context5.t1 === photometricInterpretations.CMYK ? 34 : _context5.t1 === photometricInterpretations.YCbCr ? 36 : _context5.t1 === photometricInterpretations.CIELab ? 38 : 40;\n                break;\n\n              case 28:\n                data = fromWhiteIsZero(raster, max);\n                return _context5.abrupt(\"break\", 41);\n\n              case 30:\n                data = fromBlackIsZero(raster, max);\n                return _context5.abrupt(\"break\", 41);\n\n              case 32:\n                data = fromPalette(raster, fileDirectory.ColorMap);\n                return _context5.abrupt(\"break\", 41);\n\n              case 34:\n                data = fromCMYK(raster);\n                return _context5.abrupt(\"break\", 41);\n\n              case 36:\n                data = fromYCbCr(raster);\n                return _context5.abrupt(\"break\", 41);\n\n              case 38:\n                data = fromCIELab(raster);\n                return _context5.abrupt(\"break\", 41);\n\n              case 40:\n                throw new Error('Unsupported photometric interpretation.');\n\n              case 41:\n                // if non-interleaved data is requested, we must split the channels\n                // into their respective arrays\n                if (!interleave) {\n                  red = new Uint8Array(data.length / 3);\n                  green = new Uint8Array(data.length / 3);\n                  blue = new Uint8Array(data.length / 3);\n\n                  for (_i3 = 0, j = 0; _i3 < data.length; _i3 += 3, ++j) {\n                    red[j] = data[_i3];\n                    green[j] = data[_i3 + 1];\n                    blue[j] = data[_i3 + 2];\n                  }\n\n                  data = [red, green, blue];\n                }\n\n                data.width = raster.width;\n                data.height = raster.height;\n                return _context5.abrupt(\"return\", data);\n\n              case 45:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function readRGB() {\n        return _readRGB.apply(this, arguments);\n      }\n\n      return readRGB;\n    }()\n    /**\n     * Returns an array of tiepoints.\n     * @returns {Object[]}\n     */\n\n  }, {\n    key: \"getTiePoints\",\n    value: function getTiePoints() {\n      if (!this.fileDirectory.ModelTiepoint) {\n        return [];\n      }\n\n      var tiePoints = [];\n\n      for (var i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n        tiePoints.push({\n          i: this.fileDirectory.ModelTiepoint[i],\n          j: this.fileDirectory.ModelTiepoint[i + 1],\n          k: this.fileDirectory.ModelTiepoint[i + 2],\n          x: this.fileDirectory.ModelTiepoint[i + 3],\n          y: this.fileDirectory.ModelTiepoint[i + 4],\n          z: this.fileDirectory.ModelTiepoint[i + 5]\n        });\n      }\n\n      return tiePoints;\n    }\n    /**\n     * Returns the parsed GDAL metadata items.\n     *\n     * If sample is passed to null, dataset-level metadata will be returned.\n     * Otherwise only metadata specific to the provided sample will be returned.\n     *\n     * @param {number} [sample=null] The sample index.\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"getGDALMetadata\",\n    value: function getGDALMetadata() {\n      var sample = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var metadata = {};\n\n      if (!this.fileDirectory.GDAL_METADATA) {\n        return null;\n      }\n\n      var string = this.fileDirectory.GDAL_METADATA;\n      var items = findTagsByName(string, 'Item');\n\n      if (sample === null) {\n        items = items.filter(function (item) {\n          return getAttribute(item, 'sample') === undefined;\n        });\n      } else {\n        items = items.filter(function (item) {\n          return Number(getAttribute(item, 'sample')) === sample;\n        });\n      }\n\n      for (var i = 0; i < items.length; ++i) {\n        var item = items[i];\n        metadata[getAttribute(item, 'name')] = item.inner;\n      }\n\n      return metadata;\n    }\n    /**\n     * Returns the GDAL nodata value\n     * @returns {number|null}\n     */\n\n  }, {\n    key: \"getGDALNoData\",\n    value: function getGDALNoData() {\n      if (!this.fileDirectory.GDAL_NODATA) {\n        return null;\n      }\n\n      var string = this.fileDirectory.GDAL_NODATA;\n      return Number(string.substring(0, string.length - 1));\n    }\n    /**\n     * Returns the image origin as a XYZ-vector. When the image has no affine\n     * transformation, then an exception is thrown.\n     * @returns {Array<number>} The origin as a vector\n     */\n\n  }, {\n    key: \"getOrigin\",\n    value: function getOrigin() {\n      var tiePoints = this.fileDirectory.ModelTiepoint;\n      var modelTransformation = this.fileDirectory.ModelTransformation;\n\n      if (tiePoints && tiePoints.length === 6) {\n        return [tiePoints[3], tiePoints[4], tiePoints[5]];\n      }\n\n      if (modelTransformation) {\n        return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];\n      }\n\n      throw new Error('The image does not have an affine transformation.');\n    }\n    /**\n     * Returns the image resolution as a XYZ-vector. When the image has no affine\n     * transformation, then an exception is thrown.\n     * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n     *                                             in cases when the current image does not have the\n     *                                             required tags on its own.\n     * @returns {Array<number>} The resolution as a vector\n     */\n\n  }, {\n    key: \"getResolution\",\n    value: function getResolution() {\n      var referenceImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var modelPixelScale = this.fileDirectory.ModelPixelScale;\n      var modelTransformation = this.fileDirectory.ModelTransformation;\n\n      if (modelPixelScale) {\n        return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];\n      }\n\n      if (modelTransformation) {\n        return [modelTransformation[0], modelTransformation[5], modelTransformation[10]];\n      }\n\n      if (referenceImage) {\n        var _referenceImage$getRe = referenceImage.getResolution(),\n            _referenceImage$getRe2 = _slicedToArray(_referenceImage$getRe, 3),\n            refResX = _referenceImage$getRe2[0],\n            refResY = _referenceImage$getRe2[1],\n            refResZ = _referenceImage$getRe2[2];\n\n        return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];\n      }\n\n      throw new Error('The image does not have an affine transformation.');\n    }\n    /**\n     * Returns whether or not the pixels of the image depict an area (or point).\n     * @returns {Boolean} Whether the pixels are a point\n     */\n\n  }, {\n    key: \"pixelIsArea\",\n    value: function pixelIsArea() {\n      return this.geoKeys.GTRasterTypeGeoKey === 1;\n    }\n    /**\n     * Returns the image bounding box as an array of 4 values: min-x, min-y,\n     * max-x and max-y. When the image has no affine transformation, then an\n     * exception is thrown.\n     * @returns {Array<number>} The bounding box\n     */\n\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox() {\n      var origin = this.getOrigin();\n      var resolution = this.getResolution();\n      var x1 = origin[0];\n      var y1 = origin[1];\n      var x2 = x1 + resolution[0] * this.getWidth();\n      var y2 = y1 + resolution[1] * this.getHeight();\n      return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n    }\n  }]);\n\n  return GeoTIFFImage;\n}();\n\nexport default GeoTIFFImage;","map":{"version":3,"sources":["D:/Java/JavaEE/IdeaProjects/ocean-vis/node_modules/geotiff/dist-module/geotiffimage.js"],"names":["getFloat16","getAttribute","findTagsByName","photometricInterpretations","ExtraSamplesValues","fromWhiteIsZero","fromBlackIsZero","fromPalette","fromCMYK","fromYCbCr","fromCIELab","getDecoder","resample","resampleInterleaved","sum","array","start","end","s","i","arrayForType","format","bitsPerSample","size","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","Error","needsNormalization","normalizeArray","inBuffer","planarConfiguration","samplesPerPixel","tileWidth","tileHeight","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","y","lineBitOffset","x","pixelBitOffset","bitOffset","outIndex","byteOffset","Math","floor","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","GeoTIFFImage","fileDirectory","geoKeys","dataView","littleEndian","cache","source","tiles","isTiled","StripOffsets","PlanarConfiguration","ImageWidth","ImageLength","SamplesPerPixel","TileWidth","getWidth","TileLength","RowsPerStrip","min","getHeight","getTileWidth","getTileHeight","bytes","BitsPerSample","length","getSampleByteSize","RangeError","ceil","sampleIndex","SampleFormat","prototype","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","TileOffsets","byteCount","TileByteCounts","StripByteCounts","fetch","slice","request","decode","data","sampleFormat","getSamplesPerPixel","getBlockHeight","imageWindow","samples","valueArrays","interleave","width","height","resampleMethod","imageWidth","imageHeight","minXTile","max","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","getBytesPerPixel","srcSampleOffsets","sampleReaders","push","getReaderForSample","promises","yTile","xTile","si","promise","getTileOrStrip","then","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","value","call","windowCoordinate","Promise","all","resampled","wnd","window","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","apply","fill","valueArray","getArrayForSample","Array","isArray","_readRaster","result","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","readRasters","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","raster","ColorMap","red","green","blue","j","ModelTiepoint","tiePoints","k","z","metadata","GDAL_METADATA","string","items","filter","item","undefined","Number","inner","GDAL_NODATA","substring","modelTransformation","ModelTransformation","referenceImage","modelPixelScale","ModelPixelScale","getResolution","refResX","refResY","refResZ","GTRasterTypeGeoKey","origin","getOrigin","resolution","x1","y1","x2","y2"],"mappings":"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","sourcesContent":["/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          promises.push(promise);\n          promise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n"]},"metadata":{},"sourceType":"module"}